/// <reference types="node" resolution-mode="require"/>
import type { AbstractLevel } from 'abstract-level';
import type { Web5ManagedAgent } from './types/agent.js';
export interface SyncManager {
    agent: Web5ManagedAgent;
    registerIdentity(options: {
        did: string;
    }): Promise<void>;
    startSync(options: {
        interval: number;
    }): Promise<void>;
    stopSync(): void;
    push(): Promise<void>;
    pull(): Promise<void>;
}
type LevelDatabase = AbstractLevel<string | Buffer | Uint8Array, string, string>;
export type SyncManagerOptions = {
    agent?: Web5ManagedAgent;
    dataPath?: string;
    db?: LevelDatabase;
};
export declare class SyncManagerLevel implements SyncManager {
    /**
     * Holds the instance of a `Web5ManagedAgent` that represents the current
     * execution context for the `KeyManager`. This agent is utilized
     * to interact with other Web5 agent components. It's vital
     * to ensure this instance is set to correctly contextualize
     * operations within the broader Web5 agent framework.
     */
    private _agent?;
    private _db;
    private _syncIntervalId?;
    constructor(options?: SyncManagerOptions);
    /**
     * Retrieves the `Web5ManagedAgent` execution context.
     * If the `agent` instance proprety is undefined, it will throw an error.
     *
     * @returns The `Web5ManagedAgent` instance that represents the current execution
     * context.
     *
     * @throws Will throw an error if the `agent` instance property is undefined.
     */
    get agent(): Web5ManagedAgent;
    set agent(agent: Web5ManagedAgent);
    clear(): Promise<void>;
    pull(): Promise<void>;
    push(): Promise<void>;
    registerIdentity(options: {
        did: string;
    }): Promise<void>;
    startSync(options: {
        interval: number;
    }): Promise<void>;
    stopSync(): void;
    private enqueueOperations;
    private getDwnEventLog;
    private getDwnMessage;
    private getSyncPeerState;
    private getWatermark;
    private setWatermark;
    /**
     * The message store is used to prevent "echoes" that occur during a sync pull operation.
     * After a message is confirmed to already be synchronized on the local DWN, its CID is added
     * to the message store to ensure that any subsequent pull attempts are skipped.
     */
    private messageExists;
    private addMessage;
    private getMessageStore;
    private getWatermarkStore;
    private getPushQueue;
    private getPullQueue;
    private getDwnMessageType;
}
export {};
//# sourceMappingURL=sync-manager.d.ts.map