var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Jose } from '@web5/crypto';
import * as didUtils from '@web5/dids/utils';
import { Convert, removeUndefinedProperties } from '@web5/common';
import { EventLogLevel, DataStoreLevel, MessageStoreLevel, } from '@tbd54566975/dwn-sdk-js/stores';
import { Cid, Dwn, Message, EventsGet, DataStream, RecordsRead, MessagesGet, RecordsWrite, RecordsQuery, DwnMethodName, RecordsDelete, ProtocolsQuery, DwnInterfaceName, ProtocolsConfigure, } from '@tbd54566975/dwn-sdk-js';
import { isManagedKeyPair } from './utils.js';
import { blobToIsomorphicNodeReadable, webReadableToIsomorphicNodeReadable } from './utils.js';
const dwnMessageCreators = {
    [DwnInterfaceName.Events + DwnMethodName.Get]: EventsGet,
    [DwnInterfaceName.Messages + DwnMethodName.Get]: MessagesGet,
    [DwnInterfaceName.Records + DwnMethodName.Read]: RecordsRead,
    [DwnInterfaceName.Records + DwnMethodName.Query]: RecordsQuery,
    [DwnInterfaceName.Records + DwnMethodName.Write]: RecordsWrite,
    [DwnInterfaceName.Records + DwnMethodName.Delete]: RecordsDelete,
    [DwnInterfaceName.Protocols + DwnMethodName.Query]: ProtocolsQuery,
    [DwnInterfaceName.Protocols + DwnMethodName.Configure]: ProtocolsConfigure,
};
export class DwnManager {
    constructor(options) {
        this._agent = options.agent;
        this._dwn = options.dwn;
    }
    /**
     * Retrieves the `Web5ManagedAgent` execution context.
     * If the `agent` instance proprety is undefined, it will throw an error.
     *
     * @returns The `Web5ManagedAgent` instance that represents the current execution
     * context.
     *
     * @throws Will throw an error if the `agent` instance property is undefined.
     */
    get agent() {
        if (this._agent === undefined) {
            throw new Error('DidManager: Unable to determine agent execution context.');
        }
        return this._agent;
    }
    set agent(agent) {
        this._agent = agent;
    }
    get dwn() {
        return this._dwn;
    }
    static create(options) {
        return __awaiter(this, void 0, void 0, function* () {
            let { agent, dataPath, didResolver, dwn } = options !== null && options !== void 0 ? options : {};
            dataPath !== null && dataPath !== void 0 ? dataPath : (dataPath = 'DATA/AGENT');
            if (dwn === undefined) {
                const dataStore = new DataStoreLevel({
                    blockstoreLocation: `${dataPath}/DWN_DATASTORE`
                });
                const eventLog = new EventLogLevel({
                    location: `${dataPath}/DWN_EVENTLOG`
                });
                const messageStore = new MessageStoreLevel(({
                    blockstoreLocation: `${dataPath}/DWN_MESSAGESTORE`,
                    indexLocation: `${dataPath}/DWN_MESSAGEINDEX`
                }));
                dwn = yield Dwn.create({
                    dataStore,
                    // @ts-expect-error because `dwn-sdk-js` expects its internal DidResolver implementation.
                    didResolver,
                    eventLog,
                    messageStore,
                });
            }
            return new DwnManager({ agent, dwn });
        });
    }
    processRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { message, dataStream } = yield this.constructDwnMessage({ request });
            let reply;
            if (request.store !== false) {
                reply = yield this._dwn.processMessage(request.target, message, dataStream);
            }
            else {
                reply = { status: { code: 202, detail: 'Accepted' } };
            }
            return {
                reply,
                message: message,
                messageCid: yield Message.getCid(message)
            };
        });
    }
    sendRequest(request) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const dwnRpcRequest = { targetDid: request.target };
            let messageData;
            if ('messageCid' in request) {
                const { message, data } = yield this.getDwnMessage({
                    author: request.author,
                    messageCid: request.messageCid,
                    messageType: request.messageType
                });
                dwnRpcRequest.message = message;
                messageData = data;
            }
            else {
                const { message } = yield this.constructDwnMessage({ request });
                dwnRpcRequest.message = message;
                messageData = request.dataStream;
            }
            if (messageData) {
                dwnRpcRequest.data = messageData;
            }
            const { didDocument, didResolutionMetadata } = yield this.agent.didResolver.resolve(request.target);
            if (!didDocument) {
                const errorCode = (_a = `${didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.error}: `) !== null && _a !== void 0 ? _a : '';
                const defaultMessage = `Unable to resolve target DID: ${request.target}`;
                const errorMessage = (_b = didResolutionMetadata === null || didResolutionMetadata === void 0 ? void 0 : didResolutionMetadata.errorMessage) !== null && _b !== void 0 ? _b : defaultMessage;
                throw new Error(`DwnManager: ${errorCode}${errorMessage}`);
            }
            const [service] = didUtils.getServices({ didDocument, id: '#dwn' });
            if (!service) {
                throw new Error(`DwnManager: DID Document of '${request.target}' has no service endpoints with ID '#dwn'`);
            }
            if (!didUtils.isDwnServiceEndpoint(service.serviceEndpoint)) {
                throw new Error(`DwnManager: Malformed '#dwn' service endpoint. Expected array of node addresses.`);
            }
            const dwnEndpointUrls = service.serviceEndpoint.nodes;
            let dwnReply;
            let errorMessages = [];
            // try sending to author's publicly addressable dwn's until first request succeeds.
            for (let dwnUrl of dwnEndpointUrls) {
                dwnRpcRequest.dwnUrl = dwnUrl;
                try {
                    dwnReply = yield this.agent.rpcClient.sendDwnRequest(dwnRpcRequest);
                    break;
                }
                catch (error) {
                    const message = (error instanceof Error) ? error.message : 'Uknown error';
                    errorMessages.push({ url: dwnUrl, message });
                }
            }
            if (!dwnReply) {
                throw new Error(JSON.stringify(errorMessages));
            }
            return {
                message: dwnRpcRequest.message,
                messageCid: yield Message.getCid(dwnRpcRequest.message),
                reply: dwnReply,
            };
        });
    }
    constructDwnMessage(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { request } = options;
            let readableStream;
            // TODO: Consider refactoring to move data transformations imposed by fetch() limitations to the HTTP transport-related methods.
            if (request.messageType === 'RecordsWrite') {
                const messageOptions = request.messageOptions;
                if (request.dataStream && !messageOptions.data) {
                    const { dataStream } = request;
                    let isomorphicNodeReadable;
                    if (dataStream instanceof Blob) {
                        isomorphicNodeReadable = blobToIsomorphicNodeReadable(dataStream);
                        readableStream = blobToIsomorphicNodeReadable(dataStream);
                    }
                    else if (dataStream instanceof ReadableStream) {
                        const [forCid, forProcessMessage] = dataStream.tee();
                        isomorphicNodeReadable = webReadableToIsomorphicNodeReadable(forCid);
                        readableStream = webReadableToIsomorphicNodeReadable(forProcessMessage);
                    }
                    // @ts-ignore
                    messageOptions.dataCid = yield Cid.computeDagPbCidFromStream(isomorphicNodeReadable);
                    // @ts-ignore
                    (_a = messageOptions.dataSize) !== null && _a !== void 0 ? _a : (messageOptions.dataSize = isomorphicNodeReadable['bytesRead']);
                }
            }
            const signingKeyId = yield this.getAuthorSigningKeyId({ did: request.author });
            // ! TODO: Remove this once DWN SDK supports external signers.
            const dwnSignatureInput = this.getTempSignatureInput({ signingKeyId });
            // TODO: Figure out how to narrow this type.
            const messageCreateInput = Object.assign(Object.assign({}, request.messageOptions), { authorizationSignatureInput: dwnSignatureInput });
            const messageCreator = dwnMessageCreators[request.messageType];
            // ! TODO: START Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            // MP Step 1: Store the original methods.
            const originalCreateAuthorization = RecordsWrite.createAuthorization;
            const originalSignAsAuthorization = Message.signAsAuthorization;
            // MP Step 2: Replace the methods.
            RecordsWrite.createAuthorization = (recordId, contextId, descriptorCid, attestation, encryption) => this.createAuthorization(recordId, contextId, descriptorCid, attestation, encryption, signingKeyId);
            Message.signAsAuthorization = (descriptor, signatureInput, permissionsGrantId) => this.signAsAuthorization(descriptor, signingKeyId, permissionsGrantId);
            // MP Step 3: Call the method that required monkey patching.
            const dwnMessage = yield messageCreator.create(messageCreateInput);
            // MP Step 4: Restore the original methods.
            RecordsWrite.createAuthorization = originalCreateAuthorization;
            Message.signAsAuthorization = originalSignAsAuthorization;
            // ! TODO: END Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            return { message: dwnMessage.toJSON(), dataStream: readableStream };
        });
    }
    getAuthorSigningKeyId(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { did } = options;
            // Get the agent instance.
            const agent = this.agent;
            // Get the method-specific default signing key.
            const signingKeyId = yield agent.didManager.getDefaultSigningKey({ did });
            if (!signingKeyId) {
                throw new Error(`DwnManager: Unable to determine signing key for author: '${did}'`);
            }
            return signingKeyId;
        });
    }
    getDwnMessage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { author, messageType, messageCid } = options;
            const signingKeyId = yield this.getAuthorSigningKeyId({ did: author });
            // ! TODO: START Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            const dwnSignatureInput = this.getTempSignatureInput({ signingKeyId });
            // MP Step 1: Store the original methods.
            const originalSignAsAuthorization = Message.signAsAuthorization;
            // MP Step 2: Replace the methods.
            Message.signAsAuthorization = (descriptor, signatureInput, permissionsGrantId) => this.signAsAuthorization(descriptor, signingKeyId, permissionsGrantId);
            // MP Step 3: Call the method that required monkey patching.
            const messagesGet = yield MessagesGet.create({
                authorizationSignatureInput: dwnSignatureInput,
                messageCids: [messageCid]
            });
            // MP Step 4: Restore the original methods.
            Message.signAsAuthorization = originalSignAsAuthorization;
            // ! TODO: END Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            const result = yield this._dwn.processMessage(author, messagesGet.toJSON());
            if (!(result.messages && result.messages.length === 1)) {
                throw new Error('TODO: figure out error message');
            }
            const [messageEntry] = result.messages;
            let { message } = messageEntry;
            if (!message) {
                throw new Error('TODO: message not found');
            }
            let dwnMessage = { message };
            /** If the message is a RecordsWrite, either data will be present, OR
             * we have to fetch it using a RecordsRead. */
            if (messageType === 'RecordsWrite') {
                const { encodedData } = messageEntry;
                const writeMessage = message;
                if (encodedData) {
                    const dataBytes = Convert.base64Url(encodedData).toUint8Array();
                    dwnMessage.data = new Blob([dataBytes]);
                }
                else {
                    const recordsRead = yield RecordsRead.create({
                        authorizationSignatureInput: dwnSignatureInput,
                        recordId: writeMessage.recordId
                    });
                    const reply = yield this._dwn.processMessage(author, recordsRead.toJSON());
                    if (reply.status.code >= 400) {
                        const { status: { code, detail } } = reply;
                        throw new Error(`(${code}) Failed to read data associated with record ${writeMessage.recordId}. ${detail}}`);
                    }
                    else if (reply.record) {
                        const dataBytes = yield DataStream.toBytes(reply.record.data);
                        dwnMessage.data = new Blob([dataBytes]);
                    }
                }
            }
            return dwnMessage;
        });
    }
    /**
     * The following methods are a temporary workaround that should be removed
     * once DWN SDK implements support for an external signer.
     *
     * - createAuthorization()
     * - createJws()
     * - getTempSignatureInput()
     * - signAsAuthorization()
     */
    createAuthorization(recordId, contextId, descriptorCid, attestation, encryption, signingKeyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const authorizationPayload = {
                recordId,
                descriptorCid
            };
            const attestationCid = attestation ? yield Cid.computeCid(attestation) : undefined;
            const encryptionCid = encryption ? yield Cid.computeCid(encryption) : undefined;
            if (contextId !== undefined) {
                authorizationPayload.contextId = contextId;
            } // assign `contextId` only if it is defined
            if (attestationCid !== undefined) {
                authorizationPayload.attestationCid = attestationCid;
            } // assign `attestationCid` only if it is defined
            if (encryptionCid !== undefined) {
                authorizationPayload.encryptionCid = encryptionCid;
            } // assign `encryptionCid` only if it is defined
            const authorizationPayloadU8A = Convert.object(authorizationPayload).toUint8Array();
            const jws = yield this.createJws(authorizationPayloadU8A, [signingKeyId]);
            return jws;
        });
    }
    createJws(payload, signingKeyIds = []) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the agent instance.
            const agent = this.agent;
            // Begin constructing a JWS.
            const jws = {
                payload: Convert.uint8Array(payload).toBase64Url(),
                signatures: []
            };
            for (const signingKeyId of signingKeyIds) {
                /** DID keys stored in KeyManager use the canonicalId as an alias, so
                 * normalize the signing key ID before attempting to retrieve the key. **/
                const parsedDid = didUtils.parseDid({ didUrl: signingKeyId });
                if (!parsedDid)
                    throw new Error(`DidIonMethod: Unable to parse DID: ${signingKeyId}`);
                const normalizedDid = parsedDid.did.split(':', 3).join(':');
                const normalizedSigningKeyId = `${normalizedDid}#${parsedDid.fragment}`;
                // Attempt to retrieve the signing key.
                const signingKey = yield agent.keyManager.getKey({ keyRef: normalizedSigningKeyId });
                if (!isManagedKeyPair(signingKey)) {
                    throw new Error(`DwnManager: Signing key not found for author: '${normalizedDid}'`);
                }
                // Get the JWS alg parameter given the key pair.
                const { alg } = Jose.webCryptoToJose(signingKey.privateKey.algorithm);
                // Construct the JWS protected header.
                const protectedHeader = Convert.object({ alg, kid: signingKeyId }).toBase64Url();
                // Concatenate the dot-separated header and payload and convert to bytes.
                const headerAndPayload = Convert.string(`${protectedHeader}.${jws.payload}`).toUint8Array();
                // Sign the JWS.
                const signatureBytes = yield agent.keyManager.sign({
                    algorithm: signingKey.privateKey.algorithm,
                    data: headerAndPayload,
                    keyRef: signingKey.privateKey.id
                });
                const signature = Convert.uint8Array(signatureBytes).toBase64Url();
                jws.signatures.push({ protected: protectedHeader, signature });
            }
            return jws;
        });
    }
    getTempSignatureInput({ signingKeyId }) {
        const privateJwk = {
            alg: 'placeholder',
            d: 'placeholder',
            crv: 'Ed25519',
            kty: 'placeholder',
            x: 'placeholder'
        };
        const protectedHeader = {
            alg: 'placeholder',
            kid: signingKeyId
        };
        const dwnSignatureInput = { privateJwk, protectedHeader };
        return dwnSignatureInput;
    }
    signAsAuthorization(descriptor, signingKeyId, permissionsGrantId) {
        return __awaiter(this, void 0, void 0, function* () {
            const descriptorCid = yield Cid.computeCid(descriptor);
            const authorizationPayload = { descriptorCid, permissionsGrantId };
            removeUndefinedProperties(authorizationPayload);
            const authorizationPayloadU8A = Convert.object(authorizationPayload).toUint8Array();
            const jws = yield this.createJws(authorizationPayloadU8A, [signingKeyId]);
            return jws;
        });
    }
    /**
     * ADDED TO GET SYNC WORKING
     * - createMessage()
     * - processMessage()
     * - writePrunedRecord()
     */
    createMessage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { author, messageOptions, messageType } = options;
            const signingKeyId = yield this.getAuthorSigningKeyId({ did: author });
            // ! TODO: Remove this once DWN SDK supports external signers.
            const dwnSignatureInput = this.getTempSignatureInput({ signingKeyId });
            // TODO: Figure out how to narrow this type.
            const messageCreateInput = Object.assign(Object.assign({}, messageOptions), { authorizationSignatureInput: dwnSignatureInput });
            const messageCreator = dwnMessageCreators[messageType];
            // ! TODO: START Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            // MP Step 1: Store the original methods.
            const originalCreateAuthorization = RecordsWrite.createAuthorization;
            const originalSignAsAuthorization = Message.signAsAuthorization;
            // MP Step 2: Replace the methods.
            RecordsWrite.createAuthorization = (recordId, contextId, descriptorCid, attestation, encryption) => this.createAuthorization(recordId, contextId, descriptorCid, attestation, encryption, signingKeyId);
            Message.signAsAuthorization = (descriptor, signatureInput, permissionsGrantId) => this.signAsAuthorization(descriptor, signingKeyId, permissionsGrantId);
            // MP Step 3: Call the method that required monkey patching.
            const dwnMessage = yield messageCreator.create(messageCreateInput);
            // MP Step 4: Restore the original methods.
            RecordsWrite.createAuthorization = originalCreateAuthorization;
            Message.signAsAuthorization = originalSignAsAuthorization;
            // ! TODO: END Remove this monkey patch (MP) as soon as the DWN SDK supports external signers.
            return dwnMessage;
        });
    }
    /**
     * Writes a pruned initial `RecordsWrite` to a DWN without needing to supply associated data.
     * Note: This method should ONLY be used by a {@link SyncManager} implementation.
     *
     * @param options.targetDid - DID of the DWN tenant to write the pruned RecordsWrite to.
     * @returns DWN reply containing the status of processing request.
     */
    writePrunedRecord(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { targetDid, message } = options;
            return yield this._dwn.synchronizePrunedInitialRecordsWrite(targetDid, message);
        });
    }
    processMessage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { dataStream, message, targetDid } = options;
            return yield this._dwn.processMessage(targetDid, message, dataStream);
        });
    }
}
//# sourceMappingURL=dwn-manager.js.map