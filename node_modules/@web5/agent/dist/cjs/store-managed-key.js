"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateKeyStoreMemory = exports.PrivateKeyStoreDwn = exports.KeyStoreMemory = exports.KeyStoreDwn = void 0;
var crypto_1 = require("@web5/crypto");
var common_1 = require("@web5/common");
var utils_js_1 = require("./utils.js");
/**
 * An implementation of `ManagedKeyStore` that stores key metadata and
 * public key material in a DWN.
 *
 * An instance of this class can be used by `KeyManager` or
 * an implementation of `KeyManagementSystem`.
 */
var KeyStoreDwn = /** @class */ (function () {
    function KeyStoreDwn(options) {
        this._keyRecordProperties = {
            dataFormat: 'application/json',
            schema: 'https://identity.foundation/schemas/web5/managed-key'
        };
        var schema = (options !== null && options !== void 0 ? options : {}).schema;
        if (schema) {
            this._keyRecordProperties.schema = schema;
        }
    }
    KeyStoreDwn.prototype.deleteKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, id, authorDid, queryReply, matchingRecordId, _b, _c, record, storedKey, storedKeyId, status;
            var e_1, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context, id = options.id;
                        return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _e.sent();
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 2:
                        queryReply = (_e.sent()).reply;
                        try {
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    storedKeyId = (0, utils_js_1.isManagedKeyPair)(storedKey) ? storedKey.publicKey.id : storedKey.id;
                                    if (storedKey && storedKeyId === id) {
                                        matchingRecordId = record.recordId;
                                        break;
                                    }
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        // Return undefined if the specified key was not found in the store.
                        if (!matchingRecordId)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsDelete',
                                messageOptions: {
                                    recordId: matchingRecordId
                                }
                            })];
                    case 3:
                        status = (_e.sent()).reply.status;
                        // If the key was successfully deleted, return true;
                        if (status.code === 202)
                            return [2 /*return*/, true];
                        // If the key could not be deleted, return false;
                        return [2 /*return*/, false];
                }
            });
        });
    };
    KeyStoreDwn.prototype.findKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, alias, context, id, queryReply, _b, _c, record, storedKey;
            var e_2, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, alias = options.alias, context = options.context, id = options.id;
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 1:
                        queryReply = (_e.sent()).reply;
                        try {
                            // Loop through all of the entries and return a match, if found.
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    if ((0, utils_js_1.isManagedKeyPair)(storedKey)) {
                                        if (storedKey.publicKey.id === id)
                                            return [2 /*return*/, storedKey];
                                        if (storedKey.publicKey.alias === alias)
                                            return [2 /*return*/, storedKey];
                                    }
                                    else {
                                        if (storedKey.id === id)
                                            return [2 /*return*/, storedKey];
                                        if (storedKey.alias === alias)
                                            return [2 /*return*/, storedKey];
                                    }
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        // Return undefined if no matches were found.
                        return [2 /*return*/, undefined];
                }
            });
        });
    };
    KeyStoreDwn.prototype.getKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, id, queryReply, _b, _c, record, storedKey, storedKeyId;
            var e_3, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context, id = options.id;
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 1:
                        queryReply = (_e.sent()).reply;
                        try {
                            // Loop through all of the entries and return a match, if found.
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    storedKeyId = (0, utils_js_1.isManagedKeyPair)(storedKey) ? storedKey.publicKey.id : storedKey.id;
                                    if (storedKeyId === id)
                                        return [2 /*return*/, storedKey];
                                }
                            }
                        }
                        catch (e_3_1) { e_3 = { error: e_3_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_3) throw e_3.error; }
                        }
                        // Return undefined if no matches were found.
                        return [2 /*return*/, undefined];
                }
            });
        });
    };
    KeyStoreDwn.prototype.importKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, key, keyId, authorDid, duplicateFound, encodedKey, status;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        agent = options.agent, context = options.context, key = options.key;
                        if ((0, utils_js_1.isManagedKeyPair)(key)) {
                            keyId = key.publicKey.id;
                        }
                        else {
                            // If an ID wasn't specified, generate one.
                            if (!key.id) {
                                key.id = crypto_1.utils.randomUuid();
                            }
                            keyId = key.id;
                        }
                        return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _a.sent();
                        return [4 /*yield*/, this.getKey({ agent: agent, context: context, id: keyId })];
                    case 2:
                        duplicateFound = _a.sent();
                        if (duplicateFound) {
                            throw new Error("KeyStoreDwn: Key with ID already exists: '".concat(keyId, "'"));
                        }
                        encodedKey = this.encodeKey(key);
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsWrite',
                                messageOptions: __assign({}, this._keyRecordProperties),
                                dataStream: new Blob([encodedKey])
                            })];
                    case 3:
                        status = (_a.sent()).reply.status;
                        // If the write fails, throw an error.
                        if (status.code !== 202) {
                            throw new Error('DidStoreDwn: Failed to write imported DID to store.');
                        }
                        return [2 /*return*/, keyId];
                }
            });
        });
    };
    KeyStoreDwn.prototype.listKeys = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, queryReply, storedKeys, _b, _c, record, storedKey;
            var e_4, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context;
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 1:
                        queryReply = (_e.sent()).reply;
                        storedKeys = [];
                        try {
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    storedKeys.push(storedKey);
                                }
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        return [2 /*return*/, storedKeys];
                }
            });
        });
    };
    KeyStoreDwn.prototype.updateKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, id, propertyUpdates, authorDid, queryReply, keyToUpdate, recordToUpdate, _b, _c, entry, encodedData, record, storedKey, storedKeyId, clonedUpdates, updatedKeyBytes, messageOptions, status;
            var e_5, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context, id = options.id;
                        propertyUpdates = { alias: options.alias, metadata: options.metadata };
                        return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _e.sent();
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 2:
                        queryReply = (_e.sent()).reply;
                        try {
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                entry = _c.value;
                                encodedData = entry.encodedData, record = __rest(entry, ["encodedData"]);
                                if (encodedData) {
                                    storedKey = this.decodeKey(encodedData);
                                    storedKeyId = (0, utils_js_1.isManagedKeyPair)(storedKey) ? storedKey.publicKey.id : storedKey.id;
                                    if (storedKey && storedKeyId === id) {
                                        keyToUpdate = storedKey;
                                        recordToUpdate = record;
                                        break;
                                    }
                                }
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        // Key with given ID not present so update operation cannot proceed.
                        if (!recordToUpdate || !keyToUpdate)
                            return [2 /*return*/, false];
                        // Make a deep copy of the update properties to ensure all nested objects do not share references.
                        (0, common_1.removeUndefinedProperties)(propertyUpdates);
                        (0, common_1.removeEmptyObjects)(propertyUpdates);
                        clonedUpdates = structuredClone(propertyUpdates);
                        // Update the given properties of the key.
                        if ((0, utils_js_1.isManagedKeyPair)(keyToUpdate)) {
                            keyToUpdate.privateKey = __assign(__assign({}, keyToUpdate.privateKey), clonedUpdates);
                            keyToUpdate.publicKey = __assign(__assign({}, keyToUpdate.publicKey), clonedUpdates);
                        }
                        else {
                            keyToUpdate = __assign(__assign({}, keyToUpdate), clonedUpdates);
                        }
                        updatedKeyBytes = this.encodeKey(keyToUpdate);
                        messageOptions = __assign({}, recordToUpdate.descriptor);
                        messageOptions.contextId = recordToUpdate.contextId;
                        messageOptions.recordId = recordToUpdate.recordId;
                        /** Remove properties from the update messageOptions to let the DWN SDK
                         * auto-fill.  Otherwisse, you will get 409 Conflict errors. */
                        delete messageOptions.dataCid;
                        delete messageOptions.dataSize;
                        delete messageOptions.data;
                        delete messageOptions.messageTimestamp;
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsWrite',
                                messageOptions: messageOptions,
                                dataStream: new Blob([updatedKeyBytes])
                            })];
                    case 3:
                        status = (_e.sent()).reply.status;
                        // If the write fails, throw an error.
                        if (status.code !== 202) {
                            throw new Error('DidStoreDwn: Failed to write updated key to store.');
                        }
                        return [2 /*return*/, true];
                }
            });
        });
    };
    KeyStoreDwn.prototype.decodeKey = function (keyEncodedData) {
        var encodedKey = common_1.Convert.base64Url(keyEncodedData).toObject();
        if ('publicKey' in encodedKey) {
            var privateKeyMaterial = encodedKey.privateKey.material
                ? common_1.Convert.base64Url(encodedKey.privateKey.material).toUint8Array()
                : undefined;
            var publicKeyMaterial = encodedKey.publicKey.material
                ? common_1.Convert.base64Url(encodedKey.publicKey.material).toUint8Array()
                : undefined;
            var managedKeyPair = {
                privateKey: __assign(__assign({}, encodedKey.privateKey), { material: privateKeyMaterial }),
                publicKey: __assign(__assign({}, encodedKey.publicKey), { material: publicKeyMaterial })
            };
            return managedKeyPair;
        }
        else {
            var material = encodedKey.material
                ? common_1.Convert.base64Url(encodedKey.material).toUint8Array()
                : undefined;
            var managedKey = __assign(__assign({}, encodedKey), { material: material });
            return managedKey;
        }
    };
    KeyStoreDwn.prototype.encodeKey = function (managedKey) {
        var encodedKey;
        if ((0, utils_js_1.isManagedKeyPair)(managedKey)) {
            var privateKeyMaterial = managedKey.privateKey.material
                ? common_1.Convert.uint8Array(managedKey.privateKey.material).toBase64Url()
                : undefined;
            var publicKeyMaterial = managedKey.publicKey.material
                ? common_1.Convert.uint8Array(managedKey.publicKey.material).toBase64Url()
                : undefined;
            encodedKey = {
                privateKey: __assign(__assign({}, managedKey.privateKey), { material: privateKeyMaterial }),
                publicKey: __assign(__assign({}, managedKey.publicKey), { material: publicKeyMaterial })
            };
        }
        else {
            var material = managedKey.material
                ? common_1.Convert.uint8Array(managedKey.material).toBase64Url()
                : undefined;
            encodedKey = __assign(__assign({}, managedKey), { material: material });
        }
        var keyBytes = common_1.Convert.object(encodedKey).toUint8Array();
        return keyBytes;
    };
    KeyStoreDwn.prototype.getAuthor = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var agent, context;
            return __generator(this, function (_a) {
                agent = options.agent, context = options.context;
                // If `context` is specified, DWN messages will be signed by this DID.
                if (context)
                    return [2 /*return*/, context];
                // If Agent has an agentDid, use it to sign DWN messages.
                if (agent.agentDid)
                    return [2 /*return*/, agent.agentDid];
                // If `context` and `agent.agentDid`are undefined, throw error.
                throw new Error("KeyStoreDwn: Agent property 'agentDid' is undefined and no context was specified.");
            });
        });
    };
    KeyStoreDwn.prototype.getKeyRecords = function (agent, context) {
        return __awaiter(this, void 0, void 0, function () {
            var authorDid, dwnResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _a.sent();
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsQuery',
                                messageOptions: {
                                    filter: __assign({}, this._keyRecordProperties)
                                }
                            })];
                    case 2:
                        dwnResponse = _a.sent();
                        return [2 /*return*/, dwnResponse];
                }
            });
        });
    };
    return KeyStoreDwn;
}());
exports.KeyStoreDwn = KeyStoreDwn;
/**
 * An implementation of `ManagedKeyStore` that stores key metadata and
 * public key material in memory.
 *
 * An instance of this class can be used by `KeyManager` or
 * an implementation of `KeyManagementSystem`.
 */
var KeyStoreMemory = /** @class */ (function () {
    function KeyStoreMemory() {
        /**
         * A private field that contains the Map used as the in-memory key-value store.
         */
        this.store = new Map();
    }
    KeyStoreMemory.prototype.deleteKey = function (_a) {
        var id = _a.id;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if (this.store.has(id)) {
                    // Key with given ID exists so proceed with delete.
                    this.store.delete(id);
                    return [2 /*return*/, true];
                }
                // Key with given ID not present so delete operation not possible.
                return [2 /*return*/, false];
            });
        });
    };
    KeyStoreMemory.prototype.findKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var alias, id, _a, _b, key, e_6_1;
            var e_6, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        alias = options.alias, id = options.id;
                        // Get key by ID.
                        if (id)
                            return [2 /*return*/, this.store.get(id)];
                        if (!alias) return [3 /*break*/, 8];
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 6, 7, 8]);
                        return [4 /*yield*/, this.listKeys()];
                    case 2:
                        _a = __values.apply(void 0, [_d.sent()]), _b = _a.next();
                        _d.label = 3;
                    case 3:
                        if (!!_b.done) return [3 /*break*/, 5];
                        key = _b.value;
                        if ('alias' in key && key.alias === alias)
                            return [2 /*return*/, key];
                        if ('publicKey' in key && key.publicKey.alias === alias)
                            return [2 /*return*/, key];
                        _d.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 3];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_6_1 = _d.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                        }
                        finally { if (e_6) throw e_6.error; }
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/, undefined];
                }
            });
        });
    };
    KeyStoreMemory.prototype.getKey = function (_a) {
        var id = _a.id;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this.store.get(id)];
            });
        });
    };
    KeyStoreMemory.prototype.importKey = function (_a) {
        var key = _a.key;
        return __awaiter(this, void 0, void 0, function () {
            var id, clonedKey;
            return __generator(this, function (_b) {
                if ((0, utils_js_1.isManagedKeyPair)(key)) {
                    id = key.publicKey.id;
                }
                else {
                    // If an ID wasn't specified, generate one.
                    if (!key.id) {
                        key.id = crypto_1.utils.randomUuid();
                    }
                    id = key.id;
                }
                if (this.store.has(id)) {
                    // Key with given ID already exists so import operation cannot proceed.
                    throw new Error("KeyStoreMemory: Key with ID already exists: '".concat(id, "'"));
                }
                clonedKey = structuredClone(key);
                this.store.set(id, clonedKey);
                return [2 /*return*/, id];
            });
        });
    };
    KeyStoreMemory.prototype.listKeys = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Array.from(this.store.values())];
            });
        });
    };
    KeyStoreMemory.prototype.updateKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var id, propertyUpdates, keyExists, key, clonedUpdates;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        id = options.id;
                        propertyUpdates = { alias: options.alias, metadata: options.metadata };
                        keyExists = this.store.has(id);
                        if (!keyExists) {
                            // Key with given ID not present so update operation cannot proceed.
                            return [2 /*return*/, false];
                        }
                        return [4 /*yield*/, this.getKey({ id: id })];
                    case 1:
                        key = _a.sent();
                        // Make a deep copy of the update properties to ensure all nested objects do not share references.
                        (0, common_1.removeUndefinedProperties)(propertyUpdates);
                        (0, common_1.removeEmptyObjects)(propertyUpdates);
                        clonedUpdates = structuredClone(propertyUpdates);
                        // Update the given properties of the key.
                        if ((0, utils_js_1.isManagedKeyPair)(key)) {
                            key.privateKey = __assign(__assign({}, key.privateKey), clonedUpdates);
                            key.publicKey = __assign(__assign({}, key.publicKey), clonedUpdates);
                        }
                        else {
                            key = __assign(__assign(__assign({}, key), clonedUpdates), { id: key.id });
                        }
                        // Overwrite the entry in the store with the updated object.
                        this.store.set(id, key);
                        return [2 /*return*/, true];
                }
            });
        });
    };
    return KeyStoreMemory;
}());
exports.KeyStoreMemory = KeyStoreMemory;
/**
 * An implementation of `ManagedKeyStore` that stores private key
 * material in a DWN.
 *
 * An instance of this class can be used by an implementation of
 * `KeyManagementSystem`.
 */
var PrivateKeyStoreDwn = /** @class */ (function () {
    function PrivateKeyStoreDwn() {
        this._keyRecordProperties = {
            dataFormat: 'application/json',
            schema: 'https://identity.foundation/schemas/web5/kms-private-key'
        };
    }
    PrivateKeyStoreDwn.prototype.deleteKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, id, authorDid, queryReply, matchingRecordId, _b, _c, record, storedKey, status;
            var e_7, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context, id = options.id;
                        return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _e.sent();
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 2:
                        queryReply = (_e.sent()).reply;
                        try {
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    if (storedKey && storedKey.id === id) {
                                        matchingRecordId = record.recordId;
                                        break;
                                    }
                                }
                            }
                        }
                        catch (e_7_1) { e_7 = { error: e_7_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_7) throw e_7.error; }
                        }
                        // Return undefined if the specified key was not found in the store.
                        if (!matchingRecordId)
                            return [2 /*return*/, false];
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsDelete',
                                messageOptions: {
                                    recordId: matchingRecordId
                                }
                            })];
                    case 3:
                        status = (_e.sent()).reply.status;
                        // If the key was successfully deleted, return true;
                        if (status.code === 202)
                            return [2 /*return*/, true];
                        // If the key could not be deleted, return false;
                        return [2 /*return*/, false];
                }
            });
        });
    };
    PrivateKeyStoreDwn.prototype.findKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("PrivateKeyStoreDwn: Method not implemented: 'findKey'");
            });
        });
    };
    PrivateKeyStoreDwn.prototype.getKey = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, id, queryReply, _b, _c, record, storedKey;
            var e_8, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context, id = options.id;
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 1:
                        queryReply = (_e.sent()).reply;
                        try {
                            // Loop through all of the entries and return a match, if found.
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    if (storedKey.id === id)
                                        return [2 /*return*/, storedKey];
                                }
                            }
                        }
                        catch (e_8_1) { e_8 = { error: e_8_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_8) throw e_8.error; }
                        }
                        // Return undefined if no matches were found.
                        return [2 /*return*/, undefined];
                }
            });
        });
    };
    PrivateKeyStoreDwn.prototype.importKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, key, authorDid, id, encodedPrivateKey, status;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        agent = options.agent, context = options.context, key = options.key;
                        if (!key.material)
                            throw new TypeError("Required parameter missing: 'material'");
                        if (!key.type)
                            throw new TypeError("Required parameter missing: 'type'");
                        return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _a.sent();
                        id = crypto_1.utils.randomUuid();
                        encodedPrivateKey = this.encodeKey(__assign(__assign({}, key), { id: id }));
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsWrite',
                                messageOptions: __assign({}, this._keyRecordProperties),
                                dataStream: new Blob([encodedPrivateKey])
                            })];
                    case 2:
                        status = (_a.sent()).reply.status;
                        // If the write fails, throw an error.
                        if (status.code !== 202) {
                            throw new Error('PrivateKeyStoreDwn: Failed to write imported DID to store.');
                        }
                        return [2 /*return*/, id];
                }
            });
        });
    };
    PrivateKeyStoreDwn.prototype.listKeys = function (options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var agent, context, queryReply, storedKeys, _b, _c, record, storedKey;
            var e_9, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        agent = options.agent, context = options.context;
                        return [4 /*yield*/, this.getKeyRecords(agent, context)];
                    case 1:
                        queryReply = (_e.sent()).reply;
                        storedKeys = [];
                        try {
                            for (_b = __values((_a = queryReply.entries) !== null && _a !== void 0 ? _a : []), _c = _b.next(); !_c.done; _c = _b.next()) {
                                record = _c.value;
                                if (record.encodedData) {
                                    storedKey = this.decodeKey(record.encodedData);
                                    storedKeys.push(storedKey);
                                }
                            }
                        }
                        catch (e_9_1) { e_9 = { error: e_9_1 }; }
                        finally {
                            try {
                                if (_c && !_c.done && (_d = _b.return)) _d.call(_b);
                            }
                            finally { if (e_9) throw e_9.error; }
                        }
                        return [2 /*return*/, storedKeys];
                }
            });
        });
    };
    PrivateKeyStoreDwn.prototype.updateKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("PrivateKeyStoreMemory: Method not implemented: 'updateKey'");
            });
        });
    };
    PrivateKeyStoreDwn.prototype.decodeKey = function (keyEncodedData) {
        var encodedKey = common_1.Convert.base64Url(keyEncodedData).toObject();
        var privateKey = __assign(__assign({}, encodedKey), { material: common_1.Convert.base64Url(encodedKey.material).toUint8Array() });
        return privateKey;
    };
    PrivateKeyStoreDwn.prototype.encodeKey = function (privateKey) {
        var encodedKey = __assign(__assign({}, privateKey), { material: common_1.Convert.uint8Array(privateKey.material).toBase64Url() });
        var keyBytes = common_1.Convert.object(encodedKey).toUint8Array();
        return keyBytes;
    };
    PrivateKeyStoreDwn.prototype.getAuthor = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var agent, context;
            return __generator(this, function (_a) {
                agent = options.agent, context = options.context;
                // If `context` is specified, DWN messages will be signed by this DID.
                if (context)
                    return [2 /*return*/, context];
                // If Agent has an agentDid, use it to sign DWN messages.
                if (agent.agentDid)
                    return [2 /*return*/, agent.agentDid];
                // If `context` and `agent.agentDid`are undefined, throw error.
                throw new Error("PrivateKeyStoreDwn: Agent property 'agentDid' is undefined and no context was specified.");
            });
        });
    };
    PrivateKeyStoreDwn.prototype.getKeyRecords = function (agent, context) {
        return __awaiter(this, void 0, void 0, function () {
            var authorDid, dwnResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getAuthor({ agent: agent, context: context })];
                    case 1:
                        authorDid = _a.sent();
                        return [4 /*yield*/, agent.dwnManager.processRequest({
                                author: authorDid,
                                target: authorDid,
                                messageType: 'RecordsQuery',
                                messageOptions: {
                                    filter: __assign({}, this._keyRecordProperties)
                                }
                            })];
                    case 2:
                        dwnResponse = _a.sent();
                        return [2 /*return*/, dwnResponse];
                }
            });
        });
    };
    return PrivateKeyStoreDwn;
}());
exports.PrivateKeyStoreDwn = PrivateKeyStoreDwn;
/**
 * An implementation of `ManagedKeyStore` that stores private key
 * material in memory.
 *
 * An instance of this class can be used by an implementation of
 * `KeyManagementSystem`.
 */
var PrivateKeyStoreMemory = /** @class */ (function () {
    function PrivateKeyStoreMemory() {
        /**
         * A private field that contains the Map used as the in-memory key-value store.
         */
        this.store = new Map();
    }
    PrivateKeyStoreMemory.prototype.deleteKey = function (_a) {
        var id = _a.id;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                if (this.store.has(id)) {
                    // Key with given ID exists so proceed with delete.
                    this.store.delete(id);
                    return [2 /*return*/, true];
                }
                // Key with given ID not present so delete operation not possible.
                return [2 /*return*/, false];
            });
        });
    };
    PrivateKeyStoreMemory.prototype.findKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("PrivateKeyStoreMemory: Method not implemented: 'findKey'");
            });
        });
    };
    PrivateKeyStoreMemory.prototype.getKey = function (_a) {
        var id = _a.id;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                return [2 /*return*/, this.store.get(id)];
            });
        });
    };
    PrivateKeyStoreMemory.prototype.importKey = function (_a) {
        var key = _a.key;
        return __awaiter(this, void 0, void 0, function () {
            var clonedKey;
            return __generator(this, function (_b) {
                if (!key.material)
                    throw new TypeError("Required parameter missing: 'material'");
                if (!key.type)
                    throw new TypeError("Required parameter missing: 'type'");
                clonedKey = structuredClone(key, { transfer: [key.material.buffer] });
                clonedKey.id = crypto_1.utils.randomUuid();
                this.store.set(clonedKey.id, clonedKey);
                return [2 /*return*/, clonedKey.id];
            });
        });
    };
    PrivateKeyStoreMemory.prototype.listKeys = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, Array.from(this.store.values())];
            });
        });
    };
    PrivateKeyStoreMemory.prototype.updateKey = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("PrivateKeyStoreMemory: Method not implemented: 'updateKey'");
            });
        });
    };
    return PrivateKeyStoreMemory;
}());
exports.PrivateKeyStoreMemory = PrivateKeyStoreMemory;
//# sourceMappingURL=store-managed-key.js.map