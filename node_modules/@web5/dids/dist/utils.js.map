{
  "version": 3,
  "sources": ["../../../node_modules/did-resolver/src/resolver.ts", "../src/utils.ts"],
  "sourcesContent": ["// Copyright 2018 Consensys AG\n\n// Licensed under the Apache License, Version 2.0(the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Defines an object type that can be extended with other properties.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type Extensible = Record<string, any>\n\n/**\n * Defines the result of a DID resolution operation.\n *\n * @see {@link Resolvable.resolve}\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution}\n */\nexport interface DIDResolutionResult {\n  '@context'?: 'https://w3id.org/did-resolution/v1' | string | string[]\n  didResolutionMetadata: DIDResolutionMetadata\n  didDocument: DIDDocument | null\n  didDocumentMetadata: DIDDocumentMetadata\n}\n\n/**\n * Describes the options forwarded to the resolver when executing a {@link Resolvable.resolve} operation.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution-options}\n */\nexport interface DIDResolutionOptions extends Extensible {\n  accept?: string\n}\n\n/**\n * Encapsulates the resolution metadata resulting from a {@link Resolvable.resolve} operation.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-resolution-metadata}\n */\nexport interface DIDResolutionMetadata extends Extensible {\n  contentType?: string\n  error?: 'invalidDid' | 'notFound' | 'representationNotSupported' | 'unsupportedDidMethod' | string\n}\n\n/**\n * Represents metadata about the DID document resulting from a {@link Resolvable.resolve} operation.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-document-metadata}\n */\nexport interface DIDDocumentMetadata extends Extensible {\n  created?: string\n  updated?: string\n  deactivated?: boolean\n  versionId?: string\n  nextUpdate?: string\n  nextVersionId?: string\n  equivalentId?: string\n  canonicalId?: string\n}\n\n/**\n * Represents the Verification Relationship between a DID subject and a Verification Method.\n *\n * @see {@link https://www.w3.org/TR/did-core/#verification-relationships}\n */\nexport type KeyCapabilitySection =\n  | 'authentication'\n  | 'assertionMethod'\n  | 'keyAgreement'\n  | 'capabilityInvocation'\n  | 'capabilityDelegation'\n\n/**\n * Represents a DID document.\n *\n * @see {@link https://www.w3.org/TR/did-core/#did-document-properties}\n */\nexport type DIDDocument = {\n  '@context'?: 'https://www.w3.org/ns/did/v1' | string | string[]\n  id: string\n  alsoKnownAs?: string[]\n  controller?: string | string[]\n  verificationMethod?: VerificationMethod[]\n  service?: Service[]\n  /**\n   * @deprecated\n   */\n  publicKey?: VerificationMethod[]\n} & {\n  [x in KeyCapabilitySection]?: (string | VerificationMethod)[]\n}\n\n/**\n * Represents a Service entry in a {@link https://www.w3.org/TR/did-core/#did-document-properties | DID document}.\n *\n * @see {@link https://www.w3.org/TR/did-core/#services}\n * @see {@link https://www.w3.org/TR/did-core/#service-properties}\n */\nexport interface Service {\n  id: string\n  type: string\n  serviceEndpoint: ServiceEndpoint | ServiceEndpoint[]\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\n/**\n * Represents an endpoint of a Service entry in a DID document.\n *\n * @see {@link https://www.w3.org/TR/did-core/#dfn-serviceendpoint}\n * @see {@link https://www.w3.org/TR/did-core/#services}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ServiceEndpoint = string | Record<string, any>\n\n/**\n * Encapsulates a JSON web key type that includes only the public properties that\n * can be used in DID documents.\n *\n * The private properties are intentionally omitted to discourage the use\n * (and accidental disclosure) of private keys in DID documents.\n *\n * @see {@link https://www.rfc-editor.org/rfc/rfc7517 | RFC7517 JsonWebKey (JWK)}\n */\nexport interface JsonWebKey extends Extensible {\n  alg?: string\n  crv?: string\n  e?: string\n  ext?: boolean\n  key_ops?: string[]\n  kid?: string\n  kty: string\n  n?: string\n  use?: string\n  x?: string\n  y?: string\n}\n\n/**\n * Represents the properties of a Verification Method listed in a DID document.\n *\n * This data type includes public key representations that are no longer present in the spec but are still used by\n * several DID methods / resolvers and kept for backward compatibility.\n *\n * @see {@link https://www.w3.org/TR/did-core/#verification-methods}\n * @see {@link https://www.w3.org/TR/did-core/#verification-method-properties}\n */\nexport interface VerificationMethod {\n  id: string\n  type: string\n  controller: string\n  publicKeyBase58?: string\n  publicKeyBase64?: string\n  publicKeyJwk?: JsonWebKey\n  publicKeyHex?: string\n  publicKeyMultibase?: string\n  blockchainAccountId?: string\n  ethereumAddress?: string\n\n  // ConditionalProof2022 subtypes\n  conditionOr?: VerificationMethod[]\n  conditionAnd?: VerificationMethod[]\n  threshold?: number\n  conditionThreshold?: VerificationMethod[]\n  conditionWeightedThreshold?: ConditionWeightedThreshold[]\n  conditionDelegated?: string\n  relationshipParent?: string[]\n  relationshipChild?: string[]\n  relationshipSibling?: string[]\n}\n\nexport interface ConditionWeightedThreshold {\n  condition: VerificationMethod\n  weight: number\n}\n\n/**\n * URI params resulting from parsing a DID URI\n */\nexport interface Params {\n  [index: string]: string\n}\n\n/**\n * An object containing the results of parsing a DID URI string.\n *\n * This is forwarded to implementations of particular DID resolvers when calling the `resolve` method.\n *\n * @see {@link Resolver}\n * @see {@link Resolvable.resolve}\n */\nexport interface ParsedDID {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: Params\n}\n\n/**\n * The DID resolution function that DID Resolver implementations must implement.\n */\nexport type DIDResolver = (\n  did: string,\n  parsed: ParsedDID,\n  resolver: Resolvable,\n  options: DIDResolutionOptions\n) => Promise<DIDResolutionResult>\nexport type WrappedResolver = () => Promise<DIDResolutionResult>\nexport type DIDCache = (parsed: ParsedDID, resolve: WrappedResolver) => Promise<DIDResolutionResult>\nexport type LegacyDIDResolver = (did: string, parsed: ParsedDID, resolver: Resolvable) => Promise<DIDDocument>\n\nexport type ResolverRegistry = Record<string, DIDResolver>\n\nexport interface LegacyResolverRegistry {\n  [index: string]: LegacyDIDResolver\n}\n\nexport interface ResolverOptions {\n  cache?: DIDCache | boolean | undefined\n  legacyResolvers?: LegacyResolverRegistry\n}\n\nexport function inMemoryCache(): DIDCache {\n  const cache: Map<string, DIDResolutionResult> = new Map()\n  return async (parsed: ParsedDID, resolve) => {\n    if (parsed.params && parsed.params['no-cache'] === 'true') return await resolve()\n\n    const cached = cache.get(parsed.didUrl)\n    if (cached !== undefined) return cached\n    const result = await resolve()\n    if (result.didResolutionMetadata?.error !== 'notFound') {\n      cache.set(parsed.didUrl, result)\n    }\n    return result\n  }\n}\n\nexport function noCache(parsed: ParsedDID, resolve: WrappedResolver): Promise<DIDResolutionResult> {\n  return resolve()\n}\n\nconst PCT_ENCODED = '(?:%[0-9a-fA-F]{2})'\nconst ID_CHAR = `(?:[a-zA-Z0-9._-]|${PCT_ENCODED})`\nconst METHOD = '([a-z0-9]+)'\nconst METHOD_ID = `((?:${ID_CHAR}*:)*(${ID_CHAR}+))`\nconst PARAM_CHAR = '[a-zA-Z0-9_.:%-]'\nconst PARAM = `;${PARAM_CHAR}+=${PARAM_CHAR}*`\nconst PARAMS = `((${PARAM})*)`\nconst PATH = `(/[^#?]*)?`\nconst QUERY = `([?][^#]*)?`\nconst FRAGMENT = `(#.*)?`\nconst DID_MATCHER = new RegExp(`^did:${METHOD}:${METHOD_ID}${PARAMS}${PATH}${QUERY}${FRAGMENT}$`)\n\n/**\n * Parses a DID URL and builds a {@link ParsedDID | ParsedDID object}\n *\n * @param didUrl - the DID URL string to be parsed\n * @returns a ParsedDID object, or null if the input is not a DID URL\n */\nexport function parse(didUrl: string): ParsedDID | null {\n  if (didUrl === '' || !didUrl) return null\n  const sections = didUrl.match(DID_MATCHER)\n  if (sections) {\n    const parts: ParsedDID = {\n      did: `did:${sections[1]}:${sections[2]}`,\n      method: sections[1],\n      id: sections[2],\n      didUrl,\n    }\n    if (sections[4]) {\n      const params = sections[4].slice(1).split(';')\n      parts.params = {}\n      for (const p of params) {\n        const kv = p.split('=')\n        parts.params[kv[0]] = kv[1]\n      }\n    }\n    if (sections[6]) parts.path = sections[6]\n    if (sections[7]) parts.query = sections[7].slice(1)\n    if (sections[8]) parts.fragment = sections[8].slice(1)\n    return parts\n  }\n  return null\n}\n\nconst EMPTY_RESULT: DIDResolutionResult = {\n  didResolutionMetadata: {},\n  didDocument: null,\n  didDocumentMetadata: {},\n}\n\nexport function wrapLegacyResolver(resolve: LegacyDIDResolver): DIDResolver {\n  return async (did, parsed, resolver) => {\n    try {\n      const doc = await resolve(did, parsed, resolver)\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument: doc,\n      }\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString(), // This is not in spec, but may be helpful\n        },\n      }\n    }\n  }\n}\n\n/**\n * The method signature implemented by this resolver.\n */\nexport interface Resolvable {\n  resolve: (didUrl: string, options?: DIDResolutionOptions) => Promise<DIDResolutionResult>\n}\n\n/**\n * This implementation of {@link Resolvable} bundles together multiple implementations of {@link DIDResolver} and\n * presents a single function call to users.\n */\nexport class Resolver implements Resolvable {\n  private readonly registry: ResolverRegistry\n  private readonly cache: DIDCache\n\n  constructor(registry: ResolverRegistry = {}, options: ResolverOptions = {}) {\n    this.registry = registry\n    this.cache = options.cache === true ? inMemoryCache() : options.cache || noCache\n    if (options.legacyResolvers) {\n      Object.keys(options.legacyResolvers).map((methodName) => {\n        if (!this.registry[methodName]) {\n          this.registry[methodName] = wrapLegacyResolver(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            options.legacyResolvers![methodName]\n          )\n        }\n      })\n    }\n  }\n\n  async resolve(didUrl: string, options: DIDResolutionOptions = {}): Promise<DIDResolutionResult> {\n    const parsed = parse(didUrl)\n    if (parsed === null) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'invalidDid' },\n      }\n    }\n    const resolver = this.registry[parsed.method]\n    if (!resolver) {\n      return {\n        ...EMPTY_RESULT,\n        didResolutionMetadata: { error: 'unsupportedDidMethod' },\n      }\n    }\n    return this.cache(parsed, () => resolver(parsed.did, parsed, this, options))\n  }\n}\n", "import type { PublicKeyJwk } from '@web5/crypto';\nimport { parse, type ParsedDID } from 'did-resolver';\n\nimport type { DidDocument, DidService, DidServiceEndpoint, DwnServiceEndpoint } from './types.js';\n\nexport interface ParsedDid {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: ParsedDID['params']\n}\n\nexport const DID_REGEX = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\\/[^#?]*)?([?][^#]*)?(#.*)?$/;\n\n/**\n * Retrieves services from a given DID document based on provided options.\n * If no `id` or `type` filters are provided, all defined services are returned.\n *\n * Note: The DID document must adhere to the W3C DID specification.\n *\n * @param options - An object containing input parameters for retrieving services.\n * @param options.didDocument - The DID document from which services are retrieved.\n * @param options.id - Optional. A string representing the specific service ID to match. If provided, only the service with this ID will be returned.\n * @param options.type - Optional. A string representing the specific service type to match. If provided, only the service(s) of this type will be returned.\n *\n * @returns An array of services. If no matching service is found, an empty array is returned.\n *\n * @example\n *\n * const didDoc = { ... }; // W3C DID document\n * const services = getServices({ didDocument: didDoc, type: 'DecentralizedWebNode' });\n */\nexport function getServices(options: {\n  didDocument: DidDocument,\n  id?: string,\n  type?: string\n}): DidService[] {\n  const { didDocument, id, type } = options ?? {};\n\n  return didDocument?.service?.filter(service => {\n    if (id && service.id !== id) return false;\n    if (type && service.type !== type) return false;\n    return true;\n  }) ?? [ ];\n}\n\nexport function getVerificationMethodIds(options: {\n  didDocument: DidDocument,\n  publicKeyJwk?: PublicKeyJwk,\n  publicKeyMultibase?: string\n}): string | undefined {\n  const { didDocument, publicKeyJwk, publicKeyMultibase } = options;\n  if (!didDocument) throw new Error(`Required parameter missing: 'didDocument'`);\n  if (!didDocument.verificationMethod) throw new Error('Given `didDocument` is missing `verificationMethod` entries.');\n\n  for (let method of didDocument.verificationMethod) {\n    if (publicKeyMultibase && 'publicKeyMultibase' in method) {\n      if (publicKeyMultibase === method.publicKeyMultibase) {\n        return method.id;\n      }\n    } else if (publicKeyJwk && 'crv' in publicKeyJwk &&\n               'publicKeyJwk' in method && 'crv' in method.publicKeyJwk) {\n      if (publicKeyJwk.crv === method.publicKeyJwk.crv &&\n            publicKeyJwk.x === method.publicKeyJwk.x) {\n        return method.id;\n      }\n    }\n  }\n}\n\n/**\n * Retrieves DID verification method types from a given DID document.\n *\n * Note: The DID document must adhere to the W3C DID specification.\n *\n * @param options - An object containing input parameters for retrieving types.\n * @param options.didDocument - The DID document from which types are retrieved.\n *\n * @returns An array of types. If no types were found, an empty array is returned.\n */\nexport function getVerificationMethodTypes(options: {\n  didDocument: Record<string, any>\n}): string[] {\n  const { didDocument } = options;\n\n  let types: string[] = [];\n\n  for (let key in didDocument) {\n    if (typeof didDocument[key] === 'object') {\n      types = types.concat(getVerificationMethodTypes({\n        didDocument: didDocument[key]\n      }));\n\n    } else if (key === 'type') {\n      types.push(didDocument[key]);\n    }\n  }\n\n  return [...new Set(types)]; // return only unique types\n}\n\n/**\n * Type guard function to check if the given endpoint is a DwnServiceEndpoint.\n *\n * @param key The endpoint to check.\n * @returns True if the endpoint is a DwnServiceEndpoint, false otherwise.\n */\nexport function isDwnServiceEndpoint(endpoint: string | DidServiceEndpoint | DidServiceEndpoint[]): endpoint is DwnServiceEndpoint {\n  return endpoint !== undefined &&\n    typeof endpoint !== 'string' &&\n    !Array.isArray(endpoint) &&\n    'nodes' in endpoint &&\n    'signingKeys' in endpoint;\n}\n\nexport function parseDid({ didUrl }: { didUrl: string }): ParsedDid | undefined {\n  const parsedDid: ParsedDid = parse(didUrl);\n\n  return parsedDid;\n}"],
  "mappings": "AA8PA,IAAMA,EAAc,sBACdC,EAA+B,qBAAAD,KAC/BE,EAAS,cACTC,EAAY,OAAOF,SAAeA,OAClCG,EAAa,mBACbC,EAAQ,IAAID,MAAeA,KAC3BE,EAAc,KAAAD,OACdE,EAAO,aACPC,EAAQ,cACRC,EAAW,SACXC,EAAc,IAAIC,OAAO,QAAQT,KAAUC,IAAYG,IAASC,IAAOC,IAAQC,IAAW,EAQ1F,SAAUG,EAAMC,EAAc,CAClC,GAAIA,IAAW,IAAM,CAACA,EAAQ,OAAO,KACrC,IAAMC,EAAWD,EAAOE,MAAML,CAAW,EACzC,GAAII,EAAU,CACZ,IAAME,EAAmB,CACvBC,IAAY,OAAAH,EAAS,CAAC,KAAKA,EAAS,CAAC,IACrCI,OAAQJ,EAAS,CAAC,EAClBK,GAAIL,EAAS,CAAC,EACdD,OAAAA,GAEF,GAAIC,EAAS,CAAC,EAAG,CACf,IAAMM,EAASN,EAAS,CAAC,EAAEO,MAAM,CAAC,EAAEC,MAAM,GAAG,EAC7CN,EAAMI,OAAS,CAAA,EACf,QAAWG,KAAKH,EAAQ,CACtB,IAAMI,EAAKD,EAAED,MAAM,GAAG,EACtBN,EAAMI,OAAOI,EAAG,CAAC,CAAC,EAAIA,EAAG,CAAC,CAC3B,CACF,CACD,OAAIV,EAAS,CAAC,IAAGE,EAAMS,KAAOX,EAAS,CAAC,GACpCA,EAAS,CAAC,IAAGE,EAAMU,MAAQZ,EAAS,CAAC,EAAEO,MAAM,CAAC,GAC9CP,EAAS,CAAC,IAAGE,EAAMW,SAAWb,EAAS,CAAC,EAAEO,MAAM,CAAC,GAC9CL,CACR,CACD,OAAO,IACT,CCxRO,IAAMY,EAAY,kLAoBlB,SAASC,EAAYC,EAIX,CACf,GAAM,CAAE,YAAAC,EAAa,GAAAC,EAAI,KAAAC,CAAK,EAAIH,GAAW,CAAC,EAE9C,OAAOC,GAAa,SAAS,OAAOG,GAC9B,EAAAF,GAAME,EAAQ,KAAOF,GACrBC,GAAQC,EAAQ,OAASD,EAE9B,GAAK,CAAE,CACV,CAEO,SAASE,EAAyBL,EAIlB,CACrB,GAAM,CAAE,YAAAC,EAAa,aAAAK,EAAc,mBAAAC,CAAmB,EAAIP,EAC1D,GAAI,CAACC,EAAa,MAAM,IAAI,MAAM,2CAA2C,EAC7E,GAAI,CAACA,EAAY,mBAAoB,MAAM,IAAI,MAAM,8DAA8D,EAEnH,QAASO,KAAUP,EAAY,mBAC7B,GAAIM,GAAsB,uBAAwBC,GAChD,GAAID,IAAuBC,EAAO,mBAChC,OAAOA,EAAO,WAEPF,GAAgB,QAASA,GACzB,iBAAkBE,GAAU,QAASA,EAAO,cACjDF,EAAa,MAAQE,EAAO,aAAa,KACvCF,EAAa,IAAME,EAAO,aAAa,EAC3C,OAAOA,EAAO,EAItB,CAYO,SAASC,EAA2BT,EAE9B,CACX,GAAM,CAAE,YAAAC,CAAY,EAAID,EAEpBU,EAAkB,CAAC,EAEvB,QAASC,KAAOV,EACV,OAAOA,EAAYU,CAAG,GAAM,SAC9BD,EAAQA,EAAM,OAAOD,EAA2B,CAC9C,YAAaR,EAAYU,CAAG,CAC9B,CAAC,CAAC,EAEOA,IAAQ,QACjBD,EAAM,KAAKT,EAAYU,CAAG,CAAC,EAI/B,MAAO,CAAC,GAAG,IAAI,IAAID,CAAK,CAAC,CAC3B,CAQO,SAASE,EAAqBC,EAA8F,CACjI,OAAOA,IAAa,QAClB,OAAOA,GAAa,UACpB,CAAC,MAAM,QAAQA,CAAQ,GACvB,UAAWA,GACX,gBAAiBA,CACrB,CAEO,SAASC,EAAS,CAAE,OAAAC,CAAO,EAA8C,CAG9E,OAF6BC,EAAMD,CAAM,CAG3C",
  "names": ["PCT_ENCODED", "ID_CHAR", "METHOD", "METHOD_ID", "PARAM_CHAR", "PARAM", "PARAMS", "PATH", "QUERY", "FRAGMENT", "DID_MATCHER", "RegExp", "parse", "didUrl", "sections", "match", "parts", "did", "method", "id", "params", "slice", "split", "p", "kv", "path", "query", "fragment", "DID_REGEX", "getServices", "options", "didDocument", "id", "type", "service", "getVerificationMethodIds", "publicKeyJwk", "publicKeyMultibase", "method", "getVerificationMethodTypes", "types", "key", "isDwnServiceEndpoint", "endpoint", "parseDid", "didUrl", "parse"]
}
