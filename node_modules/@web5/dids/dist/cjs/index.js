var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require("ms");
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self.diff = ms2;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str3) => str3.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../../node_modules/randombytes/index.js
var require_randombytes = __commonJS({
  "../../node_modules/randombytes/index.js"(exports, module2) {
    module2.exports = require("crypto").randomBytes;
  }
});

// ../../node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "../../node_modules/k-bucket/index.js"(exports, module2) {
    "use strict";
    var randomBytes2 = require_randombytes();
    var { EventEmitter: EventEmitter2 } = require("events");
    function arrayEquals(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i = 0, length2 = array1.length; i < length2; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function createNode() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name + " is not a Uint8Array");
      }
    }
    var KBucket2 = class _KBucket extends EventEmitter2 {
      /**
       * `options`:
       *   `distance`: _Function_
       *     `function (firstId, secondId) { return distance }` An optional
       *     `distance` function that gets two `id` Uint8Arrays
       *     and return distance (as number) between them.
       *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_
       *     `function (incumbent, candidate) { return contact; }` An optional
       *     `arbiter` function that givent two `contact` objects with the same `id`
       *     returns the desired object to be used for updating the k-bucket. For
       *     more details, see [arbiter function](#arbiter-function).
       *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.
       *     If not provided, a local node id will be created via `randomBytes(20)`.
       *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include
       *     with the k-bucket. `metadata` property is guaranteed not be altered by,
       *     it is provided as an explicit container for users of k-bucket to store
       *     implementation-specific data.
       *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes
       *     that a k-bucket can contain before being full or split.
       *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to
       *     ping when a bucket that should not be split becomes full. KBucket will
       *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have
       *     not been contacted the longest.
       *
       * @param {Object=} options optional
       */
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes2(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || _KBucket.distance;
        this.arbiter = options.arbiter || _KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode();
      }
      /**
       * Default arbiter function for contacts with the same id. Uses
       * contact.vectorClock to select which contact to update the k-bucket with.
       * Contact with larger vectorClock field will be selected. If vectorClock is
       * the same, candidat will be selected.
       *
       * @param  {Object} incumbent Contact currently stored in the k-bucket.
       * @param  {Object} candidate Contact being added to the k-bucket.
       * @return {Object}           Contact to updated the k-bucket with.
       */
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      /**
       * Default distance function. Finds the XOR
       * distance between firstId and secondId.
       *
       * @param  {Uint8Array} firstId  Uint8Array containing first id.
       * @param  {Uint8Array} secondId Uint8Array containing second id.
       * @return {Number}              Integer The XOR distance between firstId
       *                               and secondId.
       */
      static distance(firstId, secondId) {
        let distance = 0;
        let i = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i < min; ++i) {
          distance = distance * 256 + (firstId[i] ^ secondId[i]);
        }
        for (; i < max; ++i)
          distance = distance * 256 + 255;
        return distance;
      }
      /**
       * Adds a contact to the k-bucket.
       *
       * @param {Object} contact the contact object to add
       */
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      /**
       * Get the n closest contacts to the provided node id. "Closest" here means:
       * closest according to the XOR metric of the contact node id.
       *
       * @param  {Uint8Array} id  Contact node id
       * @param  {Number=} n      Integer (Default: Infinity) The maximum number of
       *                          closest contacts to return
       * @return {Array}          Array Maximum of n closest contacts to the node id
       */
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      /**
       * Counts the total number of contacts in the tree.
       *
       * @return {Number} The number of contacts held in the tree
       */
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      /**
       * Determines whether the id at the bitIndex is 0 or 1.
       * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise
       *
       * @param  {Object} node     internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id   Id to compare localNodeId with.
       * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit
       *                           to check in the id Uint8Array.
       * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.
       */
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      /**
       * Get a contact by its exact ID.
       * If this is a leaf, loop through the bucket contents and return the correct
       * contact if we have it or null if not. If this is an inner node, determine
       * which branch of the tree to traverse and repeat.
       *
       * @param  {Uint8Array} id The ID of the contact to fetch.
       * @return {Object|Null}   The contact if available, otherwise null
       */
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      /**
       * Returns the index of the contact with provided
       * id if it exists, returns -1 otherwise.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Uint8Array} id  Contact node id.
       * @return {Number}         Integer Index of contact with provided id if it
       *                          exists, -1 otherwise.
       */
      _indexOf(node, id) {
        for (let i = 0; i < node.contacts.length; ++i) {
          if (arrayEquals(node.contacts[i].id, id))
            return i;
        }
        return -1;
      }
      /**
       * Removes contact with the provided id.
       *
       * @param  {Uint8Array} id The ID of the contact to remove.
       * @return {Object}        The k-bucket itself.
       */
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      /**
       * Splits the node, redistributes contacts to the new nodes, and marks the
       * node that was split as an inner node of the binary tree of nodes by
       * setting this.root.contacts = null
       *
       * @param  {Object} node     node for splitting
       * @param  {Number} bitIndex the bitIndex to which byte to check in the
       *                           Uint8Array for navigating the binary tree
       */
      _split(node, bitIndex) {
        node.left = createNode();
        node.right = createNode();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      /**
       * Returns all the contacts contained in the tree as an array.
       * If this is a leaf, return a copy of the bucket. If this is not a leaf,
       * return the union of the low and high branches (themselves also as arrays).
       *
       * @return {Array} All of the contacts in the tree, as an array
       */
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      /**
       * Similar to `toArray()` but instead of buffering everything up into an
       * array before returning it, yields contacts as they are encountered while
       * walking the tree.
       *
       * @return {Iterable} All of the contacts in the tree, as an iterable
       */
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      /**
       * Updates the contact selected by the arbiter.
       * If the selection is our old contact and the candidate is some new contact
       * then the new contact is abandoned (not added).
       * If the selection is our old contact and the candidate is our old contact
       * then we are refreshing the contact and it is marked as most recently
       * contacted (by being moved to the right/end of the bucket array).
       * If the selection is our new contact, the old contact is removed and the new
       * contact is marked as most recently contacted.
       *
       * @param  {Object} node    internal object that has 2 leafs: left and right
       * @param  {Number} index   the index in the bucket where contact exists
       *                          (index has already been computed in a previous
       *                          calculation)
       * @param  {Object} contact The contact object to update.
       */
      _update(node, index, contact) {
        if (!arrayEquals(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module2.exports = KBucket2;
  }
});

// ../../node_modules/k-rpc-socket/node_modules/bencode/lib/util.js
var require_util = __commonJS({
  "../../node_modules/k-rpc-socket/node_modules/bencode/lib/util.js"(exports, module2) {
    var util = module2.exports;
    util.digitCount = function digitCount3(value) {
      const sign = value < 0 ? 1 : 0;
      value = Math.abs(Number(value || 1));
      return Math.floor(Math.log10(value)) + 1 + sign;
    };
    util.getType = function getType3(value) {
      if (Buffer.isBuffer(value))
        return "buffer";
      if (ArrayBuffer.isView(value))
        return "arraybufferview";
      if (Array.isArray(value))
        return "array";
      if (value instanceof Number)
        return "number";
      if (value instanceof Boolean)
        return "boolean";
      if (value instanceof Set)
        return "set";
      if (value instanceof Map)
        return "map";
      if (value instanceof String)
        return "string";
      if (value instanceof ArrayBuffer)
        return "arraybuffer";
      return typeof value;
    };
  }
});

// ../../node_modules/k-rpc-socket/node_modules/bencode/lib/encode.js
var require_encode = __commonJS({
  "../../node_modules/k-rpc-socket/node_modules/bencode/lib/encode.js"(exports, module2) {
    var { getType: getType3 } = require_util();
    function encode6(data, buffer, offset) {
      const buffers = [];
      let result = null;
      encode6._encode(buffers, data);
      result = Buffer.concat(buffers);
      encode6.bytes = result.length;
      if (Buffer.isBuffer(buffer)) {
        result.copy(buffer, offset);
        return buffer;
      }
      return result;
    }
    encode6.bytes = -1;
    encode6._floatConversionDetected = false;
    encode6._encode = function(buffers, data) {
      if (data == null) {
        return;
      }
      switch (getType3(data)) {
        case "buffer":
          encode6.buffer(buffers, data);
          break;
        case "object":
          encode6.dict(buffers, data);
          break;
        case "map":
          encode6.dictMap(buffers, data);
          break;
        case "array":
          encode6.list(buffers, data);
          break;
        case "set":
          encode6.listSet(buffers, data);
          break;
        case "string":
          encode6.string(buffers, data);
          break;
        case "number":
          encode6.number(buffers, data);
          break;
        case "boolean":
          encode6.number(buffers, data);
          break;
        case "arraybufferview":
          encode6.buffer(buffers, Buffer.from(data.buffer, data.byteOffset, data.byteLength));
          break;
        case "arraybuffer":
          encode6.buffer(buffers, Buffer.from(data));
          break;
      }
    };
    var buffE3 = Buffer.from("e");
    var buffD3 = Buffer.from("d");
    var buffL3 = Buffer.from("l");
    encode6.buffer = function(buffers, data) {
      buffers.push(Buffer.from(data.length + ":"), data);
    };
    encode6.string = function(buffers, data) {
      buffers.push(Buffer.from(Buffer.byteLength(data) + ":" + data));
    };
    encode6.number = function(buffers, data) {
      const maxLo = 2147483648;
      const hi = data / maxLo << 0;
      const lo = data % maxLo << 0;
      const val = hi * maxLo + lo;
      buffers.push(Buffer.from("i" + val + "e"));
      if (val !== data && !encode6._floatConversionDetected) {
        encode6._floatConversionDetected = true;
        console.warn(
          'WARNING: Possible data corruption detected with value "' + data + '":',
          'Bencoding only defines support for integers, value was converted to "' + val + '"'
        );
        console.trace();
      }
    };
    encode6.dict = function(buffers, data) {
      buffers.push(buffD3);
      let j = 0;
      let k;
      const keys = Object.keys(data).sort();
      const kl = keys.length;
      for (; j < kl; j++) {
        k = keys[j];
        if (data[k] == null)
          continue;
        encode6.string(buffers, k);
        encode6._encode(buffers, data[k]);
      }
      buffers.push(buffE3);
    };
    encode6.dictMap = function(buffers, data) {
      buffers.push(buffD3);
      const keys = Array.from(data.keys()).sort();
      for (const key of keys) {
        if (data.get(key) == null)
          continue;
        Buffer.isBuffer(key) ? encode6._encode(buffers, key) : encode6.string(buffers, String(key));
        encode6._encode(buffers, data.get(key));
      }
      buffers.push(buffE3);
    };
    encode6.list = function(buffers, data) {
      let i = 0;
      const c = data.length;
      buffers.push(buffL3);
      for (; i < c; i++) {
        if (data[i] == null)
          continue;
        encode6._encode(buffers, data[i]);
      }
      buffers.push(buffE3);
    };
    encode6.listSet = function(buffers, data) {
      buffers.push(buffL3);
      for (const item of data) {
        if (item == null)
          continue;
        encode6._encode(buffers, item);
      }
      buffers.push(buffE3);
    };
    module2.exports = encode6;
  }
});

// ../../node_modules/k-rpc-socket/node_modules/bencode/lib/decode.js
var require_decode = __commonJS({
  "../../node_modules/k-rpc-socket/node_modules/bencode/lib/decode.js"(exports, module2) {
    var INTEGER_START3 = 105;
    var STRING_DELIM3 = 58;
    var DICTIONARY_START3 = 100;
    var LIST_START3 = 108;
    var END_OF_TYPE3 = 101;
    function getIntFromBuffer3(buffer, start, end) {
      let sum = 0;
      let sign = 1;
      for (let i = start; i < end; i++) {
        const num = buffer[i];
        if (num < 58 && num >= 48) {
          sum = sum * 10 + (num - 48);
          continue;
        }
        if (i === start && num === 43) {
          continue;
        }
        if (i === start && num === 45) {
          sign = -1;
          continue;
        }
        if (num === 46) {
          break;
        }
        throw new Error("not a number: buffer[" + i + "] = " + num);
      }
      return sum * sign;
    }
    function decode7(data, start, end, encoding) {
      if (data == null || data.length === 0) {
        return null;
      }
      if (typeof start !== "number" && encoding == null) {
        encoding = start;
        start = void 0;
      }
      if (typeof end !== "number" && encoding == null) {
        encoding = end;
        end = void 0;
      }
      decode7.position = 0;
      decode7.encoding = encoding || null;
      decode7.data = !Buffer.isBuffer(data) ? Buffer.from(data) : data.slice(start, end);
      decode7.bytes = decode7.data.length;
      return decode7.next();
    }
    decode7.bytes = 0;
    decode7.position = 0;
    decode7.data = null;
    decode7.encoding = null;
    decode7.next = function() {
      switch (decode7.data[decode7.position]) {
        case DICTIONARY_START3:
          return decode7.dictionary();
        case LIST_START3:
          return decode7.list();
        case INTEGER_START3:
          return decode7.integer();
        default:
          return decode7.buffer();
      }
    };
    decode7.find = function(chr) {
      let i = decode7.position;
      const c = decode7.data.length;
      const d = decode7.data;
      while (i < c) {
        if (d[i] === chr)
          return i;
        i++;
      }
      throw new Error(
        'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
      );
    };
    decode7.dictionary = function() {
      decode7.position++;
      const dict = {};
      while (decode7.data[decode7.position] !== END_OF_TYPE3) {
        dict[decode7.buffer()] = decode7.next();
      }
      decode7.position++;
      return dict;
    };
    decode7.list = function() {
      decode7.position++;
      const lst = [];
      while (decode7.data[decode7.position] !== END_OF_TYPE3) {
        lst.push(decode7.next());
      }
      decode7.position++;
      return lst;
    };
    decode7.integer = function() {
      const end = decode7.find(END_OF_TYPE3);
      const number = getIntFromBuffer3(decode7.data, decode7.position + 1, end);
      decode7.position += end + 1 - decode7.position;
      return number;
    };
    decode7.buffer = function() {
      let sep = decode7.find(STRING_DELIM3);
      const length2 = getIntFromBuffer3(decode7.data, decode7.position, sep);
      const end = ++sep + length2;
      decode7.position = end;
      return decode7.encoding ? decode7.data.toString(decode7.encoding, sep, end) : decode7.data.slice(sep, end);
    };
    module2.exports = decode7;
  }
});

// ../../node_modules/k-rpc-socket/node_modules/bencode/lib/encoding-length.js
var require_encoding_length = __commonJS({
  "../../node_modules/k-rpc-socket/node_modules/bencode/lib/encoding-length.js"(exports, module2) {
    var { digitCount: digitCount3, getType: getType3 } = require_util();
    function listLength3(list) {
      let length2 = 1 + 1;
      for (const value of list) {
        length2 += encodingLength6(value);
      }
      return length2;
    }
    function mapLength3(map) {
      let length2 = 1 + 1;
      for (const [key, value] of map) {
        const keyLength = Buffer.byteLength(key);
        length2 += digitCount3(keyLength) + 1 + keyLength;
        length2 += encodingLength6(value);
      }
      return length2;
    }
    function objectLength3(value) {
      let length2 = 1 + 1;
      const keys = Object.keys(value);
      for (let i = 0; i < keys.length; i++) {
        const keyLength = Buffer.byteLength(keys[i]);
        length2 += digitCount3(keyLength) + 1 + keyLength;
        length2 += encodingLength6(value[keys[i]]);
      }
      return length2;
    }
    function stringLength3(value) {
      const length2 = Buffer.byteLength(value);
      return digitCount3(length2) + 1 + length2;
    }
    function arrayBufferLength3(value) {
      const length2 = value.byteLength - value.byteOffset;
      return digitCount3(length2) + 1 + length2;
    }
    function encodingLength6(value) {
      const length2 = 0;
      if (value == null)
        return length2;
      const type = getType3(value);
      switch (type) {
        case "buffer":
          return digitCount3(value.length) + 1 + value.length;
        case "arraybufferview":
          return arrayBufferLength3(value);
        case "string":
          return stringLength3(value);
        case "array":
        case "set":
          return listLength3(value);
        case "number":
          return 1 + digitCount3(Math.floor(value)) + 1;
        case "bigint":
          return 1 + value.toString().length + 1;
        case "object":
          return objectLength3(value);
        case "map":
          return mapLength3(value);
        default:
          throw new TypeError(`Unsupported value of type "${type}"`);
      }
    }
    module2.exports = encodingLength6;
  }
});

// ../../node_modules/k-rpc-socket/node_modules/bencode/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/k-rpc-socket/node_modules/bencode/lib/index.js"(exports, module2) {
    var bencode = module2.exports;
    bencode.encode = require_encode();
    bencode.decode = require_decode();
    bencode.byteLength = bencode.encodingLength = require_encoding_length();
  }
});

// ../../node_modules/k-rpc-socket/index.js
var require_k_rpc_socket = __commonJS({
  "../../node_modules/k-rpc-socket/index.js"(exports, module2) {
    var dgram = require("dgram");
    var bencode = require_lib();
    var isIP = require("net").isIP;
    var dns2 = require("dns");
    var util = require("util");
    var events = require("events");
    var ETIMEDOUT = new Error("Query timed out");
    ETIMEDOUT.code = "ETIMEDOUT";
    var EUNEXPECTEDNODE = new Error("Unexpected node id");
    EUNEXPECTEDNODE.code = "EUNEXPECTEDNODE";
    module2.exports = RPC;
    function RPC(opts) {
      if (!(this instanceof RPC))
        return new RPC(opts);
      if (!opts)
        opts = {};
      var self = this;
      this.timeout = opts.timeout || 2e3;
      this.inflight = 0;
      this.destroyed = false;
      this.isIP = opts.isIP || isIP;
      this.socket = opts.socket || dgram.createSocket("udp4");
      this.socket.on("message", onmessage);
      this.socket.on("error", onerror);
      this.socket.on("listening", onlistening);
      this._tick = 0;
      this._ids = [];
      this._reqs = [];
      this._timer = setInterval(check, Math.floor(this.timeout / 4));
      events.EventEmitter.call(this);
      function check() {
        var missing = self.inflight;
        if (!missing)
          return;
        for (var i = 0; i < self._reqs.length; i++) {
          var req = self._reqs[i];
          if (!req)
            continue;
          if (req.ttl)
            req.ttl--;
          else
            self._cancel(i, ETIMEDOUT);
          if (!--missing)
            return;
        }
      }
      function onlistening() {
        self.emit("listening");
      }
      function onerror(err3) {
        if (err3.code === "EACCES" || err3.code === "EADDRINUSE")
          self.emit("error", err3);
        else
          self.emit("warning", err3);
      }
      function onmessage(buf, rinfo) {
        if (self.destroyed)
          return;
        if (!rinfo.port)
          return;
        try {
          var message = bencode.decode(buf);
        } catch (e) {
          return self.emit("warning", e);
        }
        var type = message && message.y && message.y.toString();
        if (type === "r" || type === "e") {
          if (!Buffer.isBuffer(message.t))
            return;
          try {
            var tid = message.t.readUInt16BE(0);
          } catch (err4) {
            return self.emit("warning", err4);
          }
          var index = self._ids.indexOf(tid);
          if (index === -1 || tid === 0) {
            self.emit("response", message, rinfo);
            self.emit("warning", new Error("Unexpected transaction id: " + tid));
            return;
          }
          var req = self._reqs[index];
          if (req.peer.host !== rinfo.address) {
            self.emit("response", message, rinfo);
            self.emit("warning", new Error("Out of order response"));
            return;
          }
          self._ids[index] = 0;
          self._reqs[index] = null;
          self.inflight--;
          if (type === "e") {
            var isArray = Array.isArray(message.e);
            var err3 = new Error(isArray ? message.e.join(" ") : "Unknown error");
            err3.code = isArray && message.e.length && typeof message.e[0] === "number" ? message.e[0] : 0;
            req.callback(err3, message, rinfo, req.message);
            self.emit("update");
            self.emit("postupdate");
            return;
          }
          var rid = message.r && message.r.id;
          if (req.peer && req.peer.id && rid && !req.peer.id.equals(rid)) {
            req.callback(EUNEXPECTEDNODE, null, rinfo);
            self.emit("update");
            self.emit("postupdate");
            return;
          }
          req.callback(null, message, rinfo, req.message);
          self.emit("update");
          self.emit("postupdate");
          self.emit("response", message, rinfo);
        } else if (type === "q") {
          self.emit("query", message, rinfo);
        } else {
          self.emit("warning", new Error("Unknown type: " + type));
        }
      }
    }
    util.inherits(RPC, events.EventEmitter);
    RPC.prototype.address = function() {
      return this.socket.address();
    };
    RPC.prototype.response = function(peer, req, res, cb) {
      this.send(peer, { t: req.t, y: "r", r: res }, cb);
    };
    RPC.prototype.error = function(peer, req, error, cb) {
      this.send(peer, { t: req.t, y: "e", e: [].concat(error.message || error) }, cb);
    };
    RPC.prototype.send = function(peer, message, cb) {
      var buf = bencode.encode(message);
      this.socket.send(buf, 0, buf.length, peer.port, peer.address || peer.host, cb || noop2);
    };
    RPC.prototype.bind = function() {
      this.socket.bind.apply(this.socket, arguments);
    };
    RPC.prototype.destroy = function(cb) {
      this.destroyed = true;
      clearInterval(this._timer);
      if (cb)
        this.socket.on("close", cb);
      for (var i = 0; i < this._ids.length; i++)
        this._cancel(i);
      this.socket.close();
    };
    RPC.prototype.query = function(peer, query, cb) {
      if (!cb)
        cb = noop2;
      if (!this.isIP(peer.host))
        return this._resolveAndQuery(peer, query, cb);
      var message = {
        t: Buffer.allocUnsafe(2),
        y: "q",
        q: query.q,
        a: query.a
      };
      var req = {
        ttl: 4,
        peer,
        message,
        callback: cb
      };
      if (this._tick === 65535)
        this._tick = 0;
      var tid = ++this._tick;
      var free = this._ids.indexOf(0);
      if (free === -1)
        free = this._ids.push(0) - 1;
      this._ids[free] = tid;
      while (this._reqs.length < free)
        this._reqs.push(null);
      this._reqs[free] = req;
      this.inflight++;
      message.t.writeUInt16BE(tid, 0);
      this.send(peer, message);
      return tid;
    };
    RPC.prototype.cancel = function(tid, err3) {
      var index = this._ids.indexOf(tid);
      if (index > -1)
        this._cancel(index, err3);
    };
    RPC.prototype._cancel = function(index, err3) {
      var req = this._reqs[index];
      this._ids[index] = 0;
      this._reqs[index] = null;
      if (req) {
        this.inflight--;
        req.callback(err3 || new Error("Query was cancelled"), null, req.peer);
        this.emit("update");
        this.emit("postupdate");
      }
    };
    RPC.prototype._resolveAndQuery = function(peer, query, cb) {
      var self = this;
      dns2.lookup(peer.host, function(err3, ip) {
        if (err3)
          return cb(err3);
        if (self.destroyed)
          return cb(new Error("k-rpc-socket is destroyed"));
        self.query({ host: ip, port: peer.port }, query, cb);
      });
    };
    function noop2() {
    }
  }
});

// ../../node_modules/k-rpc/index.js
var require_k_rpc = __commonJS({
  "../../node_modules/k-rpc/index.js"(exports, module2) {
    var socket = require_k_rpc_socket();
    var KBucket2 = require_k_bucket();
    var events = require("events");
    var randombytes2 = require_randombytes();
    var util = require("util");
    var K = 20;
    var MAX_CONCURRENCY = 16;
    var BOOTSTRAP_NODES = [
      { host: "router.bittorrent.com", port: 6881 },
      { host: "router.utorrent.com", port: 6881 },
      { host: "dht.transmissionbt.com", port: 6881 }
    ];
    module2.exports = RPC;
    function RPC(opts) {
      if (!(this instanceof RPC))
        return new RPC(opts);
      if (!opts)
        opts = {};
      var self = this;
      this._idLength = opts.idLength || 20;
      this.id = toBuffer2(opts.id || opts.nodeId || randombytes2(this._idLength));
      this.socket = opts.krpcSocket || socket(opts);
      this.bootstrap = toBootstrapArray(opts.nodes || opts.bootstrap);
      this.concurrency = opts.concurrency || MAX_CONCURRENCY;
      this.backgroundConcurrency = opts.backgroundConcurrency || this.concurrency / 4 | 0;
      this.k = opts.k || K;
      this.destroyed = false;
      this.pending = [];
      this.nodes = null;
      this.socket.setMaxListeners(0);
      this.socket.on("query", onquery);
      this.socket.on("response", onresponse);
      this.socket.on("warning", onwarning);
      this.socket.on("error", onerror);
      this.socket.on("update", onupdate);
      this.socket.on("listening", onlistening);
      events.EventEmitter.call(this);
      this.clear();
      function onupdate() {
        while (self.pending.length && self.socket.inflight < self.concurrency) {
          var next = self.pending.shift();
          self.query(next[0], next[1], next[2]);
        }
      }
      function onerror(err3) {
        self.emit("error", err3);
      }
      function onlistening() {
        self.emit("listening");
      }
      function onwarning(err3) {
        self.emit("warning", err3);
      }
      function onquery(query, peer) {
        addNode(query.a, peer);
        self.emit("query", query, peer);
      }
      function onresponse(reply, peer) {
        addNode(reply.r, peer);
      }
      function addNode(data, peer) {
        if (data && isNodeId(data.id, self._idLength) && !data.id.equals(self.id)) {
          var old = self.nodes.get(data.id);
          if (old) {
            old.seen = Date.now();
            return;
          }
          self._addNode({
            id: data.id,
            host: peer.address || peer.host,
            port: peer.port,
            distance: 0,
            seen: Date.now()
          });
        }
      }
    }
    util.inherits(RPC, events.EventEmitter);
    RPC.prototype.response = function(node, query, response, nodes, cb) {
      if (typeof nodes === "function") {
        cb = nodes;
        nodes = null;
      }
      if (!response.id)
        response.id = this.id;
      if (nodes)
        response.nodes = encodeNodes(nodes, this._idLength);
      this.socket.response(node, query, response, cb);
    };
    RPC.prototype.error = function(node, query, error, cb) {
      this.socket.error(node, query, error, cb);
    };
    RPC.prototype.bind = function() {
      this.socket.bind.apply(this.socket, arguments);
    };
    RPC.prototype.address = function() {
      return this.socket.address();
    };
    RPC.prototype.queryAll = function(nodes, message, visit, cb) {
      if (!message.a)
        message.a = {};
      if (!message.a.id)
        message.a.id = this.id;
      var stop = false;
      var missing = nodes.length;
      var hits = 0;
      var error = null;
      if (!missing)
        return cb(new Error("No nodes to query"), 0);
      for (var i = 0; i < nodes.length; i++) {
        this.query(nodes[i], message, done);
      }
      function done(err3, res, peer) {
        if (!err3)
          hits++;
        else if (err3.code >= 300 && err3.code < 400)
          error = err3;
        if (!err3 && !stop) {
          if (visit && visit(res, peer) === false)
            stop = true;
        }
        if (!--missing)
          cb(hits ? null : error || new Error("All queries failed"), hits);
      }
    };
    RPC.prototype.query = function(node, message, cb) {
      if (this.socket.inflight >= this.concurrency) {
        this.pending.push([node, message, cb]);
      } else {
        if (!message.a)
          message.a = {};
        if (!message.a.id)
          message.a.id = this.id;
        if (node.token)
          message.a.token = node.token;
        this.socket.query(node, message, cb);
      }
    };
    RPC.prototype.destroy = function(cb) {
      this.destroyed = true;
      this.socket.destroy(cb);
    };
    RPC.prototype.clear = function() {
      var self = this;
      this.nodes = new KBucket2({
        localNodeId: this.id,
        numberOfNodesPerKBucket: this.k,
        numberOfNodesToPing: this.concurrency
      });
      this.nodes.on("ping", onping);
      function onping(older, newer) {
        self.emit("ping", older, function swap(deadNode) {
          if (!deadNode)
            return;
          if (deadNode.id)
            self.nodes.remove(deadNode.id);
          self._addNode(newer);
        });
      }
    };
    RPC.prototype.populate = function(target, message, cb) {
      this._closest(target, message, true, null, cb);
    };
    RPC.prototype.closest = function(target, message, visit, cb) {
      this._closest(target, message, false, visit, cb);
    };
    RPC.prototype._addNode = function(node) {
      var old = this.nodes.get(node.id);
      this.nodes.add(node);
      if (!old)
        this.emit("node", node);
    };
    RPC.prototype._closest = function(target, message, background, visit, cb) {
      if (!cb)
        cb = noop2;
      var self = this;
      var count = 0;
      var queried = {};
      var pending = 0;
      var once = true;
      var stop = false;
      if (!message.a)
        message.a = {};
      if (!message.a.id)
        message.a.id = this.id;
      var table = new KBucket2({
        localNodeId: target,
        numberOfNodesPerKBucket: this.k,
        numberOfNodesToPing: this.concurrency
      });
      var evt = background ? "postupdate" : "update";
      this.socket.on(evt, kick);
      kick();
      function kick() {
        if (self.destroyed || self.socket.inflight >= self.concurrency)
          return;
        var otherInflight = self.pending.length + self.socket.inflight - pending;
        if (background && self.socket.inflight >= self.backgroundConcurrency && otherInflight)
          return;
        var closest = table.closest(target, self.k);
        if (!closest.length || closest.length < self.bootstrap.length) {
          closest = self.nodes.closest(target, self.k);
          if (!closest.length || closest.length < self.bootstrap.length)
            bootstrap();
        }
        for (var i = 0; i < closest.length; i++) {
          if (stop)
            break;
          if (self.socket.inflight >= self.concurrency)
            return;
          var peer = closest[i];
          var id = peer.host + ":" + peer.port;
          if (queried[id])
            continue;
          queried[id] = true;
          pending++;
          self.socket.query(peer, message, afterQuery);
        }
        if (!pending) {
          self.socket.removeListener(evt, kick);
          process.nextTick(done);
        }
      }
      function done() {
        cb(null, count);
      }
      function bootstrap() {
        if (!once)
          return;
        once = false;
        self.bootstrap.forEach(function(peer) {
          pending++;
          self.socket.query(peer, message, afterQuery);
        });
      }
      function afterQuery(err3, res, peer) {
        pending--;
        if (peer)
          queried[(peer.address || peer.host) + ":" + peer.port] = true;
        if (peer && peer.id && self.nodes.get(peer.id)) {
          if (err3 && (err3.code === "EUNEXPECTEDNODE" || err3.code === "ETIMEDOUT")) {
            self.nodes.remove(peer.id);
          }
        }
        var r = res && res.r;
        if (!r)
          return kick();
        if (!err3 && isNodeId(r.id, self._idLength)) {
          count++;
          add({
            id: r.id,
            port: peer.port,
            host: peer.host || peer.address,
            distance: 0
          });
        }
        var nodes = r.nodes ? parseNodes(r.nodes, self._idLength) : [];
        for (var i = 0; i < nodes.length; i++)
          add(nodes[i]);
        if (visit && visit(res, peer) === false)
          stop = true;
        kick();
      }
      function add(node) {
        if (node.id.equals(self.id))
          return;
        table.add(node);
      }
    };
    function toBootstrapArray(val) {
      if (val === false)
        return [];
      if (val === true)
        return BOOTSTRAP_NODES;
      return [].concat(val || BOOTSTRAP_NODES).map(parsePeer);
    }
    function isNodeId(id, idLength) {
      return id && Buffer.isBuffer(id) && id.length === idLength;
    }
    function encodeNodes(nodes, idLength) {
      var buf = Buffer.allocUnsafe(nodes.length * (idLength + 6));
      var ptr = 0;
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!isNodeId(node.id, idLength))
          continue;
        node.id.copy(buf, ptr);
        ptr += idLength;
        var ip = (node.host || node.address).split(".");
        for (var j = 0; j < 4; j++)
          buf[ptr++] = parseInt(ip[j] || 0, 10);
        buf.writeUInt16BE(node.port, ptr);
        ptr += 2;
      }
      if (ptr === buf.length)
        return buf;
      return buf.slice(0, ptr);
    }
    function parseNodes(buf, idLength) {
      var contacts = [];
      try {
        for (var i = 0; i < buf.length; i += idLength + 6) {
          var port = buf.readUInt16BE(i + (idLength + 4));
          if (!port)
            continue;
          contacts.push({
            id: buf.slice(i, i + idLength),
            host: parseIp2(buf, i + idLength),
            port,
            distance: 0,
            token: null
          });
        }
      } catch (err3) {
      }
      return contacts;
    }
    function parseIp2(buf, offset) {
      return buf[offset++] + "." + buf[offset++] + "." + buf[offset++] + "." + buf[offset++];
    }
    function parsePeer(peer) {
      if (typeof peer === "string")
        return { host: peer.split(":")[0], port: Number(peer.split(":")[1]) };
      return peer;
    }
    function noop2() {
    }
    function toBuffer2(str3) {
      if (Buffer.isBuffer(str3))
        return str3;
      if (ArrayBuffer.isView(str3))
        return Buffer.from(str3.buffer, str3.byteOffset, str3.byteLength);
      if (typeof str3 === "string")
        return Buffer.from(str3, "hex");
      throw new Error("Pass a buffer or a string");
    }
  }
});

// ../../node_modules/last-one-wins/index.js
var require_last_one_wins = __commonJS({
  "../../node_modules/last-one-wins/index.js"(exports, module2) {
    module2.exports = function(work) {
      var pending = null;
      var callback = null;
      var callbacks = null;
      var next = null;
      return function(val, cb) {
        next = val;
        update(cb || noop2);
      };
      function update(cb) {
        if (callback) {
          if (!pending)
            pending = [];
          pending.push(cb);
          return;
        }
        var val = next;
        next = null;
        callback = cb;
        work(val, done);
      }
      function done(err3) {
        var cb = callback;
        var cbs = callbacks;
        callbacks = null;
        callback = null;
        if (pending) {
          callbacks = pending;
          pending = null;
          update(noop2);
        }
        if (cbs) {
          for (var i = 0; i < cbs.length; i++)
            cbs[i](err3);
        }
        cb(err3);
      }
    };
    function noop2(_) {
    }
  }
});

// ../../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../../node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../../node_modules/lru/index.js
var require_lru = __commonJS({
  "../../node_modules/lru/index.js"(exports, module2) {
    var events = require("events");
    var inherits = require_inherits();
    module2.exports = LRU2;
    function LRU2(opts) {
      if (!(this instanceof LRU2))
        return new LRU2(opts);
      if (typeof opts === "number")
        opts = { max: opts };
      if (!opts)
        opts = {};
      events.EventEmitter.call(this);
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
      this.max = opts.max || 1e3;
      this.maxAge = opts.maxAge || 0;
    }
    inherits(LRU2, events.EventEmitter);
    Object.defineProperty(LRU2.prototype, "keys", {
      get: function() {
        return Object.keys(this.cache);
      }
    });
    LRU2.prototype.clear = function() {
      this.cache = {};
      this.head = this.tail = null;
      this.length = 0;
    };
    LRU2.prototype.remove = function(key) {
      if (typeof key !== "string")
        key = "" + key;
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      delete this.cache[key];
      this._unlink(key, element.prev, element.next);
      return element.value;
    };
    LRU2.prototype._unlink = function(key, prev, next) {
      this.length--;
      if (this.length === 0) {
        this.head = this.tail = null;
      } else {
        if (this.head === key) {
          this.head = prev;
          this.cache[this.head].next = null;
        } else if (this.tail === key) {
          this.tail = next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[prev].next = next;
          this.cache[next].prev = prev;
        }
      }
    };
    LRU2.prototype.peek = function(key) {
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      if (!this._checkAge(key, element))
        return;
      return element.value;
    };
    LRU2.prototype.set = function(key, value) {
      if (typeof key !== "string")
        key = "" + key;
      var element;
      if (this.cache.hasOwnProperty(key)) {
        element = this.cache[key];
        element.value = value;
        if (this.maxAge)
          element.modified = Date.now();
        if (key === this.head)
          return value;
        this._unlink(key, element.prev, element.next);
      } else {
        element = { value, modified: 0, next: null, prev: null };
        if (this.maxAge)
          element.modified = Date.now();
        this.cache[key] = element;
        if (this.length === this.max)
          this.evict();
      }
      this.length++;
      element.next = null;
      element.prev = this.head;
      if (this.head)
        this.cache[this.head].next = key;
      this.head = key;
      if (!this.tail)
        this.tail = key;
      return value;
    };
    LRU2.prototype._checkAge = function(key, element) {
      if (this.maxAge && Date.now() - element.modified > this.maxAge) {
        this.remove(key);
        this.emit("evict", { key, value: element.value });
        return false;
      }
      return true;
    };
    LRU2.prototype.get = function(key) {
      if (typeof key !== "string")
        key = "" + key;
      if (!this.cache.hasOwnProperty(key))
        return;
      var element = this.cache[key];
      if (!this._checkAge(key, element))
        return;
      if (this.head !== key) {
        if (key === this.tail) {
          this.tail = element.next;
          this.cache[this.tail].prev = null;
        } else {
          this.cache[element.prev].next = element.next;
        }
        this.cache[element.next].prev = element.prev;
        this.cache[this.head].next = key;
        element.prev = this.head;
        element.next = null;
        this.head = key;
      }
      return element.value;
    };
    LRU2.prototype.evict = function() {
      if (!this.tail)
        return;
      var key = this.tail;
      var value = this.remove(this.tail);
      this.emit("evict", { key, value });
    };
  }
});

// ../../node_modules/b4a/index.js
var require_b4a = __commonJS({
  "../../node_modules/b4a/index.js"(exports, module2) {
    function isBuffer(value) {
      return Buffer.isBuffer(value) || value instanceof Uint8Array;
    }
    function isEncoding(encoding) {
      return Buffer.isEncoding(encoding);
    }
    function alloc(size, fill2, encoding) {
      return Buffer.alloc(size, fill2, encoding);
    }
    function allocUnsafe(size) {
      return Buffer.allocUnsafe(size);
    }
    function allocUnsafeSlow(size) {
      return Buffer.allocUnsafeSlow(size);
    }
    function byteLength(string, encoding) {
      return Buffer.byteLength(string, encoding);
    }
    function compare(a, b) {
      return Buffer.compare(a, b);
    }
    function concat2(buffers, totalLength) {
      return Buffer.concat(buffers, totalLength);
    }
    function copy(source, target, targetStart, start, end) {
      return toBuffer2(source).copy(target, targetStart, start, end);
    }
    function equals2(a, b) {
      return toBuffer2(a).equals(b);
    }
    function fill(buffer, value, offset, end, encoding) {
      return toBuffer2(buffer).fill(value, offset, end, encoding);
    }
    function from3(value, encodingOrOffset, length2) {
      return Buffer.from(value, encodingOrOffset, length2);
    }
    function includes(buffer, value, byteOffset, encoding) {
      return toBuffer2(buffer).includes(value, byteOffset, encoding);
    }
    function indexOf(buffer, value, byfeOffset, encoding) {
      return toBuffer2(buffer).indexOf(value, byfeOffset, encoding);
    }
    function lastIndexOf(buffer, value, byteOffset, encoding) {
      return toBuffer2(buffer).lastIndexOf(value, byteOffset, encoding);
    }
    function swap16(buffer) {
      return toBuffer2(buffer).swap16();
    }
    function swap32(buffer) {
      return toBuffer2(buffer).swap32();
    }
    function swap64(buffer) {
      return toBuffer2(buffer).swap64();
    }
    function toBuffer2(buffer) {
      if (Buffer.isBuffer(buffer))
        return buffer;
      return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    }
    function toString(buffer, encoding, start, end) {
      return toBuffer2(buffer).toString(encoding, start, end);
    }
    function write(buffer, string, offset, length2, encoding) {
      return toBuffer2(buffer).write(string, offset, length2, encoding);
    }
    function writeDoubleLE(buffer, value, offset) {
      return toBuffer2(buffer).writeDoubleLE(value, offset);
    }
    function writeFloatLE(buffer, value, offset) {
      return toBuffer2(buffer).writeFloatLE(value, offset);
    }
    function writeUInt32LE(buffer, value, offset) {
      return toBuffer2(buffer).writeUInt32LE(value, offset);
    }
    function writeInt32LE(buffer, value, offset) {
      return toBuffer2(buffer).writeInt32LE(value, offset);
    }
    function readDoubleLE(buffer, offset) {
      return toBuffer2(buffer).readDoubleLE(offset);
    }
    function readFloatLE(buffer, offset) {
      return toBuffer2(buffer).readFloatLE(offset);
    }
    function readUInt32LE(buffer, offset) {
      return toBuffer2(buffer).readUInt32LE(offset);
    }
    function readInt32LE(buffer, offset) {
      return toBuffer2(buffer).readInt32LE(offset);
    }
    module2.exports = {
      isBuffer,
      isEncoding,
      alloc,
      allocUnsafe,
      allocUnsafeSlow,
      byteLength,
      compare,
      concat: concat2,
      copy,
      equals: equals2,
      fill,
      from: from3,
      includes,
      indexOf,
      lastIndexOf,
      swap16,
      swap32,
      swap64,
      toBuffer: toBuffer2,
      toString,
      write,
      writeDoubleLE,
      writeFloatLE,
      writeUInt32LE,
      writeInt32LE,
      readDoubleLE,
      readFloatLE,
      readUInt32LE,
      readInt32LE
    };
  }
});

// ../../node_modules/record-cache/index.js
var require_record_cache = __commonJS({
  "../../node_modules/record-cache/index.js"(exports, module2) {
    var b4a = require_b4a();
    var EMPTY = [];
    module2.exports = RecordCache;
    function RecordSet() {
      this.list = [];
      this.map = /* @__PURE__ */ new Map();
    }
    RecordSet.prototype.add = function(record, value) {
      var k = toString(record);
      var r = this.map.get(k);
      if (r)
        return false;
      r = { index: this.list.length, record: value || record };
      this.list.push(r);
      this.map.set(k, r);
      return true;
    };
    RecordSet.prototype.remove = function(record) {
      var k = toString(record);
      var r = this.map.get(k);
      if (!r)
        return false;
      swap(this.list, r.index, this.list.length - 1);
      this.list.pop();
      this.map.delete(k);
      return true;
    };
    function RecordStore() {
      this.records = /* @__PURE__ */ new Map();
      this.size = 0;
    }
    RecordStore.prototype.add = function(name, record, value) {
      var r = this.records.get(name);
      if (!r) {
        r = new RecordSet();
        this.records.set(name, r);
      }
      if (r.add(record, value)) {
        this.size++;
        return true;
      }
      return false;
    };
    RecordStore.prototype.remove = function(name, record, value) {
      var r = this.records.get(name);
      if (!r)
        return false;
      if (r.remove(record, value)) {
        this.size--;
        if (!r.map.size)
          this.records.delete(name);
        return true;
      }
      return false;
    };
    RecordStore.prototype.get = function(name) {
      var r = this.records.get(name);
      return r ? r.list : EMPTY;
    };
    function RecordCache(opts) {
      if (!(this instanceof RecordCache))
        return new RecordCache(opts);
      if (!opts)
        opts = {};
      this.maxSize = opts.maxSize || Infinity;
      this.maxAge = opts.maxAge || 0;
      this._onstale = opts.onStale || opts.onstale || null;
      this._fresh = new RecordStore();
      this._stale = new RecordStore();
      this._interval = null;
      this._gced = false;
      if (this.maxAge && this.maxAge < Infinity) {
        var tick = Math.ceil(2 / 3 * this.maxAge);
        this._interval = setInterval(this._gcAuto.bind(this), tick);
        if (this._interval.unref)
          this._interval.unref();
      }
    }
    Object.defineProperty(RecordCache.prototype, "size", {
      get: function() {
        return this._fresh.size + this._stale.size;
      }
    });
    RecordCache.prototype.add = function(name, record, value) {
      this._stale.remove(name, record, value);
      if (this._fresh.add(name, record, value) && this._fresh.size > this.maxSize) {
        this._gc();
      }
    };
    RecordCache.prototype.remove = function(name, record, value) {
      this._fresh.remove(name, record, value);
      this._stale.remove(name, record, value);
    };
    RecordCache.prototype.get = function(name, n) {
      var a = this._fresh.get(name);
      var b = this._stale.get(name);
      var aLen = a.length;
      var bLen = b.length;
      var len = aLen + bLen;
      if (n > len || !n)
        n = len;
      var result = new Array(n);
      for (var i = 0; i < n; i++) {
        var j = Math.floor(Math.random() * (aLen + bLen));
        if (j < aLen) {
          result[i] = a[j].record;
          swap(a, j, --aLen);
        } else {
          j -= aLen;
          result[i] = b[j].record;
          swap(b, j, --bLen);
        }
      }
      return result;
    };
    RecordCache.prototype._gcAuto = function() {
      if (!this._gced)
        this._gc();
      this._gced = false;
    };
    RecordCache.prototype._gc = function() {
      if (this._onstale && this._stale.size > 0)
        this._onstale(this._stale);
      this._stale = this._fresh;
      this._fresh = new RecordStore();
      this._gced = true;
    };
    RecordCache.prototype.clear = function() {
      this._gc();
      this._gc();
    };
    RecordCache.prototype.destroy = function() {
      this.clear();
      clearInterval(this._interval);
      this._interval = null;
    };
    function toString(record) {
      return b4a.isBuffer(record) ? b4a.toString(record, "hex") : record;
    }
    function swap(list, a, b) {
      var tmp = list[a];
      tmp.index = b;
      list[b].index = a;
      list[a] = list[b];
      list[b] = tmp;
    }
  }
});

// ../../node_modules/safety-catch/index.js
var require_safety_catch = __commonJS({
  "../../node_modules/safety-catch/index.js"(exports, module2) {
    module2.exports = safetyCatch;
    function isActuallyUncaught(err3) {
      if (!err3)
        return false;
      return err3 instanceof TypeError || err3 instanceof SyntaxError || err3 instanceof ReferenceError || err3 instanceof EvalError || err3 instanceof RangeError || err3 instanceof URIError || err3.code === "ERR_ASSERTION";
    }
    function throwErrorNT(err3) {
      queueMicrotask(() => {
        throw err3;
      });
    }
    function safetyCatch(err3) {
      if (isActuallyUncaught(err3)) {
        throwErrorNT(err3);
        throw err3;
      }
    }
  }
});

// ../../node_modules/graceful-goodbye/index.js
var require_graceful_goodbye = __commonJS({
  "../../node_modules/graceful-goodbye/index.js"(exports, module2) {
    var safetyCatch = require_safety_catch();
    module2.exports = goodbye2;
    var handlers = [];
    var exitCode = 0;
    var forceExit = false;
    goodbye2.exiting = false;
    goodbye2.exit = exit;
    var onsigint = onsignal.bind(null, "SIGINT");
    var onsigterm = onsignal.bind(null, "SIGTERM");
    function onsignal(name) {
      forceExit = forceExit || process.listenerCount(name) === 1;
      process.removeListener("SIGINT", onsigint);
      process.removeListener("SIGTERM", onsigterm);
      exitCode = 130;
      onexit();
    }
    function onexit() {
      if (goodbye2.exiting)
        return;
      goodbye2.exiting = true;
      process.removeListener("beforeExit", onexit);
      const order = [];
      for (const h of handlers.sort((a, b) => b.position - a.position)) {
        if (!order.length || order[order.length - 1][0].position !== h.position)
          order.push([]);
        order[order.length - 1].push(h);
      }
      loop();
      function loop() {
        if (!order.length)
          return done();
        Promise.allSettled(order.pop().map(run)).then(loop, loop);
      }
      function done() {
        if (forceExit)
          process.exit(exitCode);
      }
    }
    async function run(h) {
      try {
        await h.fn();
      } catch (e) {
        safetyCatch(e);
      }
    }
    function setup() {
      process.prependListener("beforeExit", onexit);
      process.prependListener("SIGINT", onsigint);
      process.prependListener("SIGTERM", onsigterm);
    }
    function cleanup() {
      process.removeListener("beforeExit", onexit);
      process.removeListener("SIGINT", onsigint);
      process.removeListener("SIGTERM", onsigterm);
    }
    function goodbye2(fn, position = 0) {
      if (handlers.length === 0)
        setup();
      const handler = { position, fn };
      handlers.push(handler);
      return function unregister() {
        const i = handlers.indexOf(handler);
        if (i > -1)
          handlers.splice(i, 1);
        if (!handlers.length)
          cleanup();
      };
    }
    function exit() {
      forceExit = true;
      process.removeListener("SIGINT", onsigint);
      process.removeListener("SIGTERM", onsigterm);
      onexit();
    }
  }
});

// ../../node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../../node_modules/uri-js/dist/es5/uri.all.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str3) {
        return "(?:" + str3 + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str3) {
        return str3.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = /* @__PURE__ */ function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err3) {
            _d = true;
            _e = err3;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length2 = array.length;
        while (length2--) {
          result[length2] = fn(array[length2]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length2 = string.length;
        while (counter < length2) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length2) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode7 = function decode8(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode6 = function encode7(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err3) {
          _didIteratorError = true;
          _iteratorError = err3;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err3) {
            _didIteratorError2 = true;
            _iteratorError2 = err3;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err3) {
            _didIteratorError3 = true;
            _iteratorError3 = err3;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode7(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode6(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode7,
        "encode": encode6,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str3) {
        var newStr = "";
        var i = 0;
        var il = str3.length;
        while (i < il) {
          var c = parseInt(str3.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str3.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str3.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str3.substr(i + 4, 2), 16);
              var c3 = parseInt(str3.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str3.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str3.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str3) {
          var decStr = pctDecChars(str3);
          return !decStr.match(protocol.UNRESERVED) ? str3 : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str3) {
        return str3.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse3(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse3(serialize(base2, options), options);
          relative = parse3(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse3(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse3(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse3(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse3(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str3, options) {
        return str3 && str3.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str3, options) {
        return str3 && str3.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse4(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse4(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path2 = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path2 && path2 !== "/" ? path2 : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str3) {
        var decStr = pctDecChars(str3);
        return !decStr.match(UNRESERVED) ? str3 : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse4(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse3;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
  "../../node_modules/canonicalize/lib/canonicalize.js"(exports, module2) {
    "use strict";
    module2.exports = function serialize(object) {
      if (typeof object === "number" && isNaN(object)) {
        throw new Error("NaN is not allowed");
      }
      if (typeof object === "number" && !isFinite(object)) {
        throw new Error("Infinity is not allowed");
      }
      if (object === null || typeof object !== "object") {
        return JSON.stringify(object);
      }
      if (object.toJSON instanceof Function) {
        return serialize(object.toJSON());
      }
      if (Array.isArray(object)) {
        const values2 = object.reduce((t, cv, ci) => {
          const comma = ci === 0 ? "" : ",";
          const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
          return `${t}${comma}${serialize(value)}`;
        }, "");
        return `[${values2}]`;
      }
      const values = Object.keys(object).sort().reduce((t, cv) => {
        if (object[cv] === void 0 || typeof object[cv] === "symbol") {
          return t;
        }
        const comma = t.length === 0 ? "" : ",";
        return `${t}${comma}${serialize(cv)}:${serialize(object[cv])}`;
      }, "");
      return `{${values}}`;
    };
  }
});

// ../../node_modules/@multiformats/base-x/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/@multiformats/base-x/src/index.js"(exports, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode6(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str3 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str3 += ALPHABET.charAt(b58[it2]);
        }
        return str3;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode7(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode6,
        decodeUnsafe,
        decode: decode7
      };
    }
    module2.exports = base;
  }
});

// ../../node_modules/multibase/src/util.js
var require_util2 = __commonJS({
  "../../node_modules/multibase/src/util.js"(exports, module2) {
    "use strict";
    var textDecoder = new TextDecoder();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder();
    var encodeText = (text) => textEncoder.encode(text);
    function concat2(arrs, length2) {
      const output = new Uint8Array(length2);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module2.exports = { decodeText, encodeText, concat: concat2 };
  }
});

// ../../node_modules/multibase/src/base.js
var require_base = __commonJS({
  "../../node_modules/multibase/src/base.js"(exports, module2) {
    "use strict";
    var { encodeText } = require_util2();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet2) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet2;
        this.codec = factory(alphabet2);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module2.exports = Base;
  }
});

// ../../node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "../../node_modules/multibase/src/rfc4648.js"(exports, module2) {
    "use strict";
    var decode7 = (string, alphabet2, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode6 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = (bitsPerChar) => (alphabet2) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode6(input, alphabet2, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode7(input, alphabet2, bitsPerChar);
        }
      };
    };
    module2.exports = { rfc4648: rfc46482 };
  }
});

// ../../node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "../../node_modules/multibase/src/constants.js"(exports, module2) {
    "use strict";
    var baseX = require_src2();
    var Base = require_base();
    var { rfc4648: rfc46482 } = require_rfc4648();
    var { decodeText, encodeText } = require_util2();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc46482(1), "01"],
      ["base8", "7", rfc46482(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc46482(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46482(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46482(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46482(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46482(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names,
      codes
    };
  }
});

// ../../node_modules/multibase/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/multibase/src/index.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat: concat2 } = require_util2();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat2([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode6(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat2([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode7(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err3) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports = module2.exports = multibase;
    exports.encode = encode6;
    exports.decode = decode7;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes;
  }
});

// ../../node_modules/multihashes/node_modules/varint/encode.js
var require_encode2 = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/encode.js"(exports, module2) {
    module2.exports = encode6;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode6(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode6.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/multihashes/node_modules/varint/decode.js
var require_decode2 = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/decode.js"(exports, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/multihashes/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/length.js"(exports, module2) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// ../../node_modules/multihashes/node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/index.js"(exports, module2) {
    module2.exports = {
      encode: require_encode2(),
      decode: require_decode2(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/multihashes/src/constants.js"(exports, module2) {
    "use strict";
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module2.exports = { names };
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/base-x.js"(exports, module2) {
    "use strict";
    function base(ALPHABET, name) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode6(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str3 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str3 += ALPHABET.charAt(b58[it2]);
        }
        return str3;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode7(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error(`Non-${name} character`);
      }
      return {
        encode: encode6,
        decodeUnsafe,
        decode: decode7
      };
    }
    var src = base;
    var _brrp__multiformats_scope_baseX = src;
    module2.exports = _brrp__multiformats_scope_baseX;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var empty2 = new Uint8Array(0);
    var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
    };
    var equals2 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    var fromString = (str3) => new TextEncoder().encode(str3);
    var toString = (b) => new TextDecoder().decode(b);
    exports.coerce = coerce2;
    exports.empty = empty2;
    exports.equals = equals2;
    exports.fromHex = fromHex;
    exports.fromString = fromString;
    exports.isBinary = isBinary;
    exports.toHex = toHex;
    exports.toString = toString;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base.js
var require_base2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes = require_bytes();
    var Encoder3 = class {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder2 = class {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder2) {
        return or2(this, decoder2);
      }
      decode(input) {
        const prefix = input[0];
        const decoder2 = this.decoders[prefix];
        if (decoder2) {
          return decoder2.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec2 = class {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name, prefix, baseEncode);
        this.decoder = new Decoder2(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name, prefix, encode: encode7, decode: decode8 }) => new Codec2(name, prefix, encode7, decode8);
    var baseX = ({ prefix, name, alphabet: alphabet2 }) => {
      const { encode: encode7, decode: decode8 } = baseX$1(alphabet2, name);
      return from3({
        prefix,
        name,
        encode: encode7,
        decode: (text) => bytes.coerce(decode8(text))
      });
    };
    var decode7 = (string, alphabet2, bitsPerChar, name) => {
      const codes = {};
      for (let i = 0; i < alphabet2.length; ++i) {
        codes[alphabet2[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode6 = (data, alphabet2, bitsPerChar) => {
      const pad = alphabet2[alphabet2.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet2[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet2[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name, prefix, bitsPerChar, alphabet: alphabet2 }) => {
      return from3({
        prefix,
        name,
        encode(input) {
          return encode6(input, alphabet2, bitsPerChar);
        },
        decode(input) {
          return decode7(input, alphabet2, bitsPerChar, name);
        }
      });
    };
    exports.Codec = Codec2;
    exports.baseX = baseX;
    exports.from = from3;
    exports.or = or2;
    exports.rfc4648 = rfc46482;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var bytes = require_bytes();
    var identity = base.from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => bytes.toString(buf),
      decode: (str3) => bytes.fromString(str3)
    });
    exports.identity = identity;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base2.js
var require_base22 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base2 = base.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports.base2 = base2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base8 = base.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports.base8 = base8;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base10.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base10 = base.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports.base10 = base10;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base16 = base.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper = base.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports.base16 = base16;
    exports.base16upper = base16upper;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base32 = base.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper = base.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad = base.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper = base.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex = base.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper = base.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad = base.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper = base.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z = base.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports.base32 = base32;
    exports.base32hex = base32hex;
    exports.base32hexpad = base32hexpad;
    exports.base32hexpadupper = base32hexpadupper;
    exports.base32hexupper = base32hexupper;
    exports.base32pad = base32pad;
    exports.base32padupper = base32padupper;
    exports.base32upper = base32upper;
    exports.base32z = base32z;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base36.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base36 = base.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper = base.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports.base36 = base36;
    exports.base36upper = base36upper;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base58.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base58btc = base.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr = base.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports.base58btc = base58btc;
    exports.base58flickr = base58flickr;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base64.js
var require_base64 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base642 = base.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = base.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = base.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = base.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports.base64 = base642;
    exports.base64pad = base64pad2;
    exports.base64url = base64url2;
    exports.base64urlpad = base64urlpad2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var alphabet2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars = alphabet2.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes = alphabet2.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode6(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
      }, "");
    }
    function decode7(str3) {
      const byts = [];
      for (const char of str3) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji = base.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode6,
      decode: decode7
    });
    exports.base256emoji = base256emoji;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/vendor/varint.js"(exports, module2) {
    "use strict";
    var encode_12 = encode6;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode6(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode6.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode7 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint2 = {
      encode: encode_12,
      decode: decode7,
      encodingLength: length2
    };
    var _brrp_varint2 = varint2;
    var varint$1 = _brrp_varint2;
    module2.exports = varint$1;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/varint.js
var require_varint3 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varint$1 = require_varint2();
    var decode7 = (data, offset = 0) => {
      const code = varint$1.decode(data, offset);
      return [
        code,
        varint$1.decode.bytes
      ];
    };
    var encodeTo2 = (int, target, offset = 0) => {
      varint$1.encode(int, target, offset);
      return target;
    };
    var encodingLength6 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports.decode = decode7;
    exports.encodeTo = encodeTo2;
    exports.encodingLength = encodingLength6;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/digest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var varint2 = require_varint3();
    var create2 = (code, digest) => {
      const size = digest.byteLength;
      const sizeOffset = varint2.encodingLength(code);
      const digestOffset = sizeOffset + varint2.encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      varint2.encodeTo(code, bytes2, 0);
      varint2.encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest, digestOffset);
      return new Digest2(code, size, digest, bytes2);
    };
    var decode7 = (multihash) => {
      const bytes$1 = bytes.coerce(multihash);
      const [code, sizeOffset] = varint2.decode(bytes$1);
      const [size, digestOffset] = varint2.decode(bytes$1.subarray(sizeOffset));
      const digest = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code, size, digest, bytes$1);
    };
    var equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code, size, digest, bytes2) {
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes2;
      }
    };
    exports.Digest = Digest2;
    exports.create = create2;
    exports.decode = decode7;
    exports.equals = equals2;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var digest = require_digest();
    var from3 = ({ name, code, encode: encode6 }) => new Hasher2(name, code, encode6);
    var Hasher2 = class {
      constructor(name, code, encode6) {
        this.name = name;
        this.code = code;
        this.encode = encode6;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? digest.create(this.code, result) : result.then((digest$1) => digest.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports.Hasher = Hasher2;
    exports.from = from3;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto4 = require("crypto");
    var hasher = require_hasher();
    var bytes = require_bytes();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto4);
    var sha2562 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha256").update(input).digest())
    });
    var sha5122 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha512").update(input).digest())
    });
    exports.sha256 = sha2562;
    exports.sha512 = sha5122;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/hashes/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var digest$1 = require_digest();
    var code = 0;
    var name = "identity";
    var encode6 = bytes.coerce;
    var digest = (input) => digest$1.create(code, encode6(input));
    var identity = {
      code,
      name,
      encode: encode6,
      digest
    };
    exports.identity = identity;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/raw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var name = "raw";
    var code = 85;
    var encode6 = (node) => bytes.coerce(node);
    var decode7 = (data) => bytes.coerce(data);
    exports.code = code;
    exports.decode = decode7;
    exports.encode = encode6;
    exports.name = name;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/codecs/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    var name = "json";
    var code = 512;
    var encode6 = (node) => textEncoder.encode(JSON.stringify(node));
    var decode7 = (data) => JSON.parse(textDecoder.decode(data));
    exports.code = code;
    exports.decode = decode7;
    exports.encode = encode6;
    exports.name = name;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/cid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varint2 = require_varint3();
    var digest = require_digest();
    var base58 = require_base58();
    var base32 = require_base32();
    var bytes = require_bytes();
    var CID = class _CID {
      constructor(version2, code, multihash, bytes2) {
        this.code = code;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code, multihash } = this;
            if (code !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return _CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code, digest: digest$1 } = this.multihash;
            const multihash = digest.create(code, digest$1);
            return _CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);
      }
      toString(base) {
        const { bytes: bytes2, version: version2, _baseCache } = this;
        switch (version2) {
          case 0:
            return toStringV0(bytes2, _baseCache, base || base58.base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base || base32.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof _CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version2, code, multihash, bytes: bytes2 } = value;
          return new _CID(version2, code, multihash, bytes2 || encodeCID(version2, code, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version2, multihash, code } = value;
          const digest$1 = digest.decode(multihash);
          return _CID.create(version2, code, digest$1);
        } else {
          return null;
        }
      }
      static create(version2, code, digest2) {
        if (typeof code !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version2) {
          case 0: {
            if (code !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new _CID(version2, code, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version2, code, digest2.bytes);
            return new _CID(version2, code, digest2, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return _CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code, digest2) {
        return _CID.create(1, code, digest2);
      }
      static decode(bytes2) {
        const [cid, remainder] = _CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = _CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? _CID.createV0(digest$1) : _CID.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = varint2.decode(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version2 = next();
        let codec = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else if (version2 === 1) {
          codec = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version2,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base) {
        const [prefix, bytes2] = parseCIDtoBytes(source, base);
        const cid = _CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes = (source, base) => {
      switch (source[0]) {
        case "Q": {
          const decoder2 = base || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder2 = base || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder2.decode(source)
          ];
        }
        case base32.base32.prefix: {
          const decoder2 = base || base32.base32;
          return [
            base32.base32.prefix,
            decoder2.decode(source)
          ];
        }
        default: {
          if (base == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base.decode(source)
          ];
        }
      }
    };
    var toStringV0 = (bytes2, cache, base) => {
      const { prefix } = base;
      if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base.encode(bytes2).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV1 = (bytes2, cache, base) => {
      const { prefix } = base;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base.encode(bytes2);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE = 112;
    var SHA_256_CODE = 18;
    var encodeCID = (version2, code, multihash) => {
      const codeOffset = varint2.encodingLength(version2);
      const hashOffset = codeOffset + varint2.encodingLength(code);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      varint2.encodeTo(version2, bytes2, 0);
      varint2.encodeTo(code, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol = Symbol.for("@ipld/js-cid/CID");
    var readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version = "0.0.0-dev";
    var deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports.CID = CID;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cid = require_cid();
    var varint2 = require_varint3();
    var bytes = require_bytes();
    var hasher = require_hasher();
    var digest = require_digest();
    exports.CID = cid.CID;
    exports.varint = varint2;
    exports.bytes = bytes;
    exports.hasher = hasher;
    exports.digest = digest;
  }
});

// ../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/uint8arrays/node_modules/multiformats/cjs/src/basics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var identity = require_identity();
    var base2 = require_base22();
    var base8 = require_base8();
    var base10 = require_base10();
    var base16 = require_base16();
    var base32 = require_base32();
    var base36 = require_base36();
    var base58 = require_base58();
    var base642 = require_base64();
    var base256emoji = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src4();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest = require_digest();
    var varint2 = require_varint3();
    var bytes = require_bytes();
    var bases = {
      ...identity,
      ...base2,
      ...base8,
      ...base10,
      ...base16,
      ...base32,
      ...base36,
      ...base58,
      ...base642,
      ...base256emoji
    };
    var hashes = {
      ...sha2,
      ...identity$1
    };
    var codecs = {
      raw,
      json
    };
    exports.CID = cid.CID;
    exports.hasher = hasher;
    exports.digest = digest;
    exports.varint = varint2;
    exports.bytes = bytes;
    exports.bases = bases;
    exports.codecs = codecs;
    exports.hashes = hashes;
  }
});

// ../../node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function asUint8Array(buf) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      return buf;
    }
    exports.asUint8Array = asUint8Array;
  }
});

// ../../node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/alloc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports.alloc = alloc;
    exports.allocUnsafe = allocUnsafe;
  }
});

// ../../node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/util/bases.js"(exports, module2) {
    "use strict";
    var basics = require_basics();
    var alloc = require_alloc();
    function createCodec(name, prefix, encode6, decode7) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode: encode6
        },
        decoder: { decode: decode7 }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder2 = new TextDecoder("utf8");
      return "u" + decoder2.decode(buf);
    }, (str3) => {
      const encoder = new TextEncoder();
      return encoder.encode(str3.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str3) => {
      str3 = str3.substring(1);
      const buf = alloc.allocUnsafe(str3.length);
      for (let i = 0; i < str3.length; i++) {
        buf[i] = str3.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      utf8: string,
      "utf-8": string,
      hex: basics.bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...basics.bases
    };
    module2.exports = BASES;
  }
});

// ../../node_modules/uint8arrays/cjs/src/to-string.js
var require_to_string = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/to-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bases = require_bases();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
      }
      return base.encoder.encode(array).substring(1);
    }
    exports.toString = toString;
  }
});

// ../../node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/from-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bases = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string, "utf-8"));
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    exports.fromString = fromString;
  }
});

// ../../node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/uint8arrays/cjs/src/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var alloc = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat2(arrays, length2) {
      if (!length2) {
        length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc.allocUnsafe(length2);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports.concat = concat2;
  }
});

// ../../node_modules/multihashes/src/index.js
var require_src5 = __commonJS({
  "../../node_modules/multihashes/src/index.js"(exports, module2) {
    "use strict";
    var multibase = require_src3();
    var varint2 = require_varint();
    var { names } = require_constants2();
    var { toString: uint8ArrayToString } = require_to_string();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var { concat: uint8ArrayConcat } = require_concat();
    var codes = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names) {
      const name = (
        /** @type {HashName} */
        key
      );
      codes[names[name]] = name;
    }
    Object.freeze(codes);
    function toHexString(hash2) {
      if (!(hash2 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash2, "base16");
    }
    function fromHexString(hash2) {
      return uint8ArrayFromString(hash2, "base16");
    }
    function toB58String(hash2) {
      if (!(hash2 instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash2)).slice(1);
    }
    function fromB58String(hash2) {
      const encoded = hash2 instanceof Uint8Array ? uint8ArrayToString(hash2) : hash2;
      return multibase.decode("z" + encoded);
    }
    function decode7(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = (
        /** @type {HashCode} */
        varint2.decode(bytes)
      );
      if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      bytes = bytes.slice(varint2.decode.bytes);
      const len = varint2.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint2.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
      };
    }
    function encode6(digest, code, length2) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code);
      if (!(digest instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length2 == null) {
        length2 = digest.length;
      }
      if (length2 && digest.length !== length2) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash2 = varint2.encode(hashfn);
      const len = varint2.encode(length2);
      return uint8ArrayConcat([hash2, len, digest], hash2.length + len.length + digest.length);
    }
    function coerceCode(name) {
      let code = name;
      if (typeof name === "string") {
        if (names[name] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (codes[code] === void 0 && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    }
    function isAppCode(code) {
      return code > 0 && code < 16;
    }
    function isValidCode(code) {
      if (isAppCode(code)) {
        return true;
      }
      if (codes[code]) {
        return true;
      }
      return false;
    }
    function validate2(multihash) {
      decode7(multihash);
    }
    function prefix(multihash) {
      validate2(multihash);
      return multihash.subarray(0, 2);
    }
    module2.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode7,
      encode: encode6,
      coerceCode,
      isAppCode,
      validate: validate2,
      prefix,
      isValidCode
    };
  }
});

// dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DidDht: () => DidDht,
  DidDhtMethod: () => DidDhtMethod,
  DidIonMethod: () => DidIonMethod,
  DidKeyMethod: () => DidKeyMethod,
  DidResolver: () => DidResolver,
  DidResolverCacheLevel: () => DidResolverCacheLevel,
  DidResolverCacheNoop: () => DidResolverCacheNoop,
  utils: () => utils_exports
});
module.exports = __toCommonJS(esm_exports);

// dist/esm/dht.js
var import_crypto3 = require("@web5/crypto");
var import_common = require("@web5/common");

// ../../node_modules/bittorrent-dht/client.js
var import_events = require("events");

// ../../node_modules/uint8-util/util.js
var alphabet = "0123456789abcdef";
var encodeLookup = [];
var decodeLookup = [];
for (let i = 0; i < 256; i++) {
  encodeLookup[i] = alphabet[i >> 4 & 15] + alphabet[i & 15];
  if (i < 16) {
    if (i < 10) {
      decodeLookup[48 + i] = i;
    } else {
      decodeLookup[97 - 10 + i] = i;
    }
  }
}
var arr2hex = (data) => {
  const length2 = data.length;
  let string = "";
  let i = 0;
  while (i < length2) {
    string += encodeLookup[data[i++]];
  }
  return string;
};
var concat = (chunks, size = 0) => {
  const length2 = chunks.length || 0;
  if (!size) {
    let i2 = length2;
    while (i2--)
      size += chunks[i2].length;
  }
  const b = new Uint8Array(size);
  let offset = size;
  let i = length2;
  while (i--) {
    offset -= chunks[i].length;
    b.set(chunks[i], offset);
  }
  return b;
};

// ../../node_modules/uint8-util/_node.js
var decoder = new TextDecoder();
var arr2text = (data, enc) => {
  if (data.byteLength > 1024) {
    if (!enc)
      return decoder.decode(data);
    const dec = new TextDecoder(enc);
    return dec.decode(data);
  }
  return Buffer.from(data).toString(enc || "utf8");
};
var text2arr = (str3) => new Uint8Array(Buffer.from(str3, "utf8"));

// ../../node_modules/bittorrent-dht/node_modules/bencode/lib/util.js
function digitCount(value) {
  const sign = value < 0 ? 1 : 0;
  value = Math.abs(Number(value || 1));
  return Math.floor(Math.log10(value)) + 1 + sign;
}
function getType(value) {
  if (ArrayBuffer.isView(value))
    return "arraybufferview";
  if (Array.isArray(value))
    return "array";
  if (value instanceof Number)
    return "number";
  if (value instanceof Boolean)
    return "boolean";
  if (value instanceof Set)
    return "set";
  if (value instanceof Map)
    return "map";
  if (value instanceof String)
    return "string";
  if (value instanceof ArrayBuffer)
    return "arraybuffer";
  return typeof value;
}

// ../../node_modules/bittorrent-dht/node_modules/bencode/lib/encode.js
function encode(data, buffer, offset) {
  const buffers = [];
  let result = null;
  encode._encode(buffers, data);
  result = concat(buffers);
  encode.bytes = result.length;
  if (ArrayBuffer.isView(buffer)) {
    buffer.set(result, offset);
    return buffer;
  }
  return result;
}
encode.bytes = -1;
encode._floatConversionDetected = false;
encode._encode = function(buffers, data) {
  if (data == null) {
    return;
  }
  switch (getType(data)) {
    case "object":
      encode.dict(buffers, data);
      break;
    case "map":
      encode.dictMap(buffers, data);
      break;
    case "array":
      encode.list(buffers, data);
      break;
    case "set":
      encode.listSet(buffers, data);
      break;
    case "string":
      encode.string(buffers, data);
      break;
    case "number":
      encode.number(buffers, data);
      break;
    case "boolean":
      encode.number(buffers, data);
      break;
    case "arraybufferview":
      encode.buffer(buffers, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
      break;
    case "arraybuffer":
      encode.buffer(buffers, new Uint8Array(data));
      break;
  }
};
var buffE = new Uint8Array([101]);
var buffD = new Uint8Array([100]);
var buffL = new Uint8Array([108]);
encode.buffer = function(buffers, data) {
  buffers.push(text2arr(data.length + ":"), data);
};
encode.string = function(buffers, data) {
  buffers.push(text2arr(text2arr(data).byteLength + ":" + data));
};
encode.number = function(buffers, data) {
  if (Number.isInteger(data))
    return buffers.push(text2arr("i" + BigInt(data) + "e"));
  const maxLo = 2147483648;
  const hi = data / maxLo << 0;
  const lo = data % maxLo << 0;
  const val = hi * maxLo + lo;
  buffers.push(text2arr("i" + val + "e"));
  if (val !== data && !encode._floatConversionDetected) {
    encode._floatConversionDetected = true;
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    );
    console.trace();
  }
};
encode.dict = function(buffers, data) {
  buffers.push(buffD);
  let j = 0;
  let k;
  const keys = Object.keys(data).sort();
  const kl = keys.length;
  for (; j < kl; j++) {
    k = keys[j];
    if (data[k] == null)
      continue;
    encode.string(buffers, k);
    encode._encode(buffers, data[k]);
  }
  buffers.push(buffE);
};
encode.dictMap = function(buffers, data) {
  buffers.push(buffD);
  const keys = Array.from(data.keys()).sort();
  for (const key of keys) {
    if (data.get(key) == null)
      continue;
    ArrayBuffer.isView(key) ? encode._encode(buffers, key) : encode.string(buffers, String(key));
    encode._encode(buffers, data.get(key));
  }
  buffers.push(buffE);
};
encode.list = function(buffers, data) {
  let i = 0;
  const c = data.length;
  buffers.push(buffL);
  for (; i < c; i++) {
    if (data[i] == null)
      continue;
    encode._encode(buffers, data[i]);
  }
  buffers.push(buffE);
};
encode.listSet = function(buffers, data) {
  buffers.push(buffL);
  for (const item of data) {
    if (item == null)
      continue;
    encode._encode(buffers, item);
  }
  buffers.push(buffE);
};
var encode_default = encode;

// ../../node_modules/bittorrent-dht/node_modules/bencode/lib/decode.js
var INTEGER_START = 105;
var STRING_DELIM = 58;
var DICTIONARY_START = 100;
var LIST_START = 108;
var END_OF_TYPE = 101;
function getIntFromBuffer(buffer, start, end) {
  let sum = 0;
  let sign = 1;
  for (let i = start; i < end; i++) {
    const num = buffer[i];
    if (num < 58 && num >= 48) {
      sum = sum * 10 + (num - 48);
      continue;
    }
    if (i === start && num === 43) {
      continue;
    }
    if (i === start && num === 45) {
      sign = -1;
      continue;
    }
    if (num === 46) {
      break;
    }
    throw new Error("not a number: buffer[" + i + "] = " + num);
  }
  return sum * sign;
}
function decode(data, start, end, encoding) {
  if (data == null || data.length === 0) {
    return null;
  }
  if (typeof start !== "number" && encoding == null) {
    encoding = start;
    start = void 0;
  }
  if (typeof end !== "number" && encoding == null) {
    encoding = end;
    end = void 0;
  }
  decode.position = 0;
  decode.encoding = encoding || null;
  decode.data = !ArrayBuffer.isView(data) ? text2arr(data) : new Uint8Array(data.slice(start, end));
  decode.bytes = decode.data.length;
  return decode.next();
}
decode.bytes = 0;
decode.position = 0;
decode.data = null;
decode.encoding = null;
decode.next = function() {
  switch (decode.data[decode.position]) {
    case DICTIONARY_START:
      return decode.dictionary();
    case LIST_START:
      return decode.list();
    case INTEGER_START:
      return decode.integer();
    default:
      return decode.buffer();
  }
};
decode.find = function(chr) {
  let i = decode.position;
  const c = decode.data.length;
  const d = decode.data;
  while (i < c) {
    if (d[i] === chr)
      return i;
    i++;
  }
  throw new Error(
    'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
  );
};
decode.dictionary = function() {
  decode.position++;
  const dict = {};
  while (decode.data[decode.position] !== END_OF_TYPE) {
    const buffer = decode.buffer();
    let key = arr2text(buffer);
    if (key.includes("\uFFFD"))
      key = arr2hex(buffer);
    dict[key] = decode.next();
  }
  decode.position++;
  return dict;
};
decode.list = function() {
  decode.position++;
  const lst = [];
  while (decode.data[decode.position] !== END_OF_TYPE) {
    lst.push(decode.next());
  }
  decode.position++;
  return lst;
};
decode.integer = function() {
  const end = decode.find(END_OF_TYPE);
  const number = getIntFromBuffer(decode.data, decode.position + 1, end);
  decode.position += end + 1 - decode.position;
  return number;
};
decode.buffer = function() {
  let sep = decode.find(STRING_DELIM);
  const length2 = getIntFromBuffer(decode.data, decode.position, sep);
  const end = ++sep + length2;
  decode.position = end;
  return decode.encoding ? arr2text(decode.data.slice(sep, end)) : decode.data.slice(sep, end);
};
var decode_default = decode;

// ../../node_modules/bittorrent-dht/node_modules/bencode/lib/encoding-length.js
function listLength(list) {
  let length2 = 1 + 1;
  for (const value of list) {
    length2 += encodingLength(value);
  }
  return length2;
}
function mapLength(map) {
  let length2 = 1 + 1;
  for (const [key, value] of map) {
    const keyLength = text2arr(key).byteLength;
    length2 += digitCount(keyLength) + 1 + keyLength;
    length2 += encodingLength(value);
  }
  return length2;
}
function objectLength(value) {
  let length2 = 1 + 1;
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i++) {
    const keyLength = text2arr(keys[i]).byteLength;
    length2 += digitCount(keyLength) + 1 + keyLength;
    length2 += encodingLength(value[keys[i]]);
  }
  return length2;
}
function stringLength(value) {
  const length2 = text2arr(value).byteLength;
  return digitCount(length2) + 1 + length2;
}
function arrayBufferLength(value) {
  const length2 = value.byteLength - value.byteOffset;
  return digitCount(length2) + 1 + length2;
}
function encodingLength(value) {
  const length2 = 0;
  if (value == null)
    return length2;
  const type = getType(value);
  switch (type) {
    case "arraybufferview":
      return arrayBufferLength(value);
    case "string":
      return stringLength(value);
    case "array":
    case "set":
      return listLength(value);
    case "number":
      return 1 + digitCount(Math.floor(value)) + 1;
    case "bigint":
      return 1 + value.toString().length + 1;
    case "object":
      return objectLength(value);
    case "map":
      return mapLength(value);
    default:
      throw new TypeError(`Unsupported value of type "${type}"`);
  }
}
var encoding_length_default = encodingLength;

// ../../node_modules/bittorrent-dht/node_modules/bencode/index.js
var encodingLength2 = encoding_length_default;
var bencode_default = { encode: encode_default, decode: decode_default, byteLength: encoding_length_default, encodingLength: encodingLength2 };

// ../../node_modules/bittorrent-dht/client.js
var import_debug = __toESM(require_src(), 1);
var import_k_bucket = __toESM(require_k_bucket(), 1);
var import_k_rpc = __toESM(require_k_rpc(), 1);
var import_last_one_wins = __toESM(require_last_one_wins(), 1);
var import_lru = __toESM(require_lru(), 1);
var import_randombytes = __toESM(require_randombytes(), 1);
var import_record_cache = __toESM(require_record_cache(), 1);
var import_crypto = __toESM(require("crypto"), 1);
var debug = (0, import_debug.default)("bittorrent-dht");
var ROTATE_INTERVAL = 5 * 60 * 1e3;
var BUCKET_OUTDATED_TIMESPAN = 15 * 60 * 1e3;
var DHT = class extends import_events.EventEmitter {
  constructor(opts = {}) {
    super();
    this._tables = new import_lru.default({ maxAge: ROTATE_INTERVAL, max: opts.maxTables || 1e3 });
    this._values = new import_lru.default(opts.maxValues || 1e3);
    this._peers = (0, import_record_cache.default)({
      maxAge: opts.maxAge || 0,
      maxSize: opts.maxPeers || 1e4
    });
    this._secrets = null;
    this._hash = opts.hash || sha1;
    this._hashLength = this._hash(Buffer.from("")).length;
    this._rpc = opts.krpc || (0, import_k_rpc.default)(Object.assign({ idLength: this._hashLength }, opts));
    this._rpc.on("query", onquery);
    this._rpc.on("node", onnode);
    this._rpc.on("warning", onwarning);
    this._rpc.on("error", onerror);
    this._rpc.on("listening", onlistening);
    this._rotateSecrets();
    this._verify = opts.verify || null;
    this._host = opts.host || null;
    this._interval = setInterval(rotateSecrets, ROTATE_INTERVAL);
    this._runningBucketCheck = false;
    this._bucketCheckTimeout = null;
    this._bucketOutdatedTimeSpan = opts.timeBucketOutdated || BUCKET_OUTDATED_TIMESPAN;
    this.listening = false;
    this.destroyed = false;
    this.nodeId = this._rpc.id;
    this.nodes = this._rpc.nodes;
    const onping = (0, import_last_one_wins.default)(ping);
    this._rpc.on("ping", (older, swap) => {
      onping({ older, swap });
    });
    process.nextTick(bootstrap);
    this._debug("new DHT %s", this.nodeId);
    const self = this;
    function ping(opts2, cb) {
      const older = opts2.older;
      const swap = opts2.swap;
      self._debug("received ping", older);
      self._checkNodes(older, false, (_, deadNode) => {
        if (deadNode) {
          self._debug("swaping dead node with newer", deadNode);
          swap(deadNode);
          return cb();
        }
        self._debug("no node added, all other nodes ok");
        cb();
      });
    }
    function onlistening() {
      self.listening = true;
      self._debug("listening %d", self.address().port);
      self.updateBucketTimestamp();
      self._setBucketCheckInterval();
      self.emit("listening");
    }
    function onquery(query, peer) {
      self._onquery(query, peer);
    }
    function rotateSecrets() {
      self._rotateSecrets();
    }
    function bootstrap() {
      if (!self.destroyed)
        self._bootstrap(opts.bootstrap !== false);
    }
    function onwarning(err3) {
      self.emit("warning", err3);
    }
    function onerror(err3) {
      self.emit("error", err3);
    }
    function onnode(node) {
      self.emit("node", node);
    }
  }
  _setBucketCheckInterval() {
    const self = this;
    const interval = 1 * 60 * 1e3;
    this._runningBucketCheck = true;
    queueNext();
    function checkBucket() {
      const diff = Date.now() - self._rpc.nodes.metadata.lastChange;
      if (diff < self._bucketOutdatedTimeSpan)
        return queueNext();
      self._pingAll(() => {
        if (self.destroyed)
          return;
        if (self.nodes.toArray().length < 1) {
          self._bootstrap(true);
        }
        queueNext();
      });
    }
    function queueNext() {
      if (!self._runningBucketCheck || self.destroyed)
        return;
      const nextTimeout = Math.floor(Math.random() * interval + interval / 2);
      self._bucketCheckTimeout = setTimeout(checkBucket, nextTimeout);
    }
  }
  _pingAll(cb) {
    this._checkAndRemoveNodes(this.nodes.toArray(), cb);
  }
  removeBucketCheckInterval() {
    this._runningBucketCheck = false;
    clearTimeout(this._bucketCheckTimeout);
  }
  updateBucketTimestamp() {
    this._rpc.nodes.metadata.lastChange = Date.now();
  }
  _checkAndRemoveNodes(nodes, cb) {
    const self = this;
    this._checkNodes(nodes, true, (_, node) => {
      if (node)
        self.removeNode(node.id);
      cb(null, node);
    });
  }
  _checkNodes(nodes, force, cb) {
    const self = this;
    test(nodes);
    function test(acc) {
      let current = null;
      while (acc.length) {
        current = acc.pop();
        if (!current.id || force)
          break;
        if (Date.now() - (current.seen || 0) > 1e4)
          break;
        current = null;
      }
      if (!current)
        return cb(null);
      self._sendPing(current, (err3) => {
        if (!err3) {
          self.updateBucketTimestamp();
          return test(acc);
        }
        cb(null, current);
      });
    }
  }
  addNode(node) {
    const self = this;
    if (node.id) {
      node.id = toBuffer(node.id);
      const old = !!this._rpc.nodes.get(node.id);
      this._rpc.nodes.add(node);
      if (!old) {
        this.emit("node", node);
        this.updateBucketTimestamp();
      }
      return;
    }
    this._sendPing(node, (_, node2) => {
      if (node2)
        self.addNode(node2);
    });
  }
  removeNode(id) {
    this._rpc.nodes.remove(toBuffer(id));
  }
  _sendPing(node, cb) {
    const self = this;
    const expectedId = node.id;
    this._rpc.query(node, { q: "ping" }, (err3, pong, node2) => {
      if (err3)
        return cb(err3);
      if (!pong.r || !pong.r.id || !Buffer.isBuffer(pong.r.id) || pong.r.id.length !== self._hashLength) {
        return cb(new Error("Bad reply"));
      }
      if (Buffer.isBuffer(expectedId) && !expectedId.equals(pong.r.id)) {
        return cb(new Error("Unexpected node id"));
      }
      self.updateBucketTimestamp();
      cb(null, {
        id: pong.r.id,
        host: node2.host || node2.address,
        port: node2.port
      });
    });
  }
  toJSON() {
    const self = this;
    const values = {};
    Object.keys(this._values.cache).forEach((key) => {
      const value = self._values.cache[key].value;
      values[key] = {
        v: value.v.toString("hex"),
        id: value.id.toString("hex")
      };
      if (value.seq != null)
        values[key].seq = value.seq;
      if (value.sig != null)
        values[key].sig = value.sig.toString("hex");
      if (value.k != null)
        values[key].k = value.k.toString("hex");
    });
    return {
      nodes: this._rpc.nodes.toArray().map(toNode),
      values
    };
  }
  put(opts, cb) {
    if (Buffer.isBuffer(opts) || typeof opts === "string")
      opts = { v: opts };
    const isMutable = !!opts.k;
    if (opts.v === void 0) {
      throw new Error("opts.v not given");
    }
    if (opts.v.length >= 1e3) {
      throw new Error("v must be less than 1000 bytes in put()");
    }
    if (isMutable && opts.cas !== void 0 && typeof opts.cas !== "number") {
      throw new Error("opts.cas must be an integer if provided");
    }
    if (isMutable && opts.k.length !== 32) {
      throw new Error("opts.k ed25519 public key must be 32 bytes");
    }
    if (isMutable && typeof opts.sign !== "function" && !Buffer.isBuffer(opts.sig)) {
      throw new Error("opts.sign function or options.sig signature is required for mutable put");
    }
    if (isMutable && opts.salt && opts.salt.length > 64) {
      throw new Error("opts.salt is > 64 bytes long");
    }
    if (isMutable && opts.seq === void 0) {
      throw new Error("opts.seq not provided for a mutable update");
    }
    if (isMutable && typeof opts.seq !== "number") {
      throw new Error("opts.seq not an integer");
    }
    return this._put(opts, cb);
  }
  _put(opts, cb) {
    if (!cb)
      cb = noop;
    const isMutable = !!opts.k;
    const v = typeof opts.v === "string" ? Buffer.from(opts.v) : opts.v;
    const key = isMutable ? this._hash(opts.salt ? Buffer.concat([opts.k, opts.salt]) : opts.k) : this._hash(bencode_default.encode(v));
    const table = this._tables.get(key.toString("hex"));
    if (!table)
      return this._preput(key, opts, cb);
    const message = {
      q: "put",
      a: {
        id: this._rpc.id,
        token: null,
        // queryAll sets this
        v
      }
    };
    if (isMutable) {
      if (typeof opts.cas === "number")
        message.a.cas = opts.cas;
      if (opts.salt)
        message.a.salt = opts.salt;
      message.a.k = opts.k;
      message.a.seq = opts.seq;
      if (typeof opts.sign === "function")
        message.a.sig = opts.sign(encodeSigData(message.a));
      else if (Buffer.isBuffer(opts.sig))
        message.a.sig = opts.sig;
    } else {
      this._values.set(key.toString("hex"), message.a);
    }
    this._rpc.queryAll(table.closest(key), message, null, (err3, n) => {
      if (err3)
        return cb(err3, key, n);
      cb(null, key, n);
    });
    return key;
  }
  _preput(key, opts, cb) {
    const self = this;
    this._closest(key, {
      q: "get",
      a: {
        id: this._rpc.id,
        target: key
      }
    }, null, (err3, n) => {
      if (err3)
        return cb(err3);
      self.put(opts, cb);
    });
    return key;
  }
  get(key, opts, cb) {
    key = toBuffer(key);
    if (typeof opts === "function") {
      cb = opts;
      opts = null;
    }
    if (!opts)
      opts = {};
    const verify4 = opts.verify || this._verify;
    const hash2 = this._hash;
    let value = this._values.get(key.toString("hex")) || null;
    if (value && opts.cache !== false) {
      value = createGetResponse(this._rpc.id, null, value);
      return process.nextTick(done);
    }
    this._closest(key, {
      q: "get",
      a: {
        id: this._rpc.id,
        target: key
      }
    }, onreply, done);
    function done(err3) {
      if (err3)
        return cb(err3);
      cb(null, value);
    }
    function onreply(message) {
      const r = message.r;
      if (!r || !r.v)
        return true;
      const isMutable = r.k || r.sig;
      if (opts.salt)
        r.salt = Buffer.from(opts.salt);
      if (isMutable) {
        if (!verify4 || !r.sig || !r.k)
          return true;
        if (!verify4(r.sig, encodeSigData(r), r.k))
          return true;
        if (hash2(r.salt ? Buffer.concat([r.k, r.salt]) : r.k).equals(key)) {
          if (!value || r.seq > value.seq)
            value = r;
        }
      } else {
        if (hash2(bencode_default.encode(r.v)).equals(key)) {
          value = r;
          return false;
        }
      }
      return true;
    }
  }
  announce(infoHash, port, cb) {
    if (typeof port === "function")
      return this.announce(infoHash, 0, port);
    infoHash = toBuffer(infoHash);
    if (!cb)
      cb = noop;
    const table = this._tables.get(infoHash.toString("hex"));
    if (!table)
      return this._preannounce(infoHash, port, cb);
    if (this._host) {
      const dhtPort = this.listening ? this.address().port : 0;
      this._addPeer(
        { host: this._host, port: port || dhtPort },
        infoHash,
        { host: this._host, port: dhtPort }
      );
    }
    const message = {
      q: "announce_peer",
      a: {
        id: this._rpc.id,
        token: null,
        // queryAll sets this
        info_hash: infoHash,
        port,
        implied_port: port ? 0 : 1
      }
    };
    this._debug("announce %s %d", infoHash, port);
    this._rpc.queryAll(table.closest(infoHash), message, null, cb);
  }
  _preannounce(infoHash, port, cb) {
    const self = this;
    this.lookup(infoHash, (err3) => {
      if (self.destroyed)
        return cb(new Error("dht is destroyed"));
      if (err3)
        return cb(err3);
      self.announce(infoHash, port, cb);
    });
  }
  lookup(infoHash, cb) {
    infoHash = toBuffer(infoHash);
    if (!cb)
      cb = noop;
    const self = this;
    let aborted = false;
    this._debug("lookup %s", infoHash);
    process.nextTick(emit);
    this._closest(infoHash, {
      q: "get_peers",
      a: {
        id: this._rpc.id,
        info_hash: infoHash
      }
    }, onreply, cb);
    function emit(values, from3) {
      if (!values)
        values = self._peers.get(infoHash.toString("hex"), 100);
      const peers = decodePeers(values);
      for (let i = 0; i < peers.length; i++) {
        self.emit("peer", peers[i], infoHash, from3 || null);
      }
    }
    function onreply(message, node) {
      if (aborted)
        return false;
      if (message.r.values)
        emit(message.r.values, node);
    }
    return function abort() {
      aborted = true;
    };
  }
  address() {
    return this._rpc.address();
  }
  // listen([port], [address], [onlistening])
  listen(...args) {
    this._rpc.bind(...args);
  }
  destroy(cb) {
    if (this.destroyed) {
      if (cb)
        process.nextTick(cb);
      return;
    }
    this.destroyed = true;
    const self = this;
    clearInterval(this._interval);
    this.removeBucketCheckInterval();
    this._peers.destroy();
    this._debug("destroying");
    this._rpc.destroy(() => {
      self.emit("close");
      if (cb)
        cb();
    });
  }
  _onquery(query, peer) {
    if (query.q === void 0 || query.q === null)
      return;
    const q = query.q.toString();
    this._debug("received %s query from %s:%d", q, peer.address, peer.port);
    if (!query.a)
      return;
    switch (q) {
      case "ping":
        return this._rpc.response(peer, query, { id: this._rpc.id });
      case "find_node":
        return this._onfindnode(query, peer);
      case "get_peers":
        return this._ongetpeers(query, peer);
      case "announce_peer":
        return this._onannouncepeer(query, peer);
      case "get":
        return this._onget(query, peer);
      case "put":
        return this._onput(query, peer);
    }
  }
  _onfindnode(query, peer) {
    const target = query.a.target;
    if (!target)
      return this._rpc.error(peer, query, [203, "`find_node` missing required `a.target` field"]);
    this.emit("find_node", target);
    const nodes = this._rpc.nodes.closest(target);
    this._rpc.response(peer, query, { id: this._rpc.id }, nodes);
  }
  _ongetpeers(query, peer) {
    const host = peer.address || peer.host;
    const infoHash = query.a.info_hash;
    if (!infoHash)
      return this._rpc.error(peer, query, [203, "`get_peers` missing required `a.info_hash` field"]);
    this.emit("get_peers", infoHash);
    const r = { id: this._rpc.id, token: this._generateToken(host) };
    const peers = this._peers.get(infoHash.toString("hex"));
    if (peers.length) {
      r.values = peers;
      this._rpc.response(peer, query, r);
    } else {
      this._rpc.response(peer, query, r, this._rpc.nodes.closest(infoHash));
    }
  }
  _onannouncepeer(query, peer) {
    const host = peer.address || peer.host;
    const port = query.a.implied_port ? peer.port : query.a.port;
    if (!port || typeof port !== "number" || port <= 0 || port > 65535)
      return;
    const infoHash = query.a.info_hash;
    const token = query.a.token;
    if (!infoHash || !token)
      return;
    if (!this._validateToken(host, token)) {
      return this._rpc.error(peer, query, [203, "cannot `announce_peer` with bad token"]);
    }
    this.emit("announce_peer", infoHash, { host, port: peer.port });
    this._addPeer({ host, port }, infoHash, { host, port: peer.port });
    this._rpc.response(peer, query, { id: this._rpc.id });
  }
  _addPeer(peer, infoHash, from3) {
    this._peers.add(infoHash.toString("hex"), encodePeer(peer.host, peer.port));
    this.emit("announce", peer, infoHash, from3);
  }
  _onget(query, peer) {
    const host = peer.address || peer.host;
    const target = query.a.target;
    if (!target)
      return;
    const token = this._generateToken(host);
    const value = this._values.get(target.toString("hex"));
    this.emit("get", target, value);
    if (!value) {
      const nodes = this._rpc.nodes.closest(target);
      this._rpc.response(peer, query, { id: this._rpc.id, token }, nodes);
    } else {
      this._rpc.response(peer, query, createGetResponse(this._rpc.id, token, value));
    }
  }
  _onput(query, peer) {
    const host = peer.address || peer.host;
    const a = query.a;
    if (!a)
      return;
    const v = query.a.v;
    if (!v)
      return;
    const id = query.a.id;
    if (!id)
      return;
    const token = a.token;
    if (!token)
      return;
    if (!this._validateToken(host, token)) {
      return this._rpc.error(peer, query, [203, "cannot `put` with bad token"]);
    }
    if (v.length > 1e3) {
      return this._rpc.error(peer, query, [205, "data payload too large"]);
    }
    const isMutable = !!(a.k || a.sig);
    if (isMutable && !a.k && !a.sig)
      return;
    const key = isMutable ? this._hash(a.salt ? Buffer.concat([a.k, a.salt]) : a.k) : this._hash(bencode_default.encode(v));
    const keyHex = key.toString("hex");
    this.emit("put", key, v);
    if (isMutable) {
      if (!this._verify)
        return this._rpc.error(peer, query, [400, "verification not supported"]);
      if (!this._verify(a.sig, encodeSigData(a), a.k))
        return;
      const prev = this._values.get(keyHex);
      if (prev && typeof a.cas === "number" && prev.seq !== a.cas) {
        return this._rpc.error(peer, query, [301, "CAS mismatch, re-read and try again"]);
      }
      if (prev && typeof prev.seq === "number" && !(a.seq > prev.seq)) {
        return this._rpc.error(peer, query, [302, "sequence number less than current"]);
      }
      this._values.set(keyHex, { v, k: a.k, salt: a.salt, sig: a.sig, seq: a.seq, id });
    } else {
      this._values.set(keyHex, { v, id });
    }
    this._rpc.response(peer, query, { id: this._rpc.id });
  }
  _bootstrap(populate) {
    const self = this;
    if (!populate)
      return process.nextTick(ready);
    this._rpc.populate(self._rpc.id, {
      q: "find_node",
      a: {
        id: self._rpc.id,
        target: self._rpc.id
      }
    }, ready);
    function ready() {
      if (self.ready)
        return;
      self._debug("emit ready");
      self.ready = true;
      self.emit("ready");
    }
  }
  _closest(target, message, onmessage, cb) {
    const self = this;
    const table = new import_k_bucket.default({
      localNodeId: target,
      numberOfNodesPerKBucket: this._rpc.k
    });
    this._rpc.closest(target, message, onreply, done);
    function done(err3, n) {
      if (err3)
        return cb(err3);
      self._tables.set(target.toString("hex"), table);
      self._debug("visited %d nodes", n);
      cb(null, n);
    }
    function onreply(message2, node) {
      if (!message2.r)
        return true;
      if (message2.r.token && message2.r.id && Buffer.isBuffer(message2.r.id) && message2.r.id.length === self._hashLength) {
        self._debug("found node %s (target: %s)", message2.r.id, target);
        table.add({
          id: message2.r.id,
          host: node.host || node.address,
          port: node.port,
          token: message2.r.token
        });
      }
      if (!onmessage)
        return true;
      return onmessage(message2, node);
    }
  }
  _debug() {
    if (!debug.enabled)
      return;
    const args = [].slice.call(arguments);
    args[0] = `[${this.nodeId.toString("hex").substring(0, 7)}] ${args[0]}`;
    for (let i = 1; i < args.length; i++) {
      if (Buffer.isBuffer(args[i]))
        args[i] = args[i].toString("hex");
    }
    debug(...args);
  }
  _validateToken(host, token) {
    const tokenA = this._generateToken(host, this._secrets[0]);
    const tokenB = this._generateToken(host, this._secrets[1]);
    return token.equals(tokenA) || token.equals(tokenB);
  }
  _generateToken(host, secret) {
    if (!secret)
      secret = this._secrets[0];
    return this._hash(Buffer.concat([Buffer.from(host), secret]));
  }
  _rotateSecrets() {
    if (!this._secrets) {
      this._secrets = [(0, import_randombytes.default)(this._hashLength), (0, import_randombytes.default)(this._hashLength)];
    } else {
      this._secrets[1] = this._secrets[0];
      this._secrets[0] = (0, import_randombytes.default)(this._hashLength);
    }
  }
};
function noop() {
}
function sha1(buf) {
  return import_crypto.default.createHash("sha1").update(buf).digest();
}
function createGetResponse(id, token, value) {
  const r = { id, token, v: value.v };
  if (value.sig) {
    r.sig = value.sig;
    r.k = value.k;
    if (typeof value.seq === "number")
      r.seq = value.seq;
  }
  return r;
}
function encodePeer(host, port) {
  const buf = Buffer.allocUnsafe(6);
  const ip = host.split(".");
  for (let i = 0; i < 4; i++)
    buf[i] = parseInt(ip[i] || 0, 10);
  buf.writeUInt16BE(port, 4);
  return buf;
}
function decodePeers(buf) {
  const peers = [];
  try {
    for (let i = 0; i < buf.length; i++) {
      const port = buf[i].readUInt16BE(4);
      if (!port)
        continue;
      peers.push({
        host: parseIp(buf[i], 0),
        port
      });
    }
  } catch (err3) {
  }
  return peers;
}
function parseIp(buf, offset) {
  return `${buf[offset++]}.${buf[offset++]}.${buf[offset++]}.${buf[offset++]}`;
}
function encodeSigData(msg) {
  const ref = { seq: msg.seq || 0, v: msg.v };
  if (msg.salt)
    ref.salt = msg.salt;
  return bencode_default.encode(ref).slice(1, -1);
}
function toNode(node) {
  return {
    host: node.host,
    port: node.port
  };
}
function toBuffer(str3) {
  if (Buffer.isBuffer(str3))
    return str3;
  if (ArrayBuffer.isView(str3))
    return Buffer.from(str3.buffer, str3.byteOffset, str3.byteLength);
  if (typeof str3 === "string")
    return Buffer.from(str3, "hex");
  throw new Error("Pass a buffer or a string");
}
var client_default = DHT;

// ../../node_modules/pkarr/lib/dht.js
var import_sodium_universal2 = __toESM(require("sodium-universal"), 1);
var import_crypto2 = __toESM(require("crypto"), 1);
var import_graceful_goodbye = __toESM(require_graceful_goodbye(), 1);
var import_fs = __toESM(require("fs"), 1);
var import_os = require("os");
var import_path = __toESM(require("path"), 1);

// ../../node_modules/pkarr/lib/tools.js
var import_sodium_universal = __toESM(require("sodium-universal"), 1);

// ../../node_modules/bencode/lib/util.js
function digitCount2(value) {
  const sign = value < 0 ? 1 : 0;
  value = Math.abs(Number(value || 1));
  return Math.floor(Math.log10(value)) + 1 + sign;
}
function getType2(value) {
  if (ArrayBuffer.isView(value))
    return "arraybufferview";
  if (Array.isArray(value))
    return "array";
  if (value instanceof Number)
    return "number";
  if (value instanceof Boolean)
    return "boolean";
  if (value instanceof Set)
    return "set";
  if (value instanceof Map)
    return "map";
  if (value instanceof String)
    return "string";
  if (value instanceof ArrayBuffer)
    return "arraybuffer";
  return typeof value;
}

// ../../node_modules/bencode/lib/encode.js
function encode2(data, buffer, offset) {
  const buffers = [];
  let result = null;
  encode2._encode(buffers, data);
  result = concat(buffers);
  encode2.bytes = result.length;
  if (ArrayBuffer.isView(buffer)) {
    buffer.set(result, offset);
    return buffer;
  }
  return result;
}
encode2.bytes = -1;
encode2._floatConversionDetected = false;
encode2._encode = function(buffers, data) {
  if (data == null) {
    return;
  }
  switch (getType2(data)) {
    case "object":
      encode2.dict(buffers, data);
      break;
    case "map":
      encode2.dictMap(buffers, data);
      break;
    case "array":
      encode2.list(buffers, data);
      break;
    case "set":
      encode2.listSet(buffers, data);
      break;
    case "string":
      encode2.string(buffers, data);
      break;
    case "number":
      encode2.number(buffers, data);
      break;
    case "boolean":
      encode2.number(buffers, data);
      break;
    case "arraybufferview":
      encode2.buffer(buffers, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
      break;
    case "arraybuffer":
      encode2.buffer(buffers, new Uint8Array(data));
      break;
  }
};
var buffE2 = new Uint8Array([101]);
var buffD2 = new Uint8Array([100]);
var buffL2 = new Uint8Array([108]);
encode2.buffer = function(buffers, data) {
  buffers.push(text2arr(data.length + ":"), data);
};
encode2.string = function(buffers, data) {
  buffers.push(text2arr(text2arr(data).byteLength + ":" + data));
};
encode2.number = function(buffers, data) {
  const maxLo = 2147483648;
  const hi = data / maxLo << 0;
  const lo = data % maxLo << 0;
  const val = hi * maxLo + lo;
  buffers.push(text2arr("i" + val + "e"));
  if (val !== data && !encode2._floatConversionDetected) {
    encode2._floatConversionDetected = true;
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    );
    console.trace();
  }
};
encode2.dict = function(buffers, data) {
  buffers.push(buffD2);
  let j = 0;
  let k;
  const keys = Object.keys(data).sort();
  const kl = keys.length;
  for (; j < kl; j++) {
    k = keys[j];
    if (data[k] == null)
      continue;
    encode2.string(buffers, k);
    encode2._encode(buffers, data[k]);
  }
  buffers.push(buffE2);
};
encode2.dictMap = function(buffers, data) {
  buffers.push(buffD2);
  const keys = Array.from(data.keys()).sort();
  for (const key of keys) {
    if (data.get(key) == null)
      continue;
    ArrayBuffer.isView(key) ? encode2._encode(buffers, key) : encode2.string(buffers, String(key));
    encode2._encode(buffers, data.get(key));
  }
  buffers.push(buffE2);
};
encode2.list = function(buffers, data) {
  let i = 0;
  const c = data.length;
  buffers.push(buffL2);
  for (; i < c; i++) {
    if (data[i] == null)
      continue;
    encode2._encode(buffers, data[i]);
  }
  buffers.push(buffE2);
};
encode2.listSet = function(buffers, data) {
  buffers.push(buffL2);
  for (const item of data) {
    if (item == null)
      continue;
    encode2._encode(buffers, item);
  }
  buffers.push(buffE2);
};
var encode_default2 = encode2;

// ../../node_modules/bencode/lib/decode.js
var INTEGER_START2 = 105;
var STRING_DELIM2 = 58;
var DICTIONARY_START2 = 100;
var LIST_START2 = 108;
var END_OF_TYPE2 = 101;
function getIntFromBuffer2(buffer, start, end) {
  let sum = 0;
  let sign = 1;
  for (let i = start; i < end; i++) {
    const num = buffer[i];
    if (num < 58 && num >= 48) {
      sum = sum * 10 + (num - 48);
      continue;
    }
    if (i === start && num === 43) {
      continue;
    }
    if (i === start && num === 45) {
      sign = -1;
      continue;
    }
    if (num === 46) {
      break;
    }
    throw new Error("not a number: buffer[" + i + "] = " + num);
  }
  return sum * sign;
}
function decode2(data, start, end, encoding) {
  if (data == null || data.length === 0) {
    return null;
  }
  if (typeof start !== "number" && encoding == null) {
    encoding = start;
    start = void 0;
  }
  if (typeof end !== "number" && encoding == null) {
    encoding = end;
    end = void 0;
  }
  decode2.position = 0;
  decode2.encoding = encoding || null;
  decode2.data = !ArrayBuffer.isView(data) ? text2arr(data) : new Uint8Array(data.slice(start, end));
  decode2.bytes = decode2.data.length;
  return decode2.next();
}
decode2.bytes = 0;
decode2.position = 0;
decode2.data = null;
decode2.encoding = null;
decode2.next = function() {
  switch (decode2.data[decode2.position]) {
    case DICTIONARY_START2:
      return decode2.dictionary();
    case LIST_START2:
      return decode2.list();
    case INTEGER_START2:
      return decode2.integer();
    default:
      return decode2.buffer();
  }
};
decode2.find = function(chr) {
  let i = decode2.position;
  const c = decode2.data.length;
  const d = decode2.data;
  while (i < c) {
    if (d[i] === chr)
      return i;
    i++;
  }
  throw new Error(
    'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
  );
};
decode2.dictionary = function() {
  decode2.position++;
  const dict = {};
  while (decode2.data[decode2.position] !== END_OF_TYPE2) {
    dict[arr2text(decode2.buffer())] = decode2.next();
  }
  decode2.position++;
  return dict;
};
decode2.list = function() {
  decode2.position++;
  const lst = [];
  while (decode2.data[decode2.position] !== END_OF_TYPE2) {
    lst.push(decode2.next());
  }
  decode2.position++;
  return lst;
};
decode2.integer = function() {
  const end = decode2.find(END_OF_TYPE2);
  const number = getIntFromBuffer2(decode2.data, decode2.position + 1, end);
  decode2.position += end + 1 - decode2.position;
  return number;
};
decode2.buffer = function() {
  let sep = decode2.find(STRING_DELIM2);
  const length2 = getIntFromBuffer2(decode2.data, decode2.position, sep);
  const end = ++sep + length2;
  decode2.position = end;
  return decode2.encoding ? arr2text(decode2.data.slice(sep, end)) : decode2.data.slice(sep, end);
};
var decode_default2 = decode2;

// ../../node_modules/bencode/lib/encoding-length.js
function listLength2(list) {
  let length2 = 1 + 1;
  for (const value of list) {
    length2 += encodingLength3(value);
  }
  return length2;
}
function mapLength2(map) {
  let length2 = 1 + 1;
  for (const [key, value] of map) {
    const keyLength = text2arr(key).byteLength;
    length2 += digitCount2(keyLength) + 1 + keyLength;
    length2 += encodingLength3(value);
  }
  return length2;
}
function objectLength2(value) {
  let length2 = 1 + 1;
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i++) {
    const keyLength = text2arr(keys[i]).byteLength;
    length2 += digitCount2(keyLength) + 1 + keyLength;
    length2 += encodingLength3(value[keys[i]]);
  }
  return length2;
}
function stringLength2(value) {
  const length2 = text2arr(value).byteLength;
  return digitCount2(length2) + 1 + length2;
}
function arrayBufferLength2(value) {
  const length2 = value.byteLength - value.byteOffset;
  return digitCount2(length2) + 1 + length2;
}
function encodingLength3(value) {
  const length2 = 0;
  if (value == null)
    return length2;
  const type = getType2(value);
  switch (type) {
    case "arraybufferview":
      return arrayBufferLength2(value);
    case "string":
      return stringLength2(value);
    case "array":
    case "set":
      return listLength2(value);
    case "number":
      return 1 + digitCount2(Math.floor(value)) + 1;
    case "bigint":
      return 1 + value.toString().length + 1;
    case "object":
      return objectLength2(value);
    case "map":
      return mapLength2(value);
    default:
      throw new TypeError(`Unsupported value of type "${type}"`);
  }
}
var encoding_length_default2 = encodingLength3;

// ../../node_modules/bencode/index.js
var encodingLength4 = encoding_length_default2;
var bencode_default2 = { encode: encode_default2, decode: decode_default2, byteLength: encoding_length_default2, encodingLength: encodingLength4 };

// ../../node_modules/pkarr/lib/tools.js
var import_z32 = __toESM(require("z32"), 1);
var verify = import_sodium_universal.default.crypto_sign_verify_detached;
function randomBytes(n = 32) {
  const buf = Buffer.alloc(n);
  import_sodium_universal.default.randombytes_buf(buf);
  return buf;
}
var encodeSigData2 = (msg) => {
  const ref = { seq: msg.seq || 0, v: msg.v };
  const bencoded = bencode_default2.encode(ref).subarray(1, -1);
  return bencoded;
};
var generateKeyPair = (seed) => {
  const publicKey = Buffer.allocUnsafe(import_sodium_universal.default.crypto_sign_PUBLICKEYBYTES);
  const secretKey = Buffer.allocUnsafe(import_sodium_universal.default.crypto_sign_SECRETKEYBYTES);
  if (seed)
    import_sodium_universal.default.crypto_sign_seed_keypair(publicKey, secretKey, seed);
  else
    import_sodium_universal.default.crypto_sign_keypair(publicKey, secretKey);
  return {
    publicKey,
    secretKey
  };
};
var decodeKey = (url) => {
  if (typeof url !== "string")
    return url;
  const keyBytes = import_z32.default.decode(url.replace("pk:", ""));
  if (keyBytes.byteLength !== 32) {
    throw new Error("Invalid key");
  }
  return keyBytes;
};

// ../../node_modules/pkarr/lib/dht.js
var verify2 = import_sodium_universal2.default.crypto_sign_verify_detached;
var DEFAULT_BOOTSTRAP = [
  "router.magnets.im:6881",
  "router.bittorrent.com:6881",
  "router.utorrent.com:6881",
  "dht.transmissionbt.com:6881",
  "router.nuh.dev:6881"
].map((addr) => {
  const [host, port] = addr.split(":");
  return { host, port: Number(port) };
});
var DEFAULT_STORAGE_LOCATION = import_path.default.join((0, import_os.homedir)(), ".config", "pkarr");
var DHT2 = class {
  /**
   * @param {object} [options]
   * @param {{host:string, port:number}[]} [options.bootstrap] - List of bootstrap nodes. example [{host: "router.utorrent.com", port: 6881}]
   * @param {Storage} [options.storage]
   * @param {string} [options.storageLocation] - location to store bootstrap nodes at
   */
  constructor(options = {}) {
    const _storage = options.storage || new Storage(options.storageLocation);
    options.bootstrap = options.bootstrap || DEFAULT_BOOTSTRAP;
    this._dht = new client_default(options);
    _storage?.loadRoutingTable(this._dht);
    (0, import_graceful_goodbye.default)(() => {
      _storage?.saveRoutingTable(this._dht);
      this.destroy();
    });
  }
  /**
   * Reguest a mutable value from the DHT.
   *
   * @param {Uint8Array} key
   * @param {object} [options]
   * @param {boolean} [options.fullLookup] - If true, will perform a full lookup, otherwise return the first valid result.
   *
   * @returns {Promise<{
   *  id: Uint8Array,
   *  k: Uint8Array,
   *  seq: number,
   *  v: Uint8Array,
   *  sig: Uint8Array,
   *  nodes?: Array<{ host: string, port: number, client?: string }>
   * }>}
   */
  async get(key, options = {}) {
    const target = hash(key);
    const targetHex = target.toString("hex");
    let value = this._dht._values.get(targetHex) || null;
    const nodes = [];
    return new Promise((resolve, reject) => {
      if (value) {
        value = createGetResponse2(this._dht._rpc.id, value);
        return process.nextTick(done);
      }
      this._dht._closest(
        target,
        {
          q: "get",
          a: {
            id: this._dht._rpc.id,
            target
          }
        },
        onreply,
        done
      );
      function done(err3) {
        if (err3)
          reject(err3);
        else
          resolve(value && { ...value, nodes });
      }
      function onreply(message, from3) {
        const r = message.r;
        if (!r.sig || !r.k)
          return true;
        const msg = encodeSigData2(r);
        if (!verify2(r.sig, msg, r.k))
          return true;
        if (hash(r.k).equals(target)) {
          if (!value || r.seq >= value.seq) {
            nodes.push({
              host: from3.host || from3.address,
              port: from3.port,
              client: message.v?.toString().slice(0, 2)
            });
            value = r;
            if (!options.fullLookup) {
              resolve({ ...value, nodes });
            }
          }
        }
        return true;
      }
    });
  }
  /**
   * @param  {object} args
   * @param  {Uint8Array} args.k
   * @param  {Uint8Array} args.v
   * @param  {Uint8Array} args.sig
   * @param  {number} args.seq
   *
   * @returns {Promise<{
   *  target: Uint8Array,
   *  nodes: Array<{ id: Uint8Array, host: string, port: number }>
   * }>}
   */
  async put(args) {
    const key = args.k;
    validate(key, args);
    const target = hash(key);
    let closestNodes = this._dht._tables.get(target.toString("hex"))?.closest(target);
    if (!closestNodes) {
      await new Promise((resolve, reject) => {
        this._dht._closest(
          target,
          {
            q: "get",
            a: {
              id: this._dht._rpc.id,
              target
            }
          },
          null,
          /**
           * @param {Error} [err]
           * @param {number} [n]
           */
          (err3, n) => {
            if (err3)
              reject(err3);
            else
              resolve(n);
          }
        );
      });
      closestNodes = this._dht._tables.get(target.toString("hex"))?.closest(target);
    }
    const message = {
      q: "put",
      a: {
        id: this._dht._rpc.id,
        token: null,
        // queryAll sets this
        v: args.v,
        k: key,
        seq: args.seq,
        sig: args.sig
      }
    };
    return new Promise((resolve, reject) => {
      this._dht._rpc.queryAll(
        closestNodes,
        message,
        null,
        /**
         * @param {Error} [err]
         * @param {number} [_n]
         */
        (err3, _n) => {
          if (err3)
            reject(err3);
          else
            resolve({ target, nodes: closestNodes });
        }
      );
    });
  }
  destroy() {
    return new Promise((resolve, reject) => {
      try {
        this._dht.destroy(resolve);
      } catch (error) {
        reject(error);
      }
    });
  }
};
function validate(key, request) {
  if (request.v === void 0) {
    throw new Error("request.v not given");
  }
  if (request.v.length >= 1e3) {
    throw new Error("v must be less than 1000 bytes in put()");
  }
  if (key.length !== 32) {
    throw new Error("key ed25519 public key must be 32 bytes");
  }
  if (!Buffer.isBuffer(request.sig)) {
    throw new Error("request.sig signature is required for mutable put");
  }
  if (request.seq === void 0) {
    throw new Error("request.seq not provided for a mutable update");
  }
  if (typeof request.seq !== "number") {
    throw new Error("request.seq not an integer");
  }
  if (!verify2(request.sig, encodeSigData2(request), key)) {
    throw new Error("invalid signature");
  }
}
function hash(input) {
  return import_crypto2.default.createHash("sha1").update(input).digest();
}
function createGetResponse2(id, value, nodes) {
  return {
    id,
    v: value.v,
    sig: value.sig,
    k: value.k,
    seq: value.seq,
    nodes
  };
}
var Storage = class {
  /**
   * @param {string} location
   */
  constructor(location) {
    this._location = location || DEFAULT_STORAGE_LOCATION;
    this._loaded = [];
  }
  /**
   * @param {_DHT} dht
   */
  loadRoutingTable(dht) {
    const filepath = import_path.default.join(this._location, "routing-table.json");
    try {
      const data = import_fs.default.readFileSync(filepath);
      const string = data.toString();
      const nodes = JSON.parse(string);
      for (const node of nodes) {
        dht.addNode(node);
      }
    } catch (error) {
      if (error.code !== "ENOENT")
        throw error;
    }
  }
  /**
   * @param {_DHT} dht
   */
  saveRoutingTable(dht) {
    const filePath = import_path.default.join(this._location, "routing-table.json");
    const nodes = dht.toJSON().nodes;
    const json = JSON.stringify(nodes);
    try {
      import_fs.default.writeFileSync(filePath, json);
    } catch (error) {
      if (error.code !== "ENOENT")
        throw error;
      import_fs.default.mkdirSync(this._location);
      import_fs.default.writeFileSync(filePath, json);
    }
  }
};
var dht_default = DHT2;

// ../../node_modules/pkarr/index.js
var import_z323 = __toESM(require("z32"), 1);
var import_dns_packet2 = __toESM(require("dns-packet"), 1);

// ../../node_modules/pkarr/lib/signed_packet.js
var import_z322 = __toESM(require("z32"), 1);
var import_dns_packet = __toESM(require("dns-packet"), 1);
var import_sodium_universal3 = __toESM(require("sodium-universal"), 1);
var verify3 = import_sodium_universal3.default.crypto_sign_verify_detached;
var SignedPacket = class _SignedPacket {
  /** @type {Uint8Array} */
  #publicKey;
  /** @type {Packet} */
  #packet;
  /** @type {Uint8Array} */
  #bytes;
  /** @type {number} */
  #timestamp;
  /**
   * Creates a new SignedPacket from a Keypair and a DNS Packet.
   *
   * It will also normalize the names of the ResourceRecords to be relative to the origin, which would be the zbase32 encoded PublicKey of the Keypair used to sign the Packet.
   *
   * @param {Keypair} keypair
   * @param {Packet} packet
   *
   * @param {object} [options] - Optional arguments mostly useful for unit testing
   * @param {object} [options.timestamp] - timestamp in microseconds
   *
   * @returns {SignedPacket}
   */
  static fromPacket(keypair, packet, options = {}) {
    const origin = import_z322.default.encode(keypair.publicKey);
    packet.answers = packet.answers.map((answer) => {
      answer.name = normalizeName(origin, answer.name);
      return answer;
    });
    const signedPacket = new _SignedPacket();
    signedPacket.#packet = packet;
    const timestamp = Math.ceil(options.timestamp || Date.now() * 1e3);
    const encodedPacket = import_dns_packet.default.encode(packet);
    const signable = encodeSigData2({ seq: timestamp, v: encodedPacket });
    const signature = Buffer.alloc(import_sodium_universal3.default.crypto_sign_BYTES);
    import_sodium_universal3.default.crypto_sign_detached(signature, signable, keypair.secretKey);
    signedPacket.#timestamp = timestamp;
    signedPacket.#publicKey = keypair.publicKey;
    const bytes = Buffer.alloc(encodedPacket.length + 72);
    bytes.set(signature);
    bytes.writeBigUInt64BE(BigInt(timestamp), 64);
    bytes.set(encodedPacket, 72);
    signedPacket.#bytes = bytes;
    return signedPacket;
  }
  /**
   * Creates a new [SignedPacket] from a [PublicKey] and the concatenated 64 bytes Signature,
   * 8 bytes timestamp and encoded [Packet] as defined in the [relays](https://github.com/Nuhvi/pkarr/blob/main/design/relays.md) spec.
   *
   * @param {Uint8Array} publicKey
   * @param {Uint8Array} bytes
   */
  static fromBytes(publicKey, bytes) {
    const buffer = Buffer.from(bytes);
    if (buffer.length < 72) {
      throw new Error(`Invalid SignedPacket bytes length, expected at least 72 bytes but got: ${buffer.length}`);
    }
    if (buffer.length > 1072) {
      throw new Error(`Encoded and compressed DNS Packet is too large, expected max 1000 bytes but got: ${buffer.length}`);
    }
    const seq = Number(buffer.readBigUInt64BE(64));
    const v = buffer.subarray(72);
    const sig = buffer.subarray(0, 64);
    return _SignedPacket.fromBep44Args({
      k: publicKey,
      seq,
      v,
      sig
    });
  }
  /**
   * @param {Bep44Args} args
   */
  static fromBep44Args(args) {
    const publicKey = args.k;
    const signature = args.sig;
    const encodedPacket = Buffer.from(args.v);
    const timestamp = args.seq;
    const signable = encodeSigData2({ seq: timestamp, v: encodedPacket });
    const valid = verify3(signature, signable, publicKey);
    if (!valid) {
      throw Error("Invalid signature");
    }
    const packet = import_dns_packet.default.decode(encodedPacket);
    const signedPacket = new _SignedPacket();
    signedPacket.#publicKey = publicKey;
    signedPacket.#packet = packet;
    signedPacket.#timestamp = timestamp;
    const buffer = Buffer.alloc(args.v.length + 72);
    buffer.set(signature);
    buffer.writeBigUInt64BE(BigInt(timestamp), 64);
    buffer.set(encodedPacket, 72);
    signedPacket.#bytes = buffer;
    return signedPacket;
  }
  /**
   * Returns a list of resource records with the target `name`.
   * `name` can be not normalized, for example `@` or `subdomain.`.
   *
   * @param {string} name
   */
  resourceRecords(name) {
    const origin = import_z322.default.encode(this.publicKey());
    const normalizedName = normalizeName(origin, name);
    return this.packet().answers.filter((rr) => rr.name === normalizedName);
  }
  /**
   * Returns the publicKey singing this packet
   *
   * @returns{Uint8Array}
   * */
  publicKey() {
    return this.#publicKey;
  }
  /**
   * Returns the DNS packet
   *
   * @returns{Packet}
   * */
  packet() {
    return this.#packet;
  }
  /**
   * Returns the timestamp of the creation of the signed packet
   *
   * @returns {number}
   */
  timestamp() {
    return this.#timestamp;
  }
  /**
   * Returns the signature over the encoded DNS packet and timestamp as defined by BEP44
   *
   * @returns{Uint8Array}
   * */
  signature() {
    return this.#bytes.subarray(0, 64);
  }
  /**
   * Returns the encoded signature, timestamp and packet as defined in the [relays](https://github.com/Nuhvi/pkarr/blob/main/design/relays.md) spec.
   *
   * @returns {Uint8Array}
   */
  bytes() {
    return this.#bytes;
  }
  /**
   * Returns BEP0044 arguments { seq, v, sig }
   *
   * @returns {Bep44Args}
   */
  bep44Args() {
    return {
      k: this.publicKey(),
      seq: this.timestamp(),
      sig: this.signature(),
      v: this.#bytes.subarray(72)
    };
  }
  /**
   * Returns the size of the encoded packet
   */
  size() {
    return this.#bytes.length - 72;
  }
};
function normalizeName(origin, name) {
  if (name.endsWith(".")) {
    name = name.slice(0, -1);
  }
  ;
  const parts = name.split(".");
  const last = parts[parts.length - 1];
  if (last === origin) {
    return name;
  } else if (last === "@" || last.length === 0) {
    return origin;
  }
  return name.concat(".").concat(origin);
}

// ../../node_modules/pkarr/index.js
var SignedPacket2 = SignedPacket;
var z323 = import_z323.default;
var Pkarr = class {
  static generateKeyPair = generateKeyPair;
  static generateSeed = randomBytes;
  /**
   * Publishes a signed packet using relay. returns the Fetch response.
   *
   * @param {string} relay - Relay url
   * @param {SignedPacket} signedPacket
   */
  static async relayPut(relay, signedPacket) {
    const id = z323.encode(signedPacket.publicKey());
    const url = relay.replace(/\/+$/, "") + "/" + id;
    return fetch(
      url,
      { method: "PUT", body: signedPacket.bytes() }
    );
  }
  /**
   * Publishes a signed packet using relay. returns the Fetch response.
   *
   * @param {string} relay - Relay url
   * @param {Uint8Array} publicKey
   */
  static async relayGet(relay, publicKey) {
    const id = z323.encode(publicKey);
    const url = relay.replace(/\/+$/, "") + "/" + id;
    const response = await fetch(url);
    const bytes = Buffer.from(await response.arrayBuffer());
    return SignedPacket2.fromBytes(publicKey, bytes);
  }
  /**
   * Publishes a signed packet to the DHT.
   * Throws an error in browser environment.
   *
   * @param {SignedPacket} signedPacket
   *
   * @returns {Promise<boolean>}
   */
  static async publish(signedPacket) {
    const dht = new dht_default();
    return dht.put(signedPacket.bep44Args()).then(() => true).catch(() => false).finally(() => dht.destroy());
  }
  /**
   * Resolves a signed packet from the DHT.
   * Throws an error in browser environment.
   *
   * @param {Uint8Array | string} key
   * @param {object} [options]
   * @param {boolean} [options.fullLookup=false] - perform a full lookup through the DHT, defaults to false, meaning it will return the first result it finds
   *
   * @throws {Error<'Invalid key'>}
   * @returns {Promise<{signedPacket: SignedPacket, nodes: {host: string, port: number}[]} | null>}
   */
  static async resolve(key, options = {}) {
    const dht = new dht_default();
    try {
      const result = await dht.get(decodeKey(key), options).finally(() => dht.destroy());
      if (!result)
        return null;
      return {
        signedPacket: SignedPacket2.fromBep44Args(result),
        nodes: result.nodes
      };
    } catch (error) {
      dht.destroy();
      throw error;
    }
  }
};

// dist/esm/dht.js
var import_dns_packet3 = require("dns-packet");
var __awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var PKARR_RELAY = "https://diddht.tbddev.org";
var TTL = 7200;
var DidDht = class _DidDht {
  /**
   * Parses a DNS packet into a DID Document.
   * @param did The DID of the document.
   * @param packet A DNS packet to parse into a DID Document.
   * @returns A Promise that resolves to the parsed DidDocument.
   */
  static fromDnsPacket({ did, packet }) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
      const document2 = {
        id: did
      };
      const keyLookup = /* @__PURE__ */ new Map();
      for (const answer of packet.answers) {
        if (answer.type !== "TXT")
          continue;
        const dataStr = (_a = answer.data) === null || _a === void 0 ? void 0 : _a.toString();
        const recordType = (_b = answer.name) === null || _b === void 0 ? void 0 : _b.split(".")[0].substring(1, 2);
        switch (recordType) {
          case "k": {
            const { id, t, k } = _DidDht.parseTxtData({ data: dataStr });
            const keyConfigurations = {
              "0": {
                crv: "Ed25519",
                kty: "OKP",
                alg: "EdDSA"
              },
              "1": {
                crv: "secp256k1",
                kty: "EC",
                alg: "ES256K"
              }
            };
            const keyConfig = keyConfigurations[t];
            if (!keyConfig) {
              throw new Error("Unsupported key type");
            }
            const publicKeyJwk = yield import_crypto3.Jose.keyToJwk(Object.assign(Object.assign({}, keyConfig), { kid: id, keyMaterial: import_common.Convert.base64Url(k).toUint8Array(), keyType: "public" }));
            if (!document2.verificationMethod) {
              document2.verificationMethod = [];
            }
            document2.verificationMethod.push({
              id: `${did}#${id}`,
              type: "JsonWebKey2020",
              controller: did,
              publicKeyJwk
            });
            keyLookup.set(answer.name, id);
            break;
          }
          case "s": {
            const { id: sId, t: sType, uri } = _DidDht.parseTxtData({ data: dataStr });
            if (!document2.service) {
              document2.service = [];
            }
            document2.service.push({
              id: `${did}#${sId}`,
              type: sType,
              serviceEndpoint: uri
            });
            break;
          }
        }
      }
      const didSuffix = did.split("did:dht:")[1];
      const potentialRootNames = ["_did", `_did.${didSuffix}`];
      let actualRootName = null;
      const root = packet.answers.filter((answer) => {
        if (potentialRootNames.includes(answer.name)) {
          actualRootName = answer.name;
          return true;
        }
        return false;
      });
      if (root.length === 0) {
        throw new Error("No root record found");
      }
      if (root.length > 1) {
        throw new Error("Multiple root records found");
      }
      const singleRoot = root[0];
      const rootRecord = (_c = singleRoot.data) === null || _c === void 0 ? void 0 : _c.toString().split(";");
      rootRecord === null || rootRecord === void 0 ? void 0 : rootRecord.forEach((record) => {
        const [type, ids] = record.split("=");
        let idList = ids === null || ids === void 0 ? void 0 : ids.split(",").map((id) => `#${keyLookup.get(`_${id}.${actualRootName}`)}`);
        switch (type) {
          case "auth":
            document2.authentication = idList;
            break;
          case "asm":
            document2.assertionMethod = idList;
            break;
          case "agm":
            document2.keyAgreement = idList;
            break;
          case "inv":
            document2.capabilityInvocation = idList;
            break;
          case "del":
            document2.capabilityDelegation = idList;
            break;
        }
      });
      return document2;
    });
  }
  /**
   * Retrieves a DID Document from the DHT.
   *
   * @param did The DID of the document to retrieve.
   * @param relay The relay to use to retrieve the document; defaults to `PKARR_RELAY`.
   * @returns A Promise that resolves to the retrieved DidDocument.
   */
  static getDidDocument({ did, relay = PKARR_RELAY }) {
    return __awaiter(this, void 0, void 0, function* () {
      const didFragment = did.replace("did:dht:", "");
      const publicKeyBytes = new Uint8Array(z323.decode(didFragment));
      const resolved = yield Pkarr.relayGet(relay, publicKeyBytes);
      if (resolved) {
        return yield _DidDht.fromDnsPacket({ did, packet: resolved.packet() });
      }
      throw new Error("No packet found");
    });
  }
  /**
   * Publishes a DID Document to the DHT.
   *
   * @param keyPair The key pair to sign the document with.
   * @param didDocument The DID Document to publish.
   * @param relay The relay to use to retrieve the document; defaults to `PKARR_RELAY`.
   * @returns A boolean indicating the success of the publishing operation.
   */
  static publishDidDocument({ keyPair, didDocument, relay = PKARR_RELAY }) {
    return __awaiter(this, void 0, void 0, function* () {
      const packet = yield _DidDht.toDnsPacket({ didDocument });
      const pkarrKeypair = {
        publicKey: keyPair.publicKey.material,
        secretKey: new Uint8Array([...keyPair.privateKey.material, ...keyPair.publicKey.material])
      };
      const signedPacket = SignedPacket2.fromPacket(pkarrKeypair, packet);
      const results = yield Pkarr.relayPut(relay, signedPacket);
      return results.ok;
    });
  }
  /**
   * Converts a DID Document to a DNS packet according to the did:dht spec.
   *
   * @param didDocument The DID Document to convert.
   * @returns A DNS packet converted from the DID Document.
   */
  static toDnsPacket({ didDocument }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const packet = {
        id: 0,
        type: "response",
        flags: import_dns_packet3.AUTHORITATIVE_ANSWER,
        answers: []
      };
      const vmIds = [];
      const svcIds = [];
      const rootRecord = [];
      const keyLookup = /* @__PURE__ */ new Map();
      for (const vm of didDocument.verificationMethod) {
        const index = didDocument.verificationMethod.indexOf(vm);
        const recordIdentifier = `k${index}`;
        let vmId = _DidDht.identifierFragment({ identifier: vm.id });
        keyLookup.set(vmId, recordIdentifier);
        let keyType;
        switch (vm.publicKeyJwk.alg) {
          case "EdDSA":
            keyType = 0;
            break;
          case "ES256K":
            keyType = 1;
            break;
          default:
            keyType = 0;
        }
        const cryptoKey = yield import_crypto3.Jose.jwkToCryptoKey({ key: vm.publicKeyJwk });
        const keyBase64Url = import_common.Convert.uint8Array(cryptoKey.material).toBase64Url();
        const keyRecord = {
          type: "TXT",
          name: `_${recordIdentifier}._did`,
          ttl: TTL,
          data: `id=${vmId},t=${keyType},k=${keyBase64Url}`
        };
        packet.answers.push(keyRecord);
        vmIds.push(recordIdentifier);
      }
      (_a = didDocument.service) === null || _a === void 0 ? void 0 : _a.forEach((service, index) => {
        const recordIdentifier = `s${index}`;
        let sId = _DidDht.identifierFragment({ identifier: service.id });
        const serviceRecord = {
          type: "TXT",
          name: `_${recordIdentifier}._did`,
          ttl: TTL,
          data: `id=${sId},t=${service.type},uri=${service.serviceEndpoint}`
        };
        packet.answers.push(serviceRecord);
        svcIds.push(recordIdentifier);
      });
      if (vmIds.length) {
        rootRecord.push(`vm=${vmIds.join(",")}`);
      }
      if (svcIds.length) {
        rootRecord.push(`svc=${svcIds.join(",")}`);
      }
      if (didDocument.authentication) {
        const authIds = didDocument.authentication.map((id) => _DidDht.identifierFragment({ identifier: id })).filter((id) => keyLookup.has(id)).map((id) => keyLookup.get(id));
        if (authIds.length) {
          rootRecord.push(`auth=${authIds.join(",")}`);
        }
      }
      if (didDocument.assertionMethod) {
        const authIds = didDocument.assertionMethod.map((id) => _DidDht.identifierFragment({ identifier: id })).filter((id) => keyLookup.has(id)).map((id) => keyLookup.get(id));
        if (authIds.length) {
          rootRecord.push(`asm=${authIds.join(",")}`);
        }
      }
      if (didDocument.keyAgreement) {
        const authIds = didDocument.keyAgreement.map((id) => _DidDht.identifierFragment({ identifier: id })).filter((id) => keyLookup.has(id)).map((id) => keyLookup.get(id));
        if (authIds.length) {
          rootRecord.push(`agm=${authIds.join(",")}`);
        }
      }
      if (didDocument.capabilityInvocation) {
        const authIds = didDocument.capabilityInvocation.map((id) => _DidDht.identifierFragment({ identifier: id })).filter((id) => keyLookup.has(id)).map((id) => keyLookup.get(id));
        if (authIds.length) {
          rootRecord.push(`inv=${authIds.join(",")}`);
        }
      }
      if (didDocument.capabilityDelegation) {
        const authIds = didDocument.capabilityDelegation.map((id) => _DidDht.identifierFragment({ identifier: id })).filter((id) => keyLookup.has(id)).map((id) => keyLookup.get(id));
        if (authIds.length) {
          rootRecord.push(`del=${authIds.join(",")}`);
        }
      }
      packet.answers.push({
        type: "TXT",
        name: "_did",
        ttl: TTL,
        data: rootRecord.join(";")
      });
      return packet;
    });
  }
  /**
   * Extracts the fragment from a DID.
   *
   * @param identifier The DID to extract the fragment from.
   * @returns The fragment from the DID or the complete DID if no fragment exists.
   */
  static identifierFragment({ identifier }) {
    return identifier.includes("#") ? identifier.substring(identifier.indexOf("#") + 1) : identifier;
  }
  /**
   * Parses TXT data from a DNS answer to extract key or service information.
   *
   * @param data The TXT record string data containing key-value pairs separated by commas.
   * @returns An object containing parsed attributes such as 'id', 't', 'k', and 'uri'.
  */
  static parseTxtData({ data }) {
    return data.split(",").reduce((acc, pair) => {
      const [key, value] = pair.split("=");
      acc[key] = value;
      return acc;
    }, {});
  }
};

// dist/esm/did-dht.js
var import_z324 = __toESM(require("z32"), 1);
var import_crypto4 = require("@web5/crypto");

// dist/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  DID_REGEX: () => DID_REGEX,
  getServices: () => getServices,
  getVerificationMethodIds: () => getVerificationMethodIds,
  getVerificationMethodTypes: () => getVerificationMethodTypes,
  isDwnServiceEndpoint: () => isDwnServiceEndpoint,
  parseDid: () => parseDid
});
var import_did_resolver = require("did-resolver");
var DID_REGEX = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\/[^#?]*)?([?][^#]*)?(#.*)?$/;
function getServices(options) {
  var _a, _b;
  const { didDocument, id, type } = options !== null && options !== void 0 ? options : {};
  return (_b = (_a = didDocument === null || didDocument === void 0 ? void 0 : didDocument.service) === null || _a === void 0 ? void 0 : _a.filter((service) => {
    if (id && service.id !== id)
      return false;
    if (type && service.type !== type)
      return false;
    return true;
  })) !== null && _b !== void 0 ? _b : [];
}
function getVerificationMethodIds(options) {
  const { didDocument, publicKeyJwk, publicKeyMultibase } = options;
  if (!didDocument)
    throw new Error(`Required parameter missing: 'didDocument'`);
  if (!didDocument.verificationMethod)
    throw new Error("Given `didDocument` is missing `verificationMethod` entries.");
  for (let method of didDocument.verificationMethod) {
    if (publicKeyMultibase && "publicKeyMultibase" in method) {
      if (publicKeyMultibase === method.publicKeyMultibase) {
        return method.id;
      }
    } else if (publicKeyJwk && "crv" in publicKeyJwk && "publicKeyJwk" in method && "crv" in method.publicKeyJwk) {
      if (publicKeyJwk.crv === method.publicKeyJwk.crv && publicKeyJwk.x === method.publicKeyJwk.x) {
        return method.id;
      }
    }
  }
}
function getVerificationMethodTypes(options) {
  const { didDocument } = options;
  let types = [];
  for (let key in didDocument) {
    if (typeof didDocument[key] === "object") {
      types = types.concat(getVerificationMethodTypes({
        didDocument: didDocument[key]
      }));
    } else if (key === "type") {
      types.push(didDocument[key]);
    }
  }
  return [...new Set(types)];
}
function isDwnServiceEndpoint(endpoint) {
  return endpoint !== void 0 && typeof endpoint !== "string" && !Array.isArray(endpoint) && "nodes" in endpoint && "signingKeys" in endpoint;
}
function parseDid({ didUrl }) {
  const parsedDid = (0, import_did_resolver.parse)(didUrl);
  return parsedDid;
}

// dist/esm/did-dht.js
var __awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidDhtMethod = class {
  /**
   * Creates a new DID Document according to the did:dht spec.
   * @param options The options to use when creating the DID Document, including whether to publish it.
   * @returns A promise that resolves to a PortableDid object.
   */
  static create(options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { publish, keySet: initialKeySet, services } = options !== null && options !== void 0 ? options : {};
      const keySet = yield this.generateKeySet({ keySet: initialKeySet });
      const id = yield this.getDidIdentifier({ key: keySet.identityKey.publicKeyJwk });
      const relationshipsMap = {};
      const verificationMethods = keySet.verificationMethodKeys.map((key) => {
        for (const relationship of key.relationships) {
          if (relationshipsMap[relationship]) {
            relationshipsMap[relationship].push(`#${key.publicKeyJwk.kid}`);
          } else {
            relationshipsMap[relationship] = [`#${key.publicKeyJwk.kid}`];
          }
        }
        return {
          id: `${id}#${key.publicKeyJwk.kid}`,
          type: "JsonWebKey2020",
          controller: id,
          publicKeyJwk: key.publicKeyJwk
        };
      });
      services === null || services === void 0 ? void 0 : services.map((service) => {
        service.id = `${id}#${service.id}`;
      });
      const document2 = Object.assign(Object.assign({ id, verificationMethod: [...verificationMethods] }, relationshipsMap), services && { service: services });
      if (publish) {
        yield this.publish({ keySet, didDocument: document2 });
      }
      return {
        did: document2.id,
        document: document2,
        keySet
      };
    });
  }
  /**
   * Generates a JWK key pair.
   * @param options The key algorithm and key ID to use.
   * @returns A promise that resolves to a JwkKeyPair object.
   */
  static generateJwkKeyPair(options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { keyAlgorithm, keyId } = options;
      let cryptoKeyPair;
      switch (keyAlgorithm) {
        case "Ed25519": {
          cryptoKeyPair = yield new import_crypto4.EdDsaAlgorithm().generateKey({
            algorithm: { name: "EdDSA", namedCurve: "Ed25519" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        case "secp256k1": {
          cryptoKeyPair = yield new import_crypto4.EcdsaAlgorithm().generateKey({
            algorithm: { name: "ECDSA", namedCurve: "secp256k1" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        default: {
          throw new Error(`Unsupported crypto algorithm: '${keyAlgorithm}'`);
        }
      }
      const jwkKeyPair = yield import_crypto4.Jose.cryptoKeyToJwkPair({ keyPair: cryptoKeyPair });
      if (keyId) {
        jwkKeyPair.privateKeyJwk.kid = keyId;
        jwkKeyPair.publicKeyJwk.kid = keyId;
      } else {
        const jwkThumbprint = yield import_crypto4.Jose.jwkThumbprint({ key: jwkKeyPair.publicKeyJwk });
        jwkKeyPair.privateKeyJwk.kid = jwkThumbprint;
        jwkKeyPair.publicKeyJwk.kid = jwkThumbprint;
      }
      return jwkKeyPair;
    });
  }
  /**
   * Generates a key set for a DID Document.
   * @param options The key set to use when generating the key set.
   * @returns A promise that resolves to a DidDhtKeySet object.
   */
  static generateKeySet(options) {
    var _a, _b;
    var _c, _d;
    return __awaiter2(this, void 0, void 0, function* () {
      let { keySet = {} } = options !== null && options !== void 0 ? options : {};
      if (!keySet.identityKey) {
        keySet.identityKey = yield this.generateJwkKeyPair({
          keyAlgorithm: "Ed25519",
          keyId: "0"
        });
      } else if (keySet.identityKey.publicKeyJwk.kid !== "0") {
        throw new Error("The identity key must have a kid of 0");
      }
      const identityKeySetVerificationMethod = Object.assign(Object.assign({}, keySet.identityKey), { relationships: ["authentication", "assertionMethod", "capabilityInvocation", "capabilityDelegation"] });
      if (!keySet.verificationMethodKeys) {
        keySet.verificationMethodKeys = [identityKeySetVerificationMethod];
      } else if (keySet.verificationMethodKeys.filter((key) => key.publicKeyJwk.kid === "0").length === 0) {
        keySet.verificationMethodKeys.push(identityKeySetVerificationMethod);
      }
      if (keySet.verificationMethodKeys) {
        for (const key of keySet.verificationMethodKeys) {
          if (key.publicKeyJwk)
            (_a = (_c = key.publicKeyJwk).kid) !== null && _a !== void 0 ? _a : _c.kid = yield import_crypto4.Jose.jwkThumbprint({ key: key.publicKeyJwk });
          if (key.privateKeyJwk)
            (_b = (_d = key.privateKeyJwk).kid) !== null && _b !== void 0 ? _b : _d.kid = yield import_crypto4.Jose.jwkThumbprint({ key: key.privateKeyJwk });
        }
      }
      return keySet;
    });
  }
  /**
   * Gets the identifier fragment from a DID.
   * @param options The key to get the identifier fragment from.
   * @returns A promise that resolves to a string containing the identifier.
   */
  static getDidIdentifier(options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { key } = options;
      const cryptoKey = yield import_crypto4.Jose.jwkToCryptoKey({ key });
      const identifier = import_z324.default.encode(cryptoKey.material);
      return "did:dht:" + identifier;
    });
  }
  /**
   * Gets the identifier fragment from a DID.
   * @param options The key to get the identifier fragment from.
   * @returns A promise that resolves to a string containing the identifier fragment.
   */
  static getDidIdentifierFragment(options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { key } = options;
      const cryptoKey = yield import_crypto4.Jose.jwkToCryptoKey({ key });
      return import_z324.default.encode(cryptoKey.material);
    });
  }
  /**
   * Publishes a DID Document to the DHT.
   * @param keySet The key set to use to sign the DHT payload.
   * @param didDocument The DID Document to publish.
   * @returns A boolean indicating the success of the publishing operation.
   */
  static publish({ didDocument, keySet }) {
    return __awaiter2(this, void 0, void 0, function* () {
      const publicCryptoKey = yield import_crypto4.Jose.jwkToCryptoKey({ key: keySet.identityKey.publicKeyJwk });
      const privateCryptoKey = yield import_crypto4.Jose.jwkToCryptoKey({ key: keySet.identityKey.privateKeyJwk });
      const isPublished = yield DidDht.publishDidDocument({
        keyPair: {
          publicKey: publicCryptoKey,
          privateKey: privateCryptoKey
        },
        didDocument
      });
      return isPublished;
    });
  }
  /**
   * Resolves a DID Document based on the specified options.
   *
   * @param options - Configuration for resolving a DID Document.
   * @param options.didUrl - The DID URL to resolve.
   * @param options.resolutionOptions - Optional settings for the DID resolution process as defined in the DID Core specification.
   * @returns A Promise that resolves to a `DidResolutionResult`, containing the resolved DID Document and associated metadata.
   */
  static resolve(options) {
    return __awaiter2(this, void 0, void 0, function* () {
      const { didUrl, resolutionOptions: _ } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      if (parsedDid.method !== "dht") {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const didDocument = yield DidDht.getDidDocument({ did: parsedDid.did });
      return {
        "@context": "https://w3id.org/did-resolution/v1",
        didDocument,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          contentType: "application/did+ld+json",
          did: {
            didString: parsedDid.did,
            methodSpecificId: parsedDid.id,
            method: parsedDid.method
          }
        }
      };
    });
  }
};
DidDhtMethod.methodName = "dht";

// dist/esm/did-ion.js
var import_common2 = require("@web5/common");
var import_ion_pow_sdk = __toESM(require("@decentralized-identity/ion-pow-sdk"), 1);
var import_crypto6 = require("@web5/crypto");

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/ErrorCode.js
var ErrorCode_default = {
  DeltaExceedsMaximumSize: "DeltaExceedsMaximumSize",
  DidDocumentPublicKeyIdDuplicated: "DidDocumentPublicKeyIdDuplicated",
  DidDocumentPublicKeyMissingOrIncorrectType: "DidDocumentPublicKeyMissingOrIncorrectType",
  DidDocumentServiceIdDuplicated: "DidDocumentServiceIdDuplicated",
  DidSuffixIncorrectLength: "DidSuffixIncorrectLength",
  EncodedStringIncorrectEncoding: "EncodedStringIncorrectEncoding",
  IdNotUsingBase64UrlCharacterSet: "IdNotUsingBase64UrlCharacterSet",
  IdTooLong: "IdTooLong",
  JwkEs256kMissingOrInvalidCrv: "JwkEs256kMissingOrInvalidCrv",
  JwkEs256kMissingOrInvalidKty: "JwkEs256kMissingOrInvalidKty",
  JwkEs256kHasIncorrectLengthOfX: "JwkEs256kHasIncorrectLengthOfX",
  JwkEs256kHasIncorrectLengthOfY: "JwkEs256kHasIncorrectLengthOfY",
  JwkEs256kHasIncorrectLengthOfD: "JwkEs256kHasIncorrectLengthOfD",
  MultihashStringNotAMultihash: "MultihashStringNotAMultihash",
  MultihashUnsupportedHashAlgorithm: "MultihashUnsupportedHashAlgorithm",
  PublicKeyJwkEs256kHasUnexpectedProperty: "PublicKeyJwkEs256kHasUnexpectedProperty",
  PublicKeyPurposeDuplicated: "PublicKeyPurposeDuplicated",
  ServiceEndpointCannotBeAnArray: "ServiceEndpointCannotBeAnArray",
  ServiceEndpointStringNotValidUri: "ServiceEndpointStringNotValidUri",
  ServiceTypeTooLong: "ServiceTypeTooLong"
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonError.js
var IonError = class extends Error {
  constructor(code, message) {
    super(`${code}: ${message}`);
    this.code = code;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bases/base.js
var Encoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder2) {
    return or(this, decoder2);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder2) {
    return or(this, decoder2);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder2 = this.decoders[prefix];
    if (decoder2) {
      return decoder2.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name, prefix, encode: encode6, decode: decode7 }) => new Codec(name, prefix, encode6, decode7);
var decode3 = (string, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode3 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode3(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode3(input, alphabet2, bitsPerChar, name);
    }
  });
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Encoder.js
var Encoder2 = class _Encoder {
  /**
   * Encodes given bytes into a Base64URL string.
   */
  static encode(content) {
    const encodedContent = base64url.baseEncode(content);
    return encodedContent;
  }
  /**
   * Decodes the given Base64URL string into bytes.
   */
  static decodeAsBytes(encodedContent, inputContextForErrorLogging) {
    if (!_Encoder.isBase64UrlString(encodedContent)) {
      throw new IonError(ErrorCode_default.EncodedStringIncorrectEncoding, `Given ${inputContextForErrorLogging} must be base64url string.`);
    }
    return base64url.baseDecode(encodedContent);
  }
  /**
   * Decodes the given Base64URL string into the original string.
   */
  static decodeAsString(encodedContent, inputContextForErrorLogging) {
    const rawBytes = _Encoder.decodeAsBytes(encodedContent, inputContextForErrorLogging);
    return _Encoder.bytesToString(rawBytes);
  }
  /**
   * Tests if the given string is a Base64URL string.
   */
  static isBase64UrlString(input) {
    const isBase64UrlString = /^[A-Za-z0-9_-]+$/.test(input);
    return isBase64UrlString;
  }
  /**
   * Converts input string to bytes.
   */
  static stringToBytes(input) {
    const bytes = new TextEncoder().encode(input);
    return bytes;
  }
  /**
   * Converts bytes to string.
   */
  static bytesToString(input) {
    const output = new TextDecoder().decode(input);
    return output;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonRequest.js
var URI = __toESM(require_uri_all(), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/OperationKeyType.js
var OperationKeyType;
(function(OperationKeyType2) {
  OperationKeyType2["Public"] = "public";
  OperationKeyType2["Private"] = "private";
})(OperationKeyType || (OperationKeyType = {}));
var OperationKeyType_default = OperationKeyType;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/InputValidator.js
var InputValidator = class {
  /**
   * Validates the schema of a ES256K JWK key.
   */
  static validateEs256kOperationKey(operationKeyJwk, operationKeyType) {
    const allowedProperties = /* @__PURE__ */ new Set(["kty", "crv", "x", "y"]);
    if (operationKeyType === OperationKeyType_default.Private) {
      allowedProperties.add("d");
    }
    for (const property in operationKeyJwk) {
      if (!allowedProperties.has(property)) {
        throw new IonError(ErrorCode_default.PublicKeyJwkEs256kHasUnexpectedProperty, `SECP256K1 JWK key has unexpected property '${property}'.`);
      }
    }
    if (operationKeyJwk.crv !== "secp256k1") {
      throw new IonError(ErrorCode_default.JwkEs256kMissingOrInvalidCrv, `SECP256K1 JWK 'crv' property must be 'secp256k1' but got '${operationKeyJwk.crv}.'`);
    }
    if (operationKeyJwk.kty !== "EC") {
      throw new IonError(ErrorCode_default.JwkEs256kMissingOrInvalidKty, `SECP256K1 JWK 'kty' property must be 'EC' but got '${operationKeyJwk.kty}.'`);
    }
    if (operationKeyJwk.x.length !== 43) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfX, `SECP256K1 JWK 'x' property must be 43 bytes.`);
    }
    if (operationKeyJwk.y.length !== 43) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfY, `SECP256K1 JWK 'y' property must be 43 bytes.`);
    }
    if (operationKeyType === OperationKeyType_default.Private && (operationKeyJwk.d === void 0 || operationKeyJwk.d.length !== 43)) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfD, `SECP256K1 JWK 'd' property must be 43 bytes.`);
    }
  }
  /**
   * Validates an `id` property (in `IonPublicKeyModel` and `IonServiceModel`).
   */
  static validateId(id) {
    const maxIdLength = 50;
    if (id.length > maxIdLength) {
      throw new IonError(ErrorCode_default.IdTooLong, `Key ID length ${id.length} exceed max allowed length of ${maxIdLength}.`);
    }
    if (!Encoder2.isBase64UrlString(id)) {
      throw new IonError(ErrorCode_default.IdNotUsingBase64UrlCharacterSet, `Key ID '${id}' is not a Base64URL string.`);
    }
  }
  /**
   * Validates the given public key purposes.
   */
  static validatePublicKeyPurposes(purposes) {
    if (purposes === void 0) {
      return;
    }
    const processedPurposes = /* @__PURE__ */ new Set();
    for (const purpose of purposes) {
      if (processedPurposes.has(purpose)) {
        throw new IonError(ErrorCode_default.PublicKeyPurposeDuplicated, `Public key purpose '${purpose}' already specified.`);
      }
      processedPurposes.add(purpose);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonSdkConfig.js
var IonSdkConfig = class {
};
IonSdkConfig.hashAlgorithmInMultihashCode = 18;
IonSdkConfig.maxCanonicalizedDeltaSizeInBytes = 1e3;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/JsonCanonicalizer.js
var canonicalize = __toESM(require_canonicalize(), 1);
var JsonCanonicalizer = class _JsonCanonicalizer {
  /**
   * Canonicalizes the given content as bytes.
   */
  static canonicalizeAsBytes(content) {
    const contentWithoutUndefinedProperties = _JsonCanonicalizer.removeAllUndefinedProperties(content);
    const canonicalizedString = canonicalize.default(contentWithoutUndefinedProperties);
    const contentBytes = Encoder2.stringToBytes(canonicalizedString);
    return contentBytes;
  }
  /**
   * Removes all properties within the given object with `undefined` as value.
   */
  static removeAllUndefinedProperties(content) {
    for (const key in content) {
      if (typeof content[key] === "object") {
        _JsonCanonicalizer.removeAllUndefinedProperties(content[key]);
      } else if (content[key] === void 0) {
        delete content[key];
      }
    }
    return content;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Multihash.js
var multihashes = __toESM(require_src5(), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/sha2.js
var import_crypto5 = __toESM(require("crypto"), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/vendor/varint.js
var encode_1 = encode4;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode4(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode4.bytes = offset - oldOffset + 1;
  return out;
}
var decode4 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode4,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/varint.js
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength5 = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/digest.js
var create = (code, digest) => {
  const size = digest.byteLength;
  const sizeOffset = encodingLength5(code);
  const digestOffset = sizeOffset + encodingLength5(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code, size, digest, bytes) {
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/hasher.js
var from2 = ({ name, code, encode: encode6 }) => new Hasher(name, code, encode6);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name, code, encode6) {
    this.name = name;
    this.code = code;
    this.encode = encode6;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest) => create(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto5.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto5.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Multihash.js
var __awaiter3 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Multihash = class _Multihash {
  /**
   * Hashes the content using the hashing algorithm specified.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   */
  static hash(content, hashAlgorithmInMultihashCode) {
    return __awaiter3(this, void 0, void 0, function* () {
      const conventionalHash = yield this.hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode);
      const multihash = multihashes.encode(conventionalHash, hashAlgorithmInMultihashCode);
      return multihash;
    });
  }
  /**
   * Hashes the content using the hashing algorithm specified as a generic (non-multihash) hash.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   * @returns A multihash bytes.
   */
  static hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode) {
    return __awaiter3(this, void 0, void 0, function* () {
      let hash2;
      switch (hashAlgorithmInMultihashCode) {
        case 18:
          hash2 = yield sha256.encode(content);
          break;
        default:
          throw new IonError(ErrorCode_default.MultihashUnsupportedHashAlgorithm, `Hash algorithm defined in multihash code ${hashAlgorithmInMultihashCode} is not supported.`);
      }
      return hash2;
    });
  }
  /**
   * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
   * Mainly used for testing purposes.
   */
  static canonicalizeThenHashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter3(this, void 0, void 0, function* () {
      const canonicalizedStringBytes = JsonCanonicalizer.canonicalizeAsBytes(content);
      const multihashEncodedString = yield _Multihash.hashThenEncode(canonicalizedStringBytes, hashAlgorithmInMultihashCode);
      return multihashEncodedString;
    });
  }
  /**
   * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
   * Mainly used for testing purposes.
   */
  static canonicalizeThenDoubleHashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter3(this, void 0, void 0, function* () {
      const contentBytes = JsonCanonicalizer.canonicalizeAsBytes(content);
      const intermediateHashBytes = yield _Multihash.hashAsNonMultihashBytes(contentBytes, hashAlgorithmInMultihashCode);
      const multihashEncodedString = yield _Multihash.hashThenEncode(intermediateHashBytes, hashAlgorithmInMultihashCode);
      return multihashEncodedString;
    });
  }
  /**
   * Hashes the content using the hashing algorithm specified then encodes the multihash bytes as string.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   */
  static hashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter3(this, void 0, void 0, function* () {
      const multihashBytes = yield _Multihash.hash(content, hashAlgorithmInMultihashCode);
      const multihashEncodedString = Encoder2.encode(multihashBytes);
      return multihashEncodedString;
    });
  }
  /**
   * Checks if the given encoded hash is a multihash computed using the configured hashing algorithm.
   */
  static validateEncodedHashComputedUsingSupportedHashAlgorithm(encodedMultihash, inputContextForErrorLogging) {
    let multihash;
    const multihashBytes = Encoder2.decodeAsBytes(encodedMultihash, inputContextForErrorLogging);
    try {
      multihash = multihashes.decode(multihashBytes);
    } catch (_a) {
      throw new IonError(ErrorCode_default.MultihashStringNotAMultihash, `Given ${inputContextForErrorLogging} string '${encodedMultihash}' is not a multihash after decoding.`);
    }
    const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
    if (hashAlgorithmInMultihashCode !== multihash.code) {
      throw new IonError(ErrorCode_default.MultihashUnsupportedHashAlgorithm, `Given ${inputContextForErrorLogging} uses unsupported multihash algorithm with code ${multihash.code}, should use ${hashAlgorithmInMultihashCode} or change IonSdkConfig to desired hashing algorithm.`);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/OperationType.js
var OperationType;
(function(OperationType3) {
  OperationType3["Create"] = "create";
  OperationType3["Update"] = "update";
  OperationType3["Deactivate"] = "deactivate";
  OperationType3["Recover"] = "recover";
})(OperationType || (OperationType = {}));
var OperationType_default = OperationType;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/PatchAction.js
var PatchAction;
(function(PatchAction2) {
  PatchAction2["Replace"] = "replace";
  PatchAction2["AddPublicKeys"] = "add-public-keys";
  PatchAction2["RemovePublicKeys"] = "remove-public-keys";
  PatchAction2["AddServices"] = "add-services";
  PatchAction2["RemoveServices"] = "remove-services";
})(PatchAction || (PatchAction = {}));
var PatchAction_default = PatchAction;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonRequest.js
var __awaiter4 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IonRequest = class _IonRequest {
  /**
   * Creates an ION DID create request.
   * @param input.document The initial state to be associate with the ION DID to be created using a `replace` document patch action.
   */
  static createCreateRequest(input) {
    return __awaiter4(this, void 0, void 0, function* () {
      const recoveryKey = input.recoveryKey;
      const updateKey = input.updateKey;
      const didDocumentKeys = input.document.publicKeys;
      const services = input.document.services;
      InputValidator.validateEs256kOperationKey(recoveryKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(updateKey, OperationKeyType_default.Public);
      _IonRequest.validateDidDocumentKeys(didDocumentKeys);
      _IonRequest.validateServices(services);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const patches = [{
        action: PatchAction_default.Replace,
        document: input.document
      }];
      const delta = {
        updateCommitment: yield Multihash.canonicalizeThenDoubleHashThenEncode(updateKey, hashAlgorithmInMultihashCode),
        patches
      };
      _IonRequest.validateDeltaSize(delta);
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const suffixData = {
        deltaHash,
        recoveryCommitment: yield Multihash.canonicalizeThenDoubleHashThenEncode(recoveryKey, hashAlgorithmInMultihashCode)
      };
      const operationRequest = {
        type: OperationType_default.Create,
        suffixData,
        delta
      };
      return operationRequest;
    });
  }
  static createDeactivateRequest(input) {
    return __awaiter4(this, void 0, void 0, function* () {
      _IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_default.Public);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        didSuffix: input.didSuffix,
        recoveryKey: input.recoveryPublicKey
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Deactivate,
        didSuffix: input.didSuffix,
        revealValue,
        signedData: compactJws
      };
    });
  }
  static createRecoverRequest(input) {
    return __awaiter4(this, void 0, void 0, function* () {
      _IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextRecoveryPublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextUpdatePublicKey, OperationKeyType_default.Public);
      _IonRequest.validateDidDocumentKeys(input.document.publicKeys);
      _IonRequest.validateServices(input.document.services);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
      const patches = [{
        action: PatchAction_default.Replace,
        document: input.document
      }];
      const nextUpdateCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextUpdatePublicKey, hashAlgorithmInMultihashCode);
      const delta = {
        patches,
        updateCommitment: nextUpdateCommitmentHash
      };
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const nextRecoveryCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextRecoveryPublicKey, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        recoveryCommitment: nextRecoveryCommitmentHash,
        recoveryKey: input.recoveryPublicKey,
        deltaHash
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Recover,
        didSuffix: input.didSuffix,
        revealValue,
        delta,
        signedData: compactJws
      };
    });
  }
  static createUpdateRequest(input) {
    return __awaiter4(this, void 0, void 0, function* () {
      _IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.updatePublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextUpdatePublicKey, OperationKeyType_default.Public);
      _IonRequest.validateServices(input.servicesToAdd);
      _IonRequest.validateDidDocumentKeys(input.publicKeysToAdd);
      if (input.idsOfServicesToRemove !== void 0) {
        for (const id of input.idsOfServicesToRemove) {
          InputValidator.validateId(id);
        }
      }
      if (input.idsOfPublicKeysToRemove !== void 0) {
        for (const id of input.idsOfPublicKeysToRemove) {
          InputValidator.validateId(id);
        }
      }
      const patches = [];
      const servicesToAdd = input.servicesToAdd;
      if (servicesToAdd !== void 0 && servicesToAdd.length > 0) {
        const patch = {
          action: PatchAction_default.AddServices,
          services: servicesToAdd
        };
        patches.push(patch);
      }
      const idsOfServicesToRemove = input.idsOfServicesToRemove;
      if (idsOfServicesToRemove !== void 0 && idsOfServicesToRemove.length > 0) {
        const patch = {
          action: PatchAction_default.RemoveServices,
          ids: idsOfServicesToRemove
        };
        patches.push(patch);
      }
      const publicKeysToAdd = input.publicKeysToAdd;
      if (publicKeysToAdd !== void 0 && publicKeysToAdd.length > 0) {
        const patch = {
          action: PatchAction_default.AddPublicKeys,
          publicKeys: publicKeysToAdd
        };
        patches.push(patch);
      }
      const idsOfPublicKeysToRemove = input.idsOfPublicKeysToRemove;
      if (idsOfPublicKeysToRemove !== void 0 && idsOfPublicKeysToRemove.length > 0) {
        const patch = {
          action: PatchAction_default.RemovePublicKeys,
          ids: idsOfPublicKeysToRemove
        };
        patches.push(patch);
      }
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.updatePublicKey, hashAlgorithmInMultihashCode);
      const nextUpdateCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextUpdatePublicKey, hashAlgorithmInMultihashCode);
      const delta = {
        patches,
        updateCommitment: nextUpdateCommitmentHash
      };
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        updateKey: input.updatePublicKey,
        deltaHash
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Update,
        didSuffix: input.didSuffix,
        revealValue,
        delta,
        signedData: compactJws
      };
    });
  }
  static validateDidSuffix(didSuffix) {
    Multihash.validateEncodedHashComputedUsingSupportedHashAlgorithm(didSuffix, "didSuffix");
  }
  static validateDidDocumentKeys(publicKeys) {
    if (publicKeys === void 0) {
      return;
    }
    const publicKeyIdSet = /* @__PURE__ */ new Set();
    for (const publicKey of publicKeys) {
      if (Array.isArray(publicKey.publicKeyJwk)) {
        throw new IonError(ErrorCode_default.DidDocumentPublicKeyMissingOrIncorrectType, `DID Document key 'publicKeyJwk' property is not a non-array object.`);
      }
      InputValidator.validateId(publicKey.id);
      if (publicKeyIdSet.has(publicKey.id)) {
        throw new IonError(ErrorCode_default.DidDocumentPublicKeyIdDuplicated, `DID Document key with ID '${publicKey.id}' already exists.`);
      }
      publicKeyIdSet.add(publicKey.id);
      InputValidator.validatePublicKeyPurposes(publicKey.purposes);
    }
  }
  static validateServices(services) {
    if (services !== void 0 && services.length !== 0) {
      const serviceIdSet = /* @__PURE__ */ new Set();
      for (const service of services) {
        _IonRequest.validateService(service);
        if (serviceIdSet.has(service.id)) {
          throw new IonError(ErrorCode_default.DidDocumentServiceIdDuplicated, "Service id has to be unique");
        }
        serviceIdSet.add(service.id);
      }
    }
  }
  static validateService(service) {
    InputValidator.validateId(service.id);
    const maxTypeLength = 30;
    if (service.type.length > maxTypeLength) {
      const errorMessage = `Service endpoint type length ${service.type.length} exceeds max allowed length of ${maxTypeLength}.`;
      throw new IonError(ErrorCode_default.ServiceTypeTooLong, errorMessage);
    }
    if (Array.isArray(service.serviceEndpoint)) {
      const errorMessage = "Service endpoint value cannot be an array.";
      throw new IonError(ErrorCode_default.ServiceEndpointCannotBeAnArray, errorMessage);
    }
    if (typeof service.serviceEndpoint === "string") {
      const uri = URI.parse(service.serviceEndpoint);
      if (uri.error !== void 0) {
        throw new IonError(ErrorCode_default.ServiceEndpointStringNotValidUri, `Service endpoint string '${service.serviceEndpoint}' is not a URI.`);
      }
    }
  }
  static validateDeltaSize(delta) {
    const deltaBytes = JsonCanonicalizer.canonicalizeAsBytes(delta);
    if (deltaBytes.length > IonSdkConfig.maxCanonicalizedDeltaSizeInBytes) {
      const errorMessage = `Delta of ${deltaBytes.length} bytes exceeded limit of ${IonSdkConfig.maxCanonicalizedDeltaSizeInBytes} bytes.`;
      throw new IonError(ErrorCode_default.DeltaExceedsMaximumSize, errorMessage);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonDid.js
var __awaiter5 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IonDid = class _IonDid {
  /**
   * Creates a long-form DID.
   * @param input.document The initial state to be associate with the ION DID to be created using a `replace` document patch action.
   */
  static createLongFormDid(input) {
    return __awaiter5(this, void 0, void 0, function* () {
      const createRequest = yield IonRequest.createCreateRequest(input);
      const didUniqueSuffix = yield _IonDid.computeDidUniqueSuffix(createRequest.suffixData);
      let shortFormDid;
      if (IonSdkConfig.network === void 0 || IonSdkConfig.network === "mainnet") {
        shortFormDid = `did:ion:${didUniqueSuffix}`;
      } else {
        shortFormDid = `did:ion:${IonSdkConfig.network}:${didUniqueSuffix}`;
      }
      const initialState = {
        suffixData: createRequest.suffixData,
        delta: createRequest.delta
      };
      const canonicalizedInitialStateBytes = JsonCanonicalizer.canonicalizeAsBytes(initialState);
      const encodedCanonicalizedInitialStateString = Encoder2.encode(canonicalizedInitialStateBytes);
      const longFormDid = `${shortFormDid}:${encodedCanonicalizedInitialStateString}`;
      return longFormDid;
    });
  }
  /**
   * Computes the DID unique suffix given the encoded suffix data string.
   */
  static computeDidUniqueSuffix(suffixData) {
    return __awaiter5(this, void 0, void 0, function* () {
      const canonicalizedStringBytes = JsonCanonicalizer.canonicalizeAsBytes(suffixData);
      const multihash = yield Multihash.hash(canonicalizedStringBytes, IonSdkConfig.hashAlgorithmInMultihashCode);
      const encodedMultihash = Encoder2.encode(multihash);
      return encodedMultihash;
    });
  }
};

// ../../node_modules/@noble/ed25519/index.js
var P = 2n ** 255n - 19n;
var N = 2n ** 252n + 27742317777372353535851937790883648493n;
var Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an;
var Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n;
var CURVE = {
  a: -1n,
  d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,
  p: P,
  n: N,
  h: 8,
  Gx,
  Gy
  // field prime, curve (group) order, cofactor
};
var err = (m = "") => {
  throw new Error(m);
};
var str = (s) => typeof s === "string";
var au8 = (a, l) => (
  // is Uint8Array (of specific length)
  !(a instanceof Uint8Array) || typeof l === "number" && l > 0 && a.length !== l ? err("Uint8Array expected") : a
);
var u8n = (data) => new Uint8Array(data);
var toU8 = (a, len) => au8(str(a) ? h2b(a) : u8n(a), len);
var mod = (a, b = P) => {
  let r = a % b;
  return r >= 0n ? r : b + r;
};
var isPoint = (p) => p instanceof Point ? p : err("Point expected");
var Gpows = void 0;
var Point = class _Point {
  constructor(ex, ey, ez, et) {
    this.ex = ex;
    this.ey = ey;
    this.ez = ez;
    this.et = et;
  }
  static fromAffine(p) {
    return new _Point(p.x, p.y, 1n, mod(p.x * p.y));
  }
  static fromHex(hex, strict = true) {
    const { d } = CURVE;
    hex = toU8(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = b2n_LE(normed);
    if (y === 0n) {
    } else {
      if (strict && !(0n < y && y < P))
        err("bad y coord 1");
      if (!strict && !(0n < y && y < 2n ** 256n))
        err("bad y coord 2");
    }
    const y2 = mod(y * y);
    const u = mod(y2 - 1n);
    const v = mod(d * y2 + 1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      err("bad y coordinate 3");
    const isXOdd = (x & 1n) === 1n;
    const isHeadOdd = (hex[31] & 128) !== 0;
    if (isHeadOdd !== isXOdd)
      x = mod(-x);
    return new _Point(x, y, 1n, mod(x * y));
  }
  get x() {
    return this.toAffine().x;
  }
  // .x, .y will call expensive toAffine.
  get y() {
    return this.toAffine().y;
  }
  // Should be used with care.
  equals(other) {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other);
    const X1Z2 = mod(X1 * Z2), X2Z1 = mod(X2 * Z1);
    const Y1Z2 = mod(Y1 * Z2), Y2Z1 = mod(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  negate() {
    return new _Point(mod(-this.ex), this.ey, this.ez, mod(-this.et));
  }
  double() {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { a } = CURVE;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(2n * mod(Z1 * Z1));
    const D = mod(a * A);
    const x1y1 = X1 + Y1;
    const E = mod(mod(x1y1 * x1y1) - A - B);
    const G3 = D + B;
    const F = G3 - C;
    const H = D - B;
    const X3 = mod(E * F);
    const Y3 = mod(G3 * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G3);
    return new _Point(X3, Y3, Z3, T3);
  }
  add(other) {
    const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
    const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other);
    const { a, d } = CURVE;
    const A = mod(X1 * X2);
    const B = mod(Y1 * Y2);
    const C = mod(T1 * d * T2);
    const D = mod(Z1 * Z2);
    const E = mod((X1 + Y1) * (X2 + Y2) - A - B);
    const F = mod(D - C);
    const G3 = mod(D + C);
    const H = mod(B - a * A);
    const X3 = mod(E * F);
    const Y3 = mod(G3 * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G3);
    return new _Point(X3, Y3, Z3, T3);
  }
  mul(n, safe = true) {
    if (n === 0n)
      return safe === true ? err("cannot multiply by 0") : I;
    if (!(typeof n === "bigint" && 0n < n && n < N))
      err("invalid scalar, must be < L");
    if (!safe && this.is0() || n === 1n)
      return this;
    if (this.equals(G))
      return wNAF(n).p;
    let p = I, f = G;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  multiply(scalar) {
    return this.mul(scalar);
  }
  // Aliases for compatibilty
  clearCofactor() {
    return this.mul(BigInt(CURVE.h), false);
  }
  // multiply by cofactor
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  // check if P is small order
  isTorsionFree() {
    let p = this.mul(N / 2n, false).double();
    if (N % 2n)
      p = p.add(this);
    return p.is0();
  }
  toAffine() {
    const { ex: x, ey: y, ez: z } = this;
    if (this.is0())
      return { x: 0n, y: 0n };
    const iz = invert(z);
    if (mod(z * iz) !== 1n)
      err("invalid inverse");
    return { x: mod(x * iz), y: mod(y * iz) };
  }
  toRawBytes() {
    const { x, y } = this.toAffine();
    const b = n2b_32LE(y);
    b[31] |= x & 1n ? 128 : 0;
    return b;
  }
  toHex() {
    return b2h(this.toRawBytes());
  }
  // encode to hex string
};
Point.BASE = new Point(Gx, Gy, 1n, mod(Gx * Gy));
Point.ZERO = new Point(0n, 1n, 1n, 0n);
var { BASE: G, ZERO: I } = Point;
var padh = (num, pad) => num.toString(16).padStart(pad, "0");
var b2h = (b) => Array.from(b).map((e) => padh(e, 2)).join("");
var h2b = (hex) => {
  const l = hex.length;
  if (!str(hex) || l % 2)
    err("hex invalid 1");
  const arr = u8n(l / 2);
  for (let i = 0; i < arr.length; i++) {
    const j = i * 2;
    const h = hex.slice(j, j + 2);
    const b = Number.parseInt(h, 16);
    if (Number.isNaN(b) || b < 0)
      err("hex invalid 2");
    arr[i] = b;
  }
  return arr;
};
var n2b_32LE = (num) => h2b(padh(num, 32 * 2)).reverse();
var b2n_LE = (b) => BigInt("0x" + b2h(u8n(au8(b)).reverse()));
var concatB = (...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
var invert = (num, md = P) => {
  if (num === 0n || md <= 0n)
    err("no inverse n=" + num + " mod=" + md);
  let a = mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? mod(x, md) : err("no inverse");
};
var pow2 = (x, power) => {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P;
  }
  return r;
};
var pow_2_252_3 = (x) => {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return { pow_p_5_8, b2 };
};
var RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;
var uvRatio = (u, v) => {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * RM1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((mod(x) & 1n) === 1n)
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
};
var _shaS;
var cr = () => (
  // We support: 1) browsers 2) node.js 19+
  typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
var etc = {
  bytesToHex: b2h,
  hexToBytes: h2b,
  concatBytes: concatB,
  mod,
  invert,
  randomBytes: (len) => {
    const crypto4 = cr();
    if (!crypto4)
      err("crypto.getRandomValues must be defined");
    return crypto4.getRandomValues(u8n(len));
  },
  sha512Async: async (...messages) => {
    const crypto4 = cr();
    if (!crypto4)
      err("crypto.subtle or etc.sha512Async must be defined");
    const m = concatB(...messages);
    return u8n(await crypto4.subtle.digest("SHA-512", m.buffer));
  },
  sha512Sync: void 0
  // Actual logic below
};
Object.defineProperties(etc, { sha512Sync: {
  configurable: false,
  get() {
    return _shaS;
  },
  set(f) {
    if (!_shaS)
      _shaS = f;
  }
} });
var W = 8;
var precompute = () => {
  const points = [];
  const windows = 256 / W + 1;
  let p = G, b = p;
  for (let w = 0; w < windows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < 2 ** (W - 1); i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var wNAF = (n) => {
  const comp = Gpows || (Gpows = precompute());
  const neg = (cnd, p2) => {
    let n2 = p2.negate();
    return cnd ? n2 : p2;
  };
  let p = I, f = G;
  const windows = 1 + 256 / W;
  const wsize = 2 ** (W - 1);
  const mask = BigInt(2 ** W - 1);
  const maxNum = 2 ** W;
  const shiftBy = BigInt(W);
  for (let w = 0; w < windows; w++) {
    const off = w * wsize;
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > wsize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off1 = off, off2 = off + Math.abs(wbits) - 1;
    const cnd1 = w % 2 !== 0, cnd2 = wbits < 0;
    if (wbits === 0) {
      f = f.add(neg(cnd1, comp[off1]));
    } else {
      p = p.add(neg(cnd2, comp[off2]));
    }
  }
  return { p, f };
};

// ../../node_modules/@noble/secp256k1/index.js
var B256 = 2n ** 256n;
var P2 = B256 - 0x1000003d1n;
var N10 = B256 - 0x14551231950b75fc4402da1732fc9bebfn;
var Gx2 = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n;
var Gy2 = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n;
var CURVE2 = { p: P2, n: N10, a: 0n, b: 7n, Gx: Gx2, Gy: Gy2 };
var fLen = 32;
var crv = (x) => mod2(mod2(x * x) * x + CURVE2.b);
var err2 = (m = "") => {
  throw new Error(m);
};
var big = (n) => typeof n === "bigint";
var str2 = (s) => typeof s === "string";
var fe = (n) => big(n) && 0n < n && n < P2;
var ge = (n) => big(n) && 0n < n && n < N10;
var au82 = (a, l) => (
  // is Uint8Array (of specific length)
  !(a instanceof Uint8Array) || typeof l === "number" && l > 0 && a.length !== l ? err2("Uint8Array expected") : a
);
var u8n2 = (data) => new Uint8Array(data);
var toU82 = (a, len) => au82(str2(a) ? h2b2(a) : u8n2(a), len);
var mod2 = (a, b = P2) => {
  let r = a % b;
  return r >= 0n ? r : b + r;
};
var isPoint2 = (p) => p instanceof Point2 ? p : err2("Point expected");
var Gpows2 = void 0;
var Point2 = class _Point {
  constructor(px, py, pz) {
    this.px = px;
    this.py = py;
    this.pz = pz;
  }
  //3d=less inversions
  static fromAffine(p) {
    return new _Point(p.x, p.y, 1n);
  }
  static fromHex(hex) {
    hex = toU82(hex);
    let p = void 0;
    const head = hex[0], tail = hex.subarray(1);
    const x = slcNum(tail, 0, fLen), len = hex.length;
    if (len === 33 && [2, 3].includes(head)) {
      if (!fe(x))
        err2("Point hex invalid: x not FE");
      let y = sqrt(crv(x));
      const isYOdd = (y & 1n) === 1n;
      const headOdd = (head & 1) === 1;
      if (headOdd !== isYOdd)
        y = mod2(-y);
      p = new _Point(x, y, 1n);
    }
    if (len === 65 && head === 4)
      p = new _Point(x, slcNum(tail, fLen, 2 * fLen), 1n);
    return p ? p.ok() : err2("Point is not on curve");
  }
  static fromPrivateKey(k) {
    return G2.mul(toPriv(k));
  }
  // Create point from a private key.
  get x() {
    return this.aff().x;
  }
  // .x, .y will call expensive toAffine:
  get y() {
    return this.aff().y;
  }
  // should be used with care.
  equals(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = isPoint2(other);
    const X1Z2 = mod2(X1 * Z2), X2Z1 = mod2(X2 * Z1);
    const Y1Z2 = mod2(Y1 * Z2), Y2Z1 = mod2(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new _Point(this.px, mod2(-this.py), this.pz);
  }
  // Flip point over y coord
  double() {
    return this.add(this);
  }
  // Point doubling: P+P, complete formula.
  add(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = isPoint2(other);
    const { a, b } = CURVE2;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = mod2(b * 3n);
    let t0 = mod2(X1 * X2), t1 = mod2(Y1 * Y2), t2 = mod2(Z1 * Z2), t3 = mod2(X1 + Y1);
    let t4 = mod2(X2 + Y2);
    t3 = mod2(t3 * t4);
    t4 = mod2(t0 + t1);
    t3 = mod2(t3 - t4);
    t4 = mod2(X1 + Z1);
    let t5 = mod2(X2 + Z2);
    t4 = mod2(t4 * t5);
    t5 = mod2(t0 + t2);
    t4 = mod2(t4 - t5);
    t5 = mod2(Y1 + Z1);
    X3 = mod2(Y2 + Z2);
    t5 = mod2(t5 * X3);
    X3 = mod2(t1 + t2);
    t5 = mod2(t5 - X3);
    Z3 = mod2(a * t4);
    X3 = mod2(b3 * t2);
    Z3 = mod2(X3 + Z3);
    X3 = mod2(t1 - Z3);
    Z3 = mod2(t1 + Z3);
    Y3 = mod2(X3 * Z3);
    t1 = mod2(t0 + t0);
    t1 = mod2(t1 + t0);
    t2 = mod2(a * t2);
    t4 = mod2(b3 * t4);
    t1 = mod2(t1 + t2);
    t2 = mod2(t0 - t2);
    t2 = mod2(a * t2);
    t4 = mod2(t4 + t2);
    t0 = mod2(t1 * t4);
    Y3 = mod2(Y3 + t0);
    t0 = mod2(t5 * t4);
    X3 = mod2(t3 * X3);
    X3 = mod2(X3 - t0);
    t0 = mod2(t3 * t1);
    Z3 = mod2(t5 * Z3);
    Z3 = mod2(Z3 + t0);
    return new _Point(X3, Y3, Z3);
  }
  mul(n, safe = true) {
    if (!safe && n === 0n)
      return I2;
    if (!ge(n))
      err2("invalid scalar");
    if (this.equals(G2))
      return wNAF2(n).p;
    let p = I2, f = G2;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  mulAddQUns(R, u1, u2) {
    return this.mul(u1, false).add(R.mul(u2, false)).ok();
  }
  // to private keys. Doesn't use Shamir trick
  toAffine() {
    const { px: x, py: y, pz: z } = this;
    if (this.equals(I2))
      return { x: 0n, y: 0n };
    if (z === 1n)
      return { x, y };
    const iz = inv(z);
    if (mod2(z * iz) !== 1n)
      err2("invalid inverse");
    return { x: mod2(x * iz), y: mod2(y * iz) };
  }
  assertValidity() {
    const { x, y } = this.aff();
    if (!fe(x) || !fe(y))
      err2("Point invalid: x or y");
    return mod2(y * y) === crv(x) ? (
      // y² = x³ + ax + b, must be equal
      this
    ) : err2("Point invalid: not on curve");
  }
  multiply(n) {
    return this.mul(n);
  }
  // Aliases to compress code
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(isCompressed = true) {
    const { x, y } = this.aff();
    const head = isCompressed ? (y & 1n) === 0n ? "02" : "03" : "04";
    return head + n2h(x) + (isCompressed ? "" : n2h(y));
  }
  toRawBytes(isCompressed = true) {
    return h2b2(this.toHex(isCompressed));
  }
};
Point2.BASE = new Point2(Gx2, Gy2, 1n);
Point2.ZERO = new Point2(0n, 1n, 0n);
var { BASE: G2, ZERO: I2 } = Point2;
var padh2 = (n, pad) => n.toString(16).padStart(pad, "0");
var b2h2 = (b) => Array.from(b).map((e) => padh2(e, 2)).join("");
var h2b2 = (hex) => {
  const l = hex.length;
  if (!str2(hex) || l % 2)
    err2("hex invalid 1");
  const arr = u8n2(l / 2);
  for (let i = 0; i < arr.length; i++) {
    const j = i * 2;
    const h = hex.slice(j, j + 2);
    const b = Number.parseInt(h, 16);
    if (Number.isNaN(b) || b < 0)
      err2("hex invalid 2");
    arr[i] = b;
  }
  return arr;
};
var b2n = (b) => BigInt("0x" + (b2h2(b) || "0"));
var slcNum = (b, from3, to) => b2n(b.slice(from3, to));
var n2b = (num) => {
  return big(num) && num >= 0n && num < B256 ? h2b2(padh2(num, 2 * fLen)) : err2("bigint expected");
};
var n2h = (num) => b2h2(n2b(num));
var concatB2 = (...arrs) => {
  const r = u8n2(arrs.reduce((sum, a) => sum + au82(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
var inv = (num, md = P2) => {
  if (num === 0n || md <= 0n)
    err2("no inverse n=" + num + " mod=" + md);
  let a = mod2(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? mod2(x, md) : err2("no inverse");
};
var sqrt = (n) => {
  let r = 1n;
  for (let num = n, e = (P2 + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r = r * num % P2;
    num = num * num % P2;
  }
  return mod2(r * r) === n ? r : err2("sqrt invalid");
};
var toPriv = (p) => {
  if (!big(p))
    p = b2n(toU82(p, fLen));
  return ge(p) ? p : err2("private key out of range");
};
var cr2 = () => (
  // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto
  typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
var _hmacSync;
function hashToPrivateKey(hash2) {
  hash2 = toU82(hash2);
  const minLen = fLen + 8;
  if (hash2.length < minLen || hash2.length > 1024)
    err2("expected proper params");
  const num = mod2(b2n(hash2), N10 - 1n) + 1n;
  return n2b(num);
}
var etc2 = {
  hexToBytes: h2b2,
  bytesToHex: b2h2,
  concatBytes: concatB2,
  bytesToNumberBE: b2n,
  numberToBytesBE: n2b,
  mod: mod2,
  invert: inv,
  hmacSha256Async: async (key, ...msgs) => {
    const crypto4 = cr2();
    if (!crypto4)
      return err2("etc.hmacSha256Async not set");
    const s = crypto4.subtle;
    const k = await s.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    return u8n2(await s.sign("HMAC", k, concatB2(...msgs)));
  },
  hmacSha256Sync: _hmacSync,
  hashToPrivateKey,
  randomBytes: (len) => {
    const crypto4 = cr2();
    if (!crypto4)
      err2("crypto.getRandomValues must be defined");
    return crypto4.getRandomValues(u8n2(len));
  }
};
Object.defineProperties(etc2, { hmacSha256Sync: {
  configurable: false,
  get() {
    return _hmacSync;
  },
  set(f) {
    if (!_hmacSync)
      _hmacSync = f;
  }
} });
var W2 = 8;
var precompute2 = () => {
  const points = [];
  const windows = 256 / W2 + 1;
  let p = G2, b = p;
  for (let w = 0; w < windows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < 2 ** (W2 - 1); i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var wNAF2 = (n) => {
  const comp = Gpows2 || (Gpows2 = precompute2());
  const neg = (cnd, p2) => {
    let n2 = p2.negate();
    return cnd ? n2 : p2;
  };
  let p = I2, f = G2;
  const windows = 1 + 256 / W2;
  const wsize = 2 ** (W2 - 1);
  const mask = BigInt(2 ** W2 - 1);
  const maxNum = 2 ** W2;
  const shiftBy = BigInt(W2);
  for (let w = 0; w < windows; w++) {
    const off = w * wsize;
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > wsize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off1 = off, off2 = off + Math.abs(wbits) - 1;
    const cnd1 = w % 2 !== 0, cnd2 = wbits < 0;
    if (wbits === 0) {
      f = f.add(neg(cnd1, comp[off1]));
    } else {
      p = p.add(neg(cnd2, comp[off2]));
    }
  }
  return { p, f };
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/IonNetwork.js
var IonNetwork;
(function(IonNetwork2) {
  IonNetwork2["Mainnet"] = "mainnet";
  IonNetwork2["Testnet"] = "test";
})(IonNetwork || (IonNetwork = {}));

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/IonPublicKeyPurpose.js
var IonPublicKeyPurpose;
(function(IonPublicKeyPurpose2) {
  IonPublicKeyPurpose2["Authentication"] = "authentication";
  IonPublicKeyPurpose2["AssertionMethod"] = "assertionMethod";
  IonPublicKeyPurpose2["CapabilityInvocation"] = "capabilityInvocation";
  IonPublicKeyPurpose2["CapabilityDelegation"] = "capabilityDelegation";
  IonPublicKeyPurpose2["KeyAgreement"] = "keyAgreement";
})(IonPublicKeyPurpose || (IonPublicKeyPurpose = {}));
var IonPublicKeyPurpose_default = IonPublicKeyPurpose;

// dist/esm/did-ion.js
var __awaiter6 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OperationType2;
(function(OperationType3) {
  OperationType3["Create"] = "create";
  OperationType3["Update"] = "update";
  OperationType3["Deactivate"] = "deactivate";
  OperationType3["Recover"] = "recover";
})(OperationType2 || (OperationType2 = {}));
var VerificationRelationshipToIonPublicKeyPurpose = {
  assertionMethod: IonPublicKeyPurpose_default.AssertionMethod,
  authentication: IonPublicKeyPurpose_default.Authentication,
  capabilityDelegation: IonPublicKeyPurpose_default.CapabilityDelegation,
  capabilityInvocation: IonPublicKeyPurpose_default.CapabilityInvocation,
  keyAgreement: IonPublicKeyPurpose_default.KeyAgreement
};
var DidIonMethod = class _DidIonMethod {
  static anchor(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { challengeEnabled = false, challengeEndpoint = "https://beta.ion.msidentity.com/api/v1.0/proof-of-work-challenge", keySet, services, operationsEndpoint = "https://ion.tbd.engineering/operations" } = options;
      const ionDocument = yield _DidIonMethod.createIonDocument({
        keySet,
        services
      });
      const createRequest = yield _DidIonMethod.getIonCreateRequest({
        ionDocument,
        recoveryPublicKeyJwk: keySet.recoveryKey.publicKeyJwk,
        updatePublicKeyJwk: keySet.updateKey.publicKeyJwk
      });
      let resolutionResult;
      if (challengeEnabled) {
        const response = yield import_ion_pow_sdk.default.submitIonRequest(challengeEndpoint, operationsEndpoint, JSON.stringify(createRequest));
        if (response !== void 0 && (0, import_common2.universalTypeOf)(response) === "String") {
          resolutionResult = JSON.parse(response);
        }
      } else {
        const response = yield fetch(operationsEndpoint, {
          method: "POST",
          mode: "cors",
          body: JSON.stringify(createRequest),
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (response.ok) {
          resolutionResult = yield response.json();
        }
      }
      return resolutionResult;
    });
  }
  static create(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      let { anchor, keyAlgorithm, keySet, services } = options !== null && options !== void 0 ? options : {};
      const did = {};
      did.keySet = yield _DidIonMethod.generateKeySet({ keyAlgorithm, keySet });
      did.did = yield _DidIonMethod.getLongFormDid({
        keySet: did.keySet,
        services
      });
      did.canonicalId = yield _DidIonMethod.getShortFormDid({ didUrl: did.did });
      let didResolutionResult;
      if (anchor) {
        didResolutionResult = yield _DidIonMethod.anchor({
          keySet: did.keySet,
          services
        });
      } else {
        didResolutionResult = yield _DidIonMethod.resolve({ didUrl: did.did });
      }
      did.document = didResolutionResult.didDocument;
      return did;
    });
  }
  static decodeLongFormDid(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { didUrl } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        throw new Error(`DidIonMethod: Unable to parse DID: ${didUrl}`);
      }
      const decodedLongFormDid = import_common2.Convert.base64Url(parsedDid.id.split(":").pop()).toObject();
      const createRequest = Object.assign(Object.assign({}, decodedLongFormDid), { type: OperationType2.Create });
      return createRequest;
    });
  }
  /**
   * Generates two key pairs used for authorization and encryption purposes
   * when interfacing with DWNs. The IDs of these keys are referenced in the
   * service object that includes the dwnUrls provided.
   */
  static generateDwnOptions(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const {
        signingKeyAlgorithm = "Ed25519",
        // Generate Ed25519 key pairs, by default.
        serviceId = "#dwn",
        // Use default ID value, unless overridden.
        signingKeyId = "#dwn-sig",
        // Use default key ID value, unless overridden.
        encryptionKeyId = "#dwn-enc",
        // Use default key ID value, unless overridden.
        serviceEndpointNodes
      } = options;
      const signingKeyPair = yield _DidIonMethod.generateJwkKeyPair({
        keyAlgorithm: signingKeyAlgorithm,
        keyId: signingKeyId
      });
      const encryptionKeyPair = yield _DidIonMethod.generateJwkKeyPair({
        keyAlgorithm: "secp256k1",
        keyId: encryptionKeyId
      });
      const keySet = {
        verificationMethodKeys: [
          Object.assign(Object.assign({}, signingKeyPair), { relationships: ["authentication"] }),
          Object.assign(Object.assign({}, encryptionKeyPair), { relationships: ["keyAgreement"] })
        ]
      };
      const serviceEndpoint = {
        encryptionKeys: [encryptionKeyId],
        nodes: serviceEndpointNodes,
        signingKeys: [signingKeyId]
      };
      const services = [{
        id: serviceId,
        serviceEndpoint,
        type: "DecentralizedWebNode"
      }];
      return { keySet, services };
    });
  }
  static generateJwkKeyPair(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { keyAlgorithm, keyId } = options;
      let cryptoKeyPair;
      switch (keyAlgorithm) {
        case "Ed25519": {
          cryptoKeyPair = yield new import_crypto6.EdDsaAlgorithm().generateKey({
            algorithm: { name: "EdDSA", namedCurve: "Ed25519" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        case "secp256k1": {
          cryptoKeyPair = yield new import_crypto6.EcdsaAlgorithm().generateKey({
            algorithm: { name: "ECDSA", namedCurve: "secp256k1" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        default: {
          throw new Error(`Unsupported crypto algorithm: '${keyAlgorithm}'`);
        }
      }
      const jwkKeyPair = yield import_crypto6.Jose.cryptoKeyToJwkPair({ keyPair: cryptoKeyPair });
      if (keyId) {
        jwkKeyPair.privateKeyJwk.kid = keyId;
        jwkKeyPair.publicKeyJwk.kid = keyId;
      } else {
        const jwkThumbprint = yield import_crypto6.Jose.jwkThumbprint({ key: jwkKeyPair.publicKeyJwk });
        jwkKeyPair.privateKeyJwk.kid = jwkThumbprint;
        jwkKeyPair.publicKeyJwk.kid = jwkThumbprint;
      }
      return jwkKeyPair;
    });
  }
  static generateKeySet(options) {
    var _a, _b;
    var _c, _d;
    return __awaiter6(this, void 0, void 0, function* () {
      let { keyAlgorithm = "Ed25519", keySet = {} } = options !== null && options !== void 0 ? options : {};
      if (keySet.verificationMethodKeys === void 0) {
        const authenticationkeyPair = yield _DidIonMethod.generateJwkKeyPair({
          keyAlgorithm,
          keyId: "dwn-sig"
        });
        keySet.verificationMethodKeys = [Object.assign(Object.assign({}, authenticationkeyPair), { relationships: ["authentication", "assertionMethod"] })];
      }
      if (keySet.recoveryKey === void 0) {
        keySet.recoveryKey = yield _DidIonMethod.generateJwkKeyPair({
          keyAlgorithm: "secp256k1",
          keyId: "ion-recovery-1"
        });
      }
      if (keySet.updateKey === void 0) {
        keySet.updateKey = yield _DidIonMethod.generateJwkKeyPair({
          keyAlgorithm: "secp256k1",
          keyId: "ion-update-1"
        });
      }
      for (const key of [...keySet.verificationMethodKeys, keySet.recoveryKey, keySet.updateKey]) {
        if ("publicKeyJwk" in key)
          (_a = (_c = key.publicKeyJwk).kid) !== null && _a !== void 0 ? _a : _c.kid = yield import_crypto6.Jose.jwkThumbprint({ key: key.publicKeyJwk });
        if ("privateKeyJwk" in key)
          (_b = (_d = key.privateKeyJwk).kid) !== null && _b !== void 0 ? _b : _d.kid = yield import_crypto6.Jose.jwkThumbprint({ key: key.privateKeyJwk });
      }
      return keySet;
    });
  }
  /**
   * Given the W3C DID Document of a `did:ion` DID, return the identifier of
   * the verification method key that will be used for signing messages and
   * credentials, by default.
   *
   * @param document = DID Document to get the default signing key from.
   * @returns Verification method identifier for the default signing key.
   */
  static getDefaultSigningKey(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { didDocument } = options;
      if (!didDocument.id) {
        throw new Error(`DidIonMethod: DID document is missing 'id' property`);
      }
      const [dwnService] = getServices({ didDocument, type: "DecentralizedWebNode" });
      if (isDwnServiceEndpoint(dwnService === null || dwnService === void 0 ? void 0 : dwnService.serviceEndpoint)) {
        const [verificationMethodId] = dwnService.serviceEndpoint.signingKeys;
        const did = didDocument.id;
        const signingKeyId = `${did}${verificationMethodId}`;
        return signingKeyId;
      }
      if (didDocument.authentication && Array.isArray(didDocument.authentication) && didDocument.authentication.length > 0 && typeof didDocument.authentication[0] === "string") {
        const [verificationMethodId] = didDocument.authentication;
        const did = didDocument.id;
        const signingKeyId = `${did}${verificationMethodId}`;
        return signingKeyId;
      }
    });
  }
  static getLongFormDid(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { services = [], keySet } = options;
      const ionDocument = yield _DidIonMethod.createIonDocument({
        keySet,
        services
      });
      const recoveryKey = _DidIonMethod.jwkToIonJwk({ key: keySet.recoveryKey.publicKeyJwk });
      const updateKey = _DidIonMethod.jwkToIonJwk({ key: keySet.updateKey.publicKeyJwk });
      const did = yield IonDid.createLongFormDid({
        document: ionDocument,
        recoveryKey,
        updateKey
      });
      return did;
    });
  }
  static getShortFormDid(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { didUrl } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        throw new Error(`DidIonMethod: Unable to parse DID: ${didUrl}`);
      }
      const shortFormDid = parsedDid.did.split(":", 3).join(":");
      return shortFormDid;
    });
  }
  static resolve(options) {
    var _a;
    return __awaiter6(this, void 0, void 0, function* () {
      const { didUrl, resolutionOptions = {} } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      if (parsedDid.method !== "ion") {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const { resolutionEndpoint = "https://ion.tbd.engineering/identifiers/" } = resolutionOptions;
      const normalizeUrl = (url) => url.endsWith("/") ? url : url + "/";
      const resolutionUrl = `${normalizeUrl(resolutionEndpoint)}${parsedDid.did}`;
      const response = yield fetch(resolutionUrl);
      let resolutionResult;
      try {
        resolutionResult = yield response.json();
      } catch (error2) {
        resolutionResult = {};
      }
      if (response.ok) {
        return resolutionResult;
      }
      if ("didResolutionMetadata" in resolutionResult) {
        return resolutionResult;
      }
      let error = "internalError";
      let errorMessage = `DID resolver responded with HTTP status code: ${response.status}`;
      if ("error" in resolutionResult && typeof resolutionResult.error === "object" && "code" in resolutionResult.error && typeof resolutionResult.error.code === "string" && "message" in resolutionResult.error && typeof resolutionResult.error.message === "string") {
        error = resolutionResult.error.code.includes("not_found") ? "notFound" : error;
        errorMessage = (_a = resolutionResult.error.message) !== null && _a !== void 0 ? _a : errorMessage;
      }
      return {
        "@context": "https://w3id.org/did-resolution/v1",
        didDocument: void 0,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          contentType: "application/did+ld+json",
          error,
          errorMessage
        }
      };
    });
  }
  static createIonDocument(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { services = [], keySet } = options;
      const ionPublicKeys = [];
      for (const key of keySet.verificationMethodKeys) {
        const ionPurposes = [];
        for (const relationship of key.relationships) {
          ionPurposes.push(VerificationRelationshipToIonPublicKeyPurpose[relationship]);
        }
        const publicKeyId = key.publicKeyJwk.kid.startsWith("#") ? key.publicKeyJwk.kid.substring(1) : key.publicKeyJwk.kid;
        const publicKey = {
          id: publicKeyId,
          publicKeyJwk: _DidIonMethod.jwkToIonJwk({ key: key.publicKeyJwk }),
          purposes: ionPurposes,
          type: "JsonWebKey2020"
        };
        ionPublicKeys.push(publicKey);
      }
      const ionServices = services.map((service) => Object.assign(Object.assign({}, service), { id: service.id.startsWith("#") ? service.id.substring(1) : service.id }));
      const ionDocumentModel = {
        publicKeys: ionPublicKeys,
        services: ionServices
      };
      return ionDocumentModel;
    });
  }
  static getIonCreateRequest(options) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { ionDocument, recoveryPublicKeyJwk, updatePublicKeyJwk } = options;
      const createRequest = yield IonRequest.createCreateRequest({
        document: ionDocument,
        recoveryKey: _DidIonMethod.jwkToIonJwk({ key: recoveryPublicKeyJwk }),
        updateKey: _DidIonMethod.jwkToIonJwk({ key: updatePublicKeyJwk })
      });
      return createRequest;
    });
  }
  static jwkToIonJwk({ key }) {
    let ionJwk = {};
    if ("crv" in key) {
      ionJwk.crv = key.crv;
      ionJwk.kty = key.kty;
      ionJwk.x = key.x;
      if ("d" in key)
        ionJwk.d = key.d;
      if ("y" in key && key.y) {
        return Object.assign(Object.assign({}, ionJwk), { y: key.y });
      }
      return Object.assign({}, ionJwk);
    }
    throw new Error(`jwkToIonJwk: Unsupported key algorithm.`);
  }
};
DidIonMethod.methodName = "ion";

// dist/esm/did-key.js
var import_common3 = require("@web5/common");
var import_crypto7 = require("@web5/crypto");
var __awaiter7 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupportedPublicKeyFormats = [
  "Ed25519VerificationKey2020",
  "JsonWebKey2020",
  "X25519KeyAgreementKey2020"
];
var VERIFICATION_METHOD_TYPES = {
  "Ed25519VerificationKey2020": "https://w3id.org/security/suites/ed25519-2020/v1",
  "JsonWebKey2020": "https://w3id.org/security/suites/jws-2020/v1",
  "X25519KeyAgreementKey2020": "https://w3id.org/security/suites/x25519-2020/v1"
};
var MULTICODEC_PUBLIC_KEY_LENGTH = {
  // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes
  231: 33,
  // x25519-pub - Curve25519 public key - 32 bytes
  236: 32,
  // ed25519-pub - Ed25519 public key - 32 bytes
  237: 32
};
var DidKeyMethod = class _DidKeyMethod {
  static create(options) {
    var _a, _b;
    return __awaiter7(this, void 0, void 0, function* () {
      let { enableEncryptionKeyDerivation = false, keyAlgorithm, keySet, publicKeyFormat = "JsonWebKey2020" } = options !== null && options !== void 0 ? options : {};
      if (keySet === void 0) {
        keySet = yield _DidKeyMethod.generateKeySet({ keyAlgorithm });
      }
      const portableDid = {};
      let multibaseId = "";
      if ((_b = (_a = keySet.verificationMethodKeys) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.publicKeyJwk) {
        const publicKeyJwk = keySet.verificationMethodKeys[0].publicKeyJwk;
        multibaseId = yield import_crypto7.Jose.jwkToMultibaseId({ key: publicKeyJwk });
      }
      if (!multibaseId) {
        throw new Error("DidKeyMethod: Failed to create DID with given input.");
      }
      portableDid.did = `did:key:${multibaseId}`;
      portableDid.document = yield _DidKeyMethod.createDocument({
        did: portableDid.did,
        publicKeyFormat,
        enableEncryptionKeyDerivation
      });
      portableDid.keySet = keySet;
      return portableDid;
    });
  }
  /**
   * Expands a did:key identifier to a DID Document.
   *
   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm
   *
   * @param options
   * @returns - A DID dodcument.
   */
  static createDocument(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { defaultContext = "https://www.w3.org/ns/did/v1", did, enableEncryptionKeyDerivation = false, enableExperimentalPublicKeyTypes = false, publicKeyFormat = "JsonWebKey2020" } = options;
      const document2 = {};
      let multibaseValue;
      try {
        ({ id: multibaseValue } = parseDid({ didUrl: did }));
      } catch (error) {
        throw new Error(`invalidDid: Unknown format: ${did}`);
      }
      if (!_DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      const signatureVerificationMethod = yield _DidKeyMethod.createSignatureMethod({
        did,
        enableExperimentalPublicKeyTypes,
        multibaseValue,
        publicKeyFormat
      });
      document2.id = did;
      document2.verificationMethod = [signatureVerificationMethod];
      document2.authentication = [signatureVerificationMethod.id];
      document2.assertionMethod = [signatureVerificationMethod.id];
      document2.capabilityInvocation = [signatureVerificationMethod.id];
      document2.capabilityDelegation = [signatureVerificationMethod.id];
      if (enableEncryptionKeyDerivation === true) {
        const encryptionPublicKeyFormat = publicKeyFormat === "Ed25519VerificationKey2020" ? "X25519KeyAgreementKey2020" : "JsonWebKey2020";
        const encryptionVerificationMethod = yield this.createEncryptionMethod({
          did,
          enableExperimentalPublicKeyTypes,
          multibaseValue,
          publicKeyFormat: encryptionPublicKeyFormat
        });
        document2.verificationMethod.push(encryptionVerificationMethod);
        document2.keyAgreement = [encryptionVerificationMethod.id];
      }
      const contextArray = [defaultContext];
      const verificationMethodTypes = getVerificationMethodTypes({ didDocument: document2 });
      verificationMethodTypes.forEach((typeName) => {
        const typeUrl = VERIFICATION_METHOD_TYPES[typeName];
        contextArray.push(typeUrl);
      });
      document2["@context"] = contextArray;
      return document2;
    });
  }
  /**
   * Decoding a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying that encrypted information will be
   * received by the intended recipient.
   */
  static createEncryptionMethod(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { did, enableExperimentalPublicKeyTypes, multibaseValue, publicKeyFormat } = options;
      const verificationMethod = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue } = yield _DidKeyMethod.deriveEncryptionKey({ multibaseValue });
      const actualLength = rawPublicKeyBytes.byteLength;
      const expectedLength = MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new Error(`invalidPublicKeyLength: Expected ${actualLength} bytes. Actual ${expectedLength} bytes.`);
      }
      const kemMultibaseValue = import_crypto7.utils.keyToMultibaseId({
        key: rawPublicKeyBytes,
        multicodecCode: multicodecValue
      });
      verificationMethod.id = `${did}#${kemMultibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new Error("invalidDidUrl: Verification Method ID is not a valid DID URL.");
      }
      if (!SupportedPublicKeyFormats.includes(publicKeyFormat)) {
        throw new Error(`unsupportedPublicKeyType: Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "X25519KeyAgreementKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new Error(`invalidPublicKeyType: Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = did;
      if (!_DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      if (publicKeyFormat === "X25519KeyAgreementKey2020") {
        verificationMethod.publicKeyMultibase = kemMultibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const jwkParams = yield import_crypto7.Jose.multicodecToJose({ code: multicodecValue });
        const jsonWebKey = yield import_crypto7.Jose.keyToJwk(Object.assign({ keyMaterial: rawPublicKeyBytes, keyType: "public" }, jwkParams));
        if ("x" in jsonWebKey && !("d" in jsonWebKey)) {
          verificationMethod.publicKeyJwk = jsonWebKey;
        }
      }
      return verificationMethod;
    });
  }
  /**
   * Transform a multibase-encoded multicodec value to public encryption key
   * components that are suitable for encrypting messages to a receiver. A
   * mathematical proof elaborating on the safety of performing this operation
   * is available in:
   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}
   */
  static deriveEncryptionKey(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { multibaseValue } = options;
      let publicEncryptionKey = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue } = import_crypto7.utils.multibaseIdToKey({ multibaseKeyId: multibaseValue });
      if (multicodecValue === 237) {
        const generatedPublicEncryptionKeyBytes = yield import_crypto7.Ed25519.convertPublicKeyToX25519({
          publicKey: rawPublicKeyBytes
        });
        publicEncryptionKey = {
          key: generatedPublicEncryptionKeyBytes,
          multicodecCode: 236
        };
      }
      return publicEncryptionKey;
    });
  }
  /**
   * Decodes a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying digital signatures.
   * @param options - Signature method creation algorithm inputs.
   * @returns - A verification method.
   */
  static createSignatureMethod(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { did, enableExperimentalPublicKeyTypes, multibaseValue, publicKeyFormat } = options;
      const verificationMethod = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue, multicodecName } = import_crypto7.utils.multibaseIdToKey({ multibaseKeyId: multibaseValue });
      const actualLength = rawPublicKeyBytes.byteLength;
      const expectedLength = MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new Error(`invalidPublicKeyLength: Expected ${actualLength} bytes. Actual ${expectedLength} bytes.`);
      }
      let isValid = false;
      switch (multicodecName) {
        case "secp256k1-pub":
          isValid = yield import_crypto7.Secp256k1.validatePublicKey({ key: rawPublicKeyBytes });
          break;
        case "ed25519-pub":
          isValid = yield import_crypto7.Ed25519.validatePublicKey({ key: rawPublicKeyBytes });
          break;
        case "x25519-pub":
          isValid = true;
          break;
      }
      if (!isValid) {
        throw new Error("invalidPublicKey: Invalid public key detected.");
      }
      verificationMethod.id = `${did}#${multibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new Error("invalidDidUrl: Verification Method ID is not a valid DID URL.");
      }
      if (!SupportedPublicKeyFormats.includes(publicKeyFormat)) {
        throw new Error(`unsupportedPublicKeyType: Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "Ed25519VerificationKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new Error(`invalidPublicKeyType: Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = did;
      if (!_DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      if (publicKeyFormat === "Ed25519VerificationKey2020") {
        verificationMethod.publicKeyMultibase = multibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const jwkParams = yield import_crypto7.Jose.multicodecToJose({ code: multicodecValue });
        const jsonWebKey = yield import_crypto7.Jose.keyToJwk(Object.assign({ keyMaterial: rawPublicKeyBytes, keyType: "public" }, jwkParams));
        if ("x" in jsonWebKey && !("d" in jsonWebKey)) {
          verificationMethod.publicKeyJwk = jsonWebKey;
        }
      }
      return verificationMethod;
    });
  }
  static generateKeySet(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { keyAlgorithm = "Ed25519" } = options !== null && options !== void 0 ? options : {};
      let keyPair;
      switch (keyAlgorithm) {
        case "Ed25519": {
          keyPair = yield new import_crypto7.EdDsaAlgorithm().generateKey({
            algorithm: { name: "EdDSA", namedCurve: "Ed25519" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        case "secp256k1": {
          keyPair = yield new import_crypto7.EcdsaAlgorithm().generateKey({
            algorithm: { name: "ECDSA", namedCurve: "secp256k1" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        default: {
          throw new Error(`Unsupported crypto algorithm: '${keyAlgorithm}'`);
        }
      }
      const publicKeyJwk = yield import_crypto7.Jose.cryptoKeyToJwk({ key: keyPair.publicKey });
      const privateKeyJwk = yield import_crypto7.Jose.cryptoKeyToJwk({ key: keyPair.privateKey });
      const keySet = {
        verificationMethodKeys: [{
          publicKeyJwk,
          privateKeyJwk,
          relationships: ["authentication"]
        }]
      };
      return keySet;
    });
  }
  /**
   * Given the W3C DID Document of a `did:key` DID, return the identifier of
   * the verification method key that will be used for signing messages and
   * credentials, by default.
   *
   * @param document = DID Document to get the default signing key from.
   * @returns Verification method identifier for the default signing key.
   */
  static getDefaultSigningKey(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { didDocument } = options;
      if (didDocument.authentication && Array.isArray(didDocument.authentication) && didDocument.authentication.length > 0 && typeof didDocument.authentication[0] === "string") {
        const [verificationMethodId] = didDocument.authentication;
        const signingKeyId = verificationMethodId;
        return signingKeyId;
      }
    });
  }
  static resolve(options) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { didUrl, resolutionOptions: _ } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      if (parsedDid.method !== "key") {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const didDocument = yield _DidKeyMethod.createDocument({ did: parsedDid.did });
      return {
        "@context": "https://w3id.org/did-resolution/v1",
        didDocument,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          contentType: "application/did+ld+json",
          did: {
            didString: parsedDid.did,
            methodSpecificId: parsedDid.id,
            method: parsedDid.method
          }
        }
      };
    });
  }
  static validateIdentifier(options) {
    const { did } = options;
    const { method, id: multibaseValue } = parseDid({ didUrl: did });
    const [scheme] = did.split(":", 1);
    const version = "1";
    return scheme !== "did" || method !== "key" || parseInt(version) > 0 || (0, import_common3.universalTypeOf)(multibaseValue) !== "String" || !multibaseValue.startsWith("z");
  }
};
DidKeyMethod.methodName = "key";

// dist/esm/resolver-cache-noop.js
var DidResolverCacheNoop = {
  get: function(_key) {
    return null;
  },
  set: function(_key, _value) {
    return null;
  },
  delete: function(_key) {
    return null;
  },
  clear: function() {
    return null;
  },
  close: function() {
    return null;
  }
};

// dist/esm/did-resolver.js
var __awaiter8 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidResolver = class {
  /**
   * Constructs a new `DidResolver`.
   *
   * @param options - The options for constructing the `DidResolver`.
   * @param options.didResolvers - An array of `DidMethodResolver` instances.
   * @param options.cache - Optional. A cache for storing resolved DID documents. If not provided, a no-operation cache is used.
   */
  constructor(options) {
    this.didResolvers = /* @__PURE__ */ new Map();
    this.cache = options.cache || DidResolverCacheNoop;
    for (const resolver of options.didResolvers) {
      this.didResolvers.set(resolver.methodName, resolver);
    }
  }
  /**
   * Resolves a DID to a DID Resolution Result.
   * If the DID Resolution Result is present in the cache, it returns the cached
   * result. Otherwise, it uses the appropriate method resolver to resolve
   * the DID, stores the resolution result in the cache, and returns the
   * resolultion result.
   *
   * Note: The method signature for resolve() in this implementation must match
   * the `DidResolver` implementation in
   * {@link https://github.com/TBD54566975/dwn-sdk-js | dwn-sdk-js} so that
   * Web5 apps and the underlying DWN instance can share the same DID
   * resolution cache.
   *
   * @param didUrl - The DID or DID URL to resolve.
   * @returns A promise that resolves to the DID Resolution Result.
   */
  resolve(didUrl, resolutionOptions) {
    return __awaiter8(this, void 0, void 0, function* () {
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      const resolver = this.didResolvers.get(parsedDid.method);
      if (!resolver) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const cachedResolutionResult = yield this.cache.get(parsedDid.did);
      if (cachedResolutionResult) {
        return cachedResolutionResult;
      } else {
        const resolutionResult = yield resolver.resolve({
          didUrl: parsedDid.did,
          resolutionOptions
        });
        yield this.cache.set(parsedDid.did, resolutionResult);
        return resolutionResult;
      }
    });
  }
};

// dist/esm/resolver-cache-level.js
var import_ms = __toESM(require("ms"), 1);
var import_level = require("level");
var __awaiter9 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidResolverCacheLevel = class _DidResolverCacheLevel {
  constructor(options = {}) {
    let { location, ttl } = options;
    location !== null && location !== void 0 ? location : location = _DidResolverCacheLevel.defaultOptions.location;
    ttl !== null && ttl !== void 0 ? ttl : ttl = _DidResolverCacheLevel.defaultOptions.ttl;
    this.cache = new import_level.Level(location);
    this.ttl = (0, import_ms.default)(ttl);
  }
  get(did) {
    return __awaiter9(this, void 0, void 0, function* () {
      try {
        const str3 = yield this.cache.get(did);
        const cacheWrapper = JSON.parse(str3);
        if (Date.now() >= cacheWrapper.ttlMillis) {
          this.cache.nextTick(() => this.cache.del(did));
          return;
        } else {
          return cacheWrapper.value;
        }
      } catch (error) {
        if (error.code === "LEVEL_NOT_FOUND") {
          return;
        }
        throw error;
      }
    });
  }
  set(did, value) {
    const cacheWrapper = { ttlMillis: Date.now() + this.ttl, value };
    const str3 = JSON.stringify(cacheWrapper);
    return this.cache.put(did, str3);
  }
  delete(did) {
    return this.cache.del(did);
  }
  clear() {
    return this.cache.clear();
  }
  close() {
    return this.cache.close();
  }
};
DidResolverCacheLevel.defaultOptions = {
  location: "DATA/AGENT/DID_RESOLVERCACHE",
  ttl: "15m"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DidDht,
  DidDhtMethod,
  DidIonMethod,
  DidKeyMethod,
  DidResolver,
  DidResolverCacheLevel,
  DidResolverCacheNoop,
  utils
});
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

uint8-util/util.js:
  (* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)
  *
  * @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)
  * @license  MIT
  *)

bittorrent-dht/index.js:
  (*! bittorrent-dht. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/secp256k1/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
