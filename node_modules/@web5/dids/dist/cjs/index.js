var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod3) => function __require() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);

// ../../node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS({
  "../../node_modules/uri-js/dist/es5/uri.all.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global.URI = global.URI || {});
    })(exports, function(exports2) {
      "use strict";
      function merge() {
        for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
          sets[_key] = arguments[_key];
        }
        if (sets.length > 1) {
          sets[0] = sets[0].slice(0, -1);
          var xl = sets.length - 1;
          for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
          }
          sets[xl] = sets[xl].slice(1);
          return sets.join("");
        } else {
          return sets[0];
        }
      }
      function subexp(str3) {
        return "(?:" + str3 + ")";
      }
      function typeOf(o) {
        return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
      }
      function toUpperCase(str3) {
        return str3.toUpperCase();
      }
      function toArray(obj) {
        return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
      }
      function assign(target, source) {
        var obj = target;
        if (source) {
          for (var key in source) {
            obj[key] = source[key];
          }
        }
        return obj;
      }
      function buildExps(isIRI2) {
        var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
        return {
          NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
          NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
          NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
          ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
          UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
          OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
          PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
          IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
          IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
          //RFC 6874, with relaxed parsing rules
        };
      }
      var URI_PROTOCOL = buildExps(false);
      var IRI_PROTOCOL = buildExps(true);
      var slicedToArray = function() {
        function sliceIterator(arr, i) {
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err3) {
            _d = true;
            _e = err3;
          } finally {
            try {
              if (!_n && _i["return"])
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        return function(arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();
      var toConsumableArray = function(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
            arr2[i] = arr[i];
          return arr2;
        } else {
          return Array.from(arr);
        }
      };
      var maxInt = 2147483647;
      var base = 36;
      var tMin = 1;
      var tMax = 26;
      var skew = 38;
      var damp = 700;
      var initialBias = 72;
      var initialN = 128;
      var delimiter = "-";
      var regexPunycode = /^xn--/;
      var regexNonASCII = /[^\0-\x7E]/;
      var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      };
      var baseMinusTMin = base - tMin;
      var floor = Math.floor;
      var stringFromCharCode = String.fromCharCode;
      function error$1(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var result = [];
        var length2 = array.length;
        while (length2--) {
          result[length2] = fn(array[length2]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length2 = string.length;
        while (counter < length2) {
          var value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length2) {
            var extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      var ucs2encode = function ucs2encode2(array) {
        return String.fromCodePoint.apply(String, toConsumableArray(array));
      };
      var basicToDigit = function basicToDigit2(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      };
      var digitToBasic = function digitToBasic2(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      };
      var adapt = function adapt2(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (
          ;
          /* no initialization */
          delta > baseMinusTMin * tMax >> 1;
          k += base
        ) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      };
      var decode5 = function decode6(input) {
        var output = [];
        var inputLength = input.length;
        var i = 0;
        var n = initialN;
        var bias = initialBias;
        var basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (var j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error$1("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          var oldi = i;
          for (
            var w = 1, k = base;
            ;
            /* no condition */
            k += base
          ) {
            if (index >= inputLength) {
              error$1("invalid-input");
            }
            var digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error$1("overflow");
            }
            i += digit * w;
            var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            var baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error$1("overflow");
            }
            w *= baseMinusT;
          }
          var out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error$1("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return String.fromCodePoint.apply(String, output);
      };
      var encode4 = function encode5(input) {
        var output = [];
        input = ucs2decode(input);
        var inputLength = input.length;
        var n = initialN;
        var delta = 0;
        var bias = initialBias;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _currentValue2 = _step.value;
            if (_currentValue2 < 128) {
              output.push(stringFromCharCode(_currentValue2));
            }
          }
        } catch (err3) {
          _didIteratorError = true;
          _iteratorError = err3;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
        var basicLength = output.length;
        var handledCPCount = basicLength;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          var m = maxInt;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var currentValue = _step2.value;
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }
          } catch (err3) {
            _didIteratorError2 = true;
            _iteratorError2 = err3;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error$1("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _currentValue = _step3.value;
              if (_currentValue < n && ++delta > maxInt) {
                error$1("overflow");
              }
              if (_currentValue == n) {
                var q = delta;
                for (
                  var k = base;
                  ;
                  /* no condition */
                  k += base
                ) {
                  var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  var qMinusT = q - t;
                  var baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }
                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }
          } catch (err3) {
            _didIteratorError3 = true;
            _iteratorError3 = err3;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      };
      var toUnicode = function toUnicode2(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode5(string.slice(4).toLowerCase()) : string;
        });
      };
      var toASCII = function toASCII2(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode4(string) : string;
        });
      };
      var punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "2.1.0",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode5,
        "encode": encode4,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      var SCHEMES = {};
      function pctEncChar(chr) {
        var c = chr.charCodeAt(0);
        var e = void 0;
        if (c < 16)
          e = "%0" + c.toString(16).toUpperCase();
        else if (c < 128)
          e = "%" + c.toString(16).toUpperCase();
        else if (c < 2048)
          e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        else
          e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
        return e;
      }
      function pctDecChars(str3) {
        var newStr = "";
        var i = 0;
        var il = str3.length;
        while (i < il) {
          var c = parseInt(str3.substr(i + 1, 2), 16);
          if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
          } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
              var c2 = parseInt(str3.substr(i + 4, 2), 16);
              newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
              newStr += str3.substr(i, 6);
            }
            i += 6;
          } else if (c >= 224) {
            if (il - i >= 9) {
              var _c = parseInt(str3.substr(i + 4, 2), 16);
              var c3 = parseInt(str3.substr(i + 7, 2), 16);
              newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
              newStr += str3.substr(i, 9);
            }
            i += 9;
          } else {
            newStr += str3.substr(i, 3);
            i += 3;
          }
        }
        return newStr;
      }
      function _normalizeComponentEncoding(components, protocol) {
        function decodeUnreserved2(str3) {
          var decStr = pctDecChars(str3);
          return !decStr.match(protocol.UNRESERVED) ? str3 : decStr;
        }
        if (components.scheme)
          components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
        if (components.userinfo !== void 0)
          components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.host !== void 0)
          components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.path !== void 0)
          components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.query !== void 0)
          components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        if (components.fragment !== void 0)
          components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
        return components;
      }
      function _stripLeadingZeros(str3) {
        return str3.replace(/^0*(.*)/, "$1") || "0";
      }
      function _normalizeIPv4(host, protocol) {
        var matches = host.match(protocol.IPV4ADDRESS) || [];
        var _matches = slicedToArray(matches, 2), address = _matches[1];
        if (address) {
          return address.split(".").map(_stripLeadingZeros).join(".");
        } else {
          return host;
        }
      }
      function _normalizeIPv6(host, protocol) {
        var matches = host.match(protocol.IPV6ADDRESS) || [];
        var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
        if (address) {
          var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
          var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
          var lastFields = last.split(":").map(_stripLeadingZeros);
          var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
          var fieldCount = isLastFieldIPv4Address ? 7 : 8;
          var lastFieldsStart = lastFields.length - fieldCount;
          var fields = Array(fieldCount);
          for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
          }
          if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
          }
          var allZeroFields = fields.reduce(function(acc, field, index) {
            if (!field || field === "0") {
              var lastLongest = acc[acc.length - 1];
              if (lastLongest && lastLongest.index + lastLongest.length === index) {
                lastLongest.length++;
              } else {
                acc.push({ index, length: 1 });
              }
            }
            return acc;
          }, []);
          var longestZeroFields = allZeroFields.sort(function(a, b) {
            return b.length - a.length;
          })[0];
          var newHost = void 0;
          if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
          } else {
            newHost = fields.join(":");
          }
          if (zone) {
            newHost += "%" + zone;
          }
          return newHost;
        } else {
          return host;
        }
      }
      var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
      var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
      function parse3(uriString) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var components = {};
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        if (options.reference === "suffix")
          uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
        var matches = uriString.match(URI_PARSE);
        if (matches) {
          if (NO_MATCH_IS_UNDEFINED) {
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            if (isNaN(components.port)) {
              components.port = matches[5];
            }
          } else {
            components.scheme = matches[1] || void 0;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
            if (isNaN(components.port)) {
              components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
            }
          }
          if (components.host) {
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
          }
          if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
            components.reference = "same-document";
          } else if (components.scheme === void 0) {
            components.reference = "relative";
          } else if (components.fragment === void 0) {
            components.reference = "absolute";
          } else {
            components.reference = "uri";
          }
          if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
          }
          var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
          if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
              try {
                components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
              } catch (e) {
                components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
              }
            }
            _normalizeComponentEncoding(components, URI_PROTOCOL);
          } else {
            _normalizeComponentEncoding(components, protocol);
          }
          if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
          }
        } else {
          components.error = components.error || "URI can not be parsed.";
        }
        return components;
      }
      function _recomposeAuthority(components, options) {
        var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        if (components.userinfo !== void 0) {
          uriTokens.push(components.userinfo);
          uriTokens.push("@");
        }
        if (components.host !== void 0) {
          uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
          }));
        }
        if (typeof components.port === "number" || typeof components.port === "string") {
          uriTokens.push(":");
          uriTokens.push(String(components.port));
        }
        return uriTokens.length ? uriTokens.join("") : void 0;
      }
      var RDS1 = /^\.\.?\//;
      var RDS2 = /^\/\.(\/|$)/;
      var RDS3 = /^\/\.\.(\/|$)/;
      var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
      function removeDotSegments(input) {
        var output = [];
        while (input.length) {
          if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
          } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
          } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
          } else if (input === "." || input === "..") {
            input = "";
          } else {
            var im = input.match(RDS5);
            if (im) {
              var s = im[0];
              input = input.slice(s.length);
              output.push(s);
            } else {
              throw new Error("Unexpected dot segment condition");
            }
          }
        }
        return output.join("");
      }
      function serialize(components) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
        var uriTokens = [];
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (schemeHandler && schemeHandler.serialize)
          schemeHandler.serialize(components, options);
        if (components.host) {
          if (protocol.IPV6ADDRESS.test(components.host)) {
          } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
            try {
              components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
          }
        }
        _normalizeComponentEncoding(components, protocol);
        if (options.reference !== "suffix" && components.scheme) {
          uriTokens.push(components.scheme);
          uriTokens.push(":");
        }
        var authority = _recomposeAuthority(components, options);
        if (authority !== void 0) {
          if (options.reference !== "suffix") {
            uriTokens.push("//");
          }
          uriTokens.push(authority);
          if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
          }
        }
        if (components.path !== void 0) {
          var s = components.path;
          if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
          }
          if (authority === void 0) {
            s = s.replace(/^\/\//, "/%2F");
          }
          uriTokens.push(s);
        }
        if (components.query !== void 0) {
          uriTokens.push("?");
          uriTokens.push(components.query);
        }
        if (components.fragment !== void 0) {
          uriTokens.push("#");
          uriTokens.push(components.fragment);
        }
        return uriTokens.join("");
      }
      function resolveComponents(base2, relative) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var skipNormalization = arguments[3];
        var target = {};
        if (!skipNormalization) {
          base2 = parse3(serialize(base2, options), options);
          relative = parse3(serialize(relative, options), options);
        }
        options = options || {};
        if (!options.tolerant && relative.scheme) {
          target.scheme = relative.scheme;
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
          } else {
            if (!relative.path) {
              target.path = base2.path;
              if (relative.query !== void 0) {
                target.query = relative.query;
              } else {
                target.query = base2.query;
              }
            } else {
              if (relative.path.charAt(0) === "/") {
                target.path = removeDotSegments(relative.path);
              } else {
                if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                  target.path = "/" + relative.path;
                } else if (!base2.path) {
                  target.path = relative.path;
                } else {
                  target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
                }
                target.path = removeDotSegments(target.path);
              }
              target.query = relative.query;
            }
            target.userinfo = base2.userinfo;
            target.host = base2.host;
            target.port = base2.port;
          }
          target.scheme = base2.scheme;
        }
        target.fragment = relative.fragment;
        return target;
      }
      function resolve(baseURI, relativeURI, options) {
        var schemelessOptions = assign({ scheme: "null" }, options);
        return serialize(resolveComponents(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
      }
      function normalize(uri, options) {
        if (typeof uri === "string") {
          uri = serialize(parse3(uri, options), options);
        } else if (typeOf(uri) === "object") {
          uri = parse3(serialize(uri, options), options);
        }
        return uri;
      }
      function equal(uriA, uriB, options) {
        if (typeof uriA === "string") {
          uriA = serialize(parse3(uriA, options), options);
        } else if (typeOf(uriA) === "object") {
          uriA = serialize(uriA, options);
        }
        if (typeof uriB === "string") {
          uriB = serialize(parse3(uriB, options), options);
        } else if (typeOf(uriB) === "object") {
          uriB = serialize(uriB, options);
        }
        return uriA === uriB;
      }
      function escapeComponent(str3, options) {
        return str3 && str3.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
      }
      function unescapeComponent(str3, options) {
        return str3 && str3.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
      }
      var handler = {
        scheme: "http",
        domainHost: true,
        parse: function parse4(components, options) {
          if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
          }
          return components;
        },
        serialize: function serialize2(components, options) {
          var secure = String(components.scheme).toLowerCase() === "https";
          if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = void 0;
          }
          if (!components.path) {
            components.path = "/";
          }
          return components;
        }
      };
      var handler$1 = {
        scheme: "https",
        domainHost: handler.domainHost,
        parse: handler.parse,
        serialize: handler.serialize
      };
      function isSecure(wsComponents) {
        return typeof wsComponents.secure === "boolean" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
      }
      var handler$2 = {
        scheme: "ws",
        domainHost: true,
        parse: function parse4(components, options) {
          var wsComponents = components;
          wsComponents.secure = isSecure(wsComponents);
          wsComponents.resourceName = (wsComponents.path || "/") + (wsComponents.query ? "?" + wsComponents.query : "");
          wsComponents.path = void 0;
          wsComponents.query = void 0;
          return wsComponents;
        },
        serialize: function serialize2(wsComponents, options) {
          if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = void 0;
          }
          if (typeof wsComponents.secure === "boolean") {
            wsComponents.scheme = wsComponents.secure ? "wss" : "ws";
            wsComponents.secure = void 0;
          }
          if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split("?"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];
            wsComponents.path = path && path !== "/" ? path : void 0;
            wsComponents.query = query;
            wsComponents.resourceName = void 0;
          }
          wsComponents.fragment = void 0;
          return wsComponents;
        }
      };
      var handler$3 = {
        scheme: "wss",
        domainHost: handler$2.domainHost,
        parse: handler$2.parse,
        serialize: handler$2.serialize
      };
      var O = {};
      var isIRI = true;
      var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
      var HEXDIG$$ = "[0-9A-Fa-f]";
      var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
      var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
      var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
      var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
      var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
      var UNRESERVED = new RegExp(UNRESERVED$$, "g");
      var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
      var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
      var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
      var NOT_HFVALUE = NOT_HFNAME;
      function decodeUnreserved(str3) {
        var decStr = pctDecChars(str3);
        return !decStr.match(UNRESERVED) ? str3 : decStr;
      }
      var handler$4 = {
        scheme: "mailto",
        parse: function parse$$1(components, options) {
          var mailtoComponents = components;
          var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
          mailtoComponents.path = void 0;
          if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
              var hfield = hfields[x].split("=");
              switch (hfield[0]) {
                case "to":
                  var toAddrs = hfield[1].split(",");
                  for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                    to.push(toAddrs[_x]);
                  }
                  break;
                case "subject":
                  mailtoComponents.subject = unescapeComponent(hfield[1], options);
                  break;
                case "body":
                  mailtoComponents.body = unescapeComponent(hfield[1], options);
                  break;
                default:
                  unknownHeaders = true;
                  headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                  break;
              }
            }
            if (unknownHeaders)
              mailtoComponents.headers = headers;
          }
          mailtoComponents.query = void 0;
          for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
              try {
                addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
              } catch (e) {
                mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
              }
            } else {
              addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
          }
          return mailtoComponents;
        },
        serialize: function serialize$$1(mailtoComponents, options) {
          var components = mailtoComponents;
          var to = toArray(mailtoComponents.to);
          if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
              var toAddr = String(to[x]);
              var atIdx = toAddr.lastIndexOf("@");
              var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
              var domain = toAddr.slice(atIdx + 1);
              try {
                domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
              } catch (e) {
                components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
              }
              to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
          }
          var headers = mailtoComponents.headers = mailtoComponents.headers || {};
          if (mailtoComponents.subject)
            headers["subject"] = mailtoComponents.subject;
          if (mailtoComponents.body)
            headers["body"] = mailtoComponents.body;
          var fields = [];
          for (var name in headers) {
            if (headers[name] !== O[name]) {
              fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
          }
          if (fields.length) {
            components.query = fields.join("&");
          }
          return components;
        }
      };
      var URN_PARSE = /^([^\:]+)\:(.*)/;
      var handler$5 = {
        scheme: "urn",
        parse: function parse$$1(components, options) {
          var matches = components.path && components.path.match(URN_PARSE);
          var urnComponents = components;
          if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = void 0;
            if (schemeHandler) {
              urnComponents = schemeHandler.parse(urnComponents, options);
            }
          } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
          }
          return urnComponents;
        },
        serialize: function serialize$$1(urnComponents, options) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = urnComponents.nid;
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
          }
          var uriComponents = urnComponents;
          var nss = urnComponents.nss;
          uriComponents.path = (nid || options.nid) + ":" + nss;
          return uriComponents;
        }
      };
      var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
      var handler$6 = {
        scheme: "urn:uuid",
        parse: function parse4(urnComponents, options) {
          var uuidComponents = urnComponents;
          uuidComponents.uuid = uuidComponents.nss;
          uuidComponents.nss = void 0;
          if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
          }
          return uuidComponents;
        },
        serialize: function serialize2(uuidComponents, options) {
          var urnComponents = uuidComponents;
          urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
          return urnComponents;
        }
      };
      SCHEMES[handler.scheme] = handler;
      SCHEMES[handler$1.scheme] = handler$1;
      SCHEMES[handler$2.scheme] = handler$2;
      SCHEMES[handler$3.scheme] = handler$3;
      SCHEMES[handler$4.scheme] = handler$4;
      SCHEMES[handler$5.scheme] = handler$5;
      SCHEMES[handler$6.scheme] = handler$6;
      exports2.SCHEMES = SCHEMES;
      exports2.pctEncChar = pctEncChar;
      exports2.pctDecChars = pctDecChars;
      exports2.parse = parse3;
      exports2.removeDotSegments = removeDotSegments;
      exports2.serialize = serialize;
      exports2.resolveComponents = resolveComponents;
      exports2.resolve = resolve;
      exports2.normalize = normalize;
      exports2.equal = equal;
      exports2.escapeComponent = escapeComponent;
      exports2.unescapeComponent = unescapeComponent;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@multiformats/base-x/src/index.js
var require_src = __commonJS({
  "../../node_modules/@multiformats/base-x/src/index.js"(exports, module2) {
    "use strict";
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode4(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str3 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str3 += ALPHABET.charAt(b58[it2]);
        }
        return str3;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode5(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode: encode4,
        decodeUnsafe,
        decode: decode5
      };
    }
    module2.exports = base;
  }
});

// ../../node_modules/multibase/src/util.js
var require_util = __commonJS({
  "../../node_modules/multibase/src/util.js"(exports, module2) {
    "use strict";
    var textDecoder = new TextDecoder();
    var decodeText = (bytes) => textDecoder.decode(bytes);
    var textEncoder = new TextEncoder();
    var encodeText = (text) => textEncoder.encode(text);
    function concat(arrs, length2) {
      const output = new Uint8Array(length2);
      let offset = 0;
      for (const arr of arrs) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    module2.exports = { decodeText, encodeText, concat };
  }
});

// ../../node_modules/multibase/src/base.js
var require_base = __commonJS({
  "../../node_modules/multibase/src/base.js"(exports, module2) {
    "use strict";
    var { encodeText } = require_util();
    var Base = class {
      /**
       * @param {BaseName} name
       * @param {BaseCode} code
       * @param {CodecFactory} factory
       * @param {string} alphabet
       */
      constructor(name, code, factory, alphabet) {
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
      }
      /**
       * @param {Uint8Array} buf
       * @returns {string}
       */
      encode(buf) {
        return this.codec.encode(buf);
      }
      /**
       * @param {string} string
       * @returns {Uint8Array}
       */
      decode(string) {
        for (const char of string) {
          if (this.alphabet && this.alphabet.indexOf(char) < 0) {
            throw new Error(`invalid character '${char}' in '${string}'`);
          }
        }
        return this.codec.decode(string);
      }
    };
    module2.exports = Base;
  }
});

// ../../node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS({
  "../../node_modules/multibase/src/rfc4648.js"(exports, module2) {
    "use strict";
    var decode5 = (string, alphabet, bitsPerChar) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError("Invalid character " + string[i]);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode4 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = (bitsPerChar) => (alphabet) => {
      return {
        /**
         * @param {Uint8Array} input
         * @returns {string}
         */
        encode(input) {
          return encode4(input, alphabet, bitsPerChar);
        },
        /**
         * @param {string} input
         * @returns {Uint8Array}
         */
        decode(input) {
          return decode5(input, alphabet, bitsPerChar);
        }
      };
    };
    module2.exports = { rfc4648: rfc46482 };
  }
});

// ../../node_modules/multibase/src/constants.js
var require_constants = __commonJS({
  "../../node_modules/multibase/src/constants.js"(exports, module2) {
    "use strict";
    var baseX = require_src();
    var Base = require_base();
    var { rfc4648: rfc46482 } = require_rfc4648();
    var { decodeText, encodeText } = require_util();
    var identity = () => {
      return {
        encode: decodeText,
        decode: encodeText
      };
    };
    var constants = [
      ["identity", "\0", identity, ""],
      ["base2", "0", rfc46482(1), "01"],
      ["base8", "7", rfc46482(3), "01234567"],
      ["base10", "9", baseX, "0123456789"],
      ["base16", "f", rfc46482(4), "0123456789abcdef"],
      ["base16upper", "F", rfc46482(4), "0123456789ABCDEF"],
      ["base32hex", "v", rfc46482(5), "0123456789abcdefghijklmnopqrstuv"],
      ["base32hexupper", "V", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
      ["base32hexpad", "t", rfc46482(5), "0123456789abcdefghijklmnopqrstuv="],
      ["base32hexpadupper", "T", rfc46482(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
      ["base32", "b", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567"],
      ["base32upper", "B", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
      ["base32pad", "c", rfc46482(5), "abcdefghijklmnopqrstuvwxyz234567="],
      ["base32padupper", "C", rfc46482(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
      ["base32z", "h", rfc46482(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
      ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
      ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
      ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
      ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
      ["base64", "m", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
      ["base64pad", "M", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
      ["base64url", "u", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
      ["base64urlpad", "U", rfc46482(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
    ];
    var names = constants.reduce(
      (prev, tupple) => {
        prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
        return prev;
      },
      /** @type {Record<BaseName,Base>} */
      {}
    );
    var codes = constants.reduce(
      (prev, tupple) => {
        prev[tupple[1]] = names[tupple[0]];
        return prev;
      },
      /** @type {Record<BaseCode,Base>} */
      {}
    );
    module2.exports = {
      names,
      codes
    };
  }
});

// ../../node_modules/multibase/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/multibase/src/index.js"(exports, module2) {
    "use strict";
    var constants = require_constants();
    var { encodeText, decodeText, concat } = require_util();
    function multibase(nameOrCode, buf) {
      if (!buf) {
        throw new Error("requires an encoded Uint8Array");
      }
      const { name, codeBuf } = encoding(nameOrCode);
      validEncode(name, buf);
      return concat([codeBuf, buf], codeBuf.length + buf.length);
    }
    function encode4(nameOrCode, buf) {
      const enc = encoding(nameOrCode);
      const data = encodeText(enc.encode(buf));
      return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
    }
    function decode5(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      const prefix = data[0];
      if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
        data = data.toLowerCase();
      }
      const enc = encoding(
        /** @type {BaseCode} */
        data[0]
      );
      return enc.decode(data.substring(1));
    }
    function isEncoded(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      if (Object.prototype.toString.call(data) !== "[object String]") {
        return false;
      }
      try {
        const enc = encoding(
          /** @type {BaseCode} */
          data[0]
        );
        return enc.name;
      } catch (err3) {
        return false;
      }
    }
    function validEncode(name, buf) {
      const enc = encoding(name);
      enc.decode(decodeText(buf));
    }
    function encoding(nameOrCode) {
      if (Object.prototype.hasOwnProperty.call(
        constants.names,
        /** @type {BaseName} */
        nameOrCode
      )) {
        return constants.names[
          /** @type {BaseName} */
          nameOrCode
        ];
      } else if (Object.prototype.hasOwnProperty.call(
        constants.codes,
        /** @type {BaseCode} */
        nameOrCode
      )) {
        return constants.codes[
          /** @type {BaseCode} */
          nameOrCode
        ];
      } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
      }
    }
    function encodingFromData(data) {
      if (data instanceof Uint8Array) {
        data = decodeText(data);
      }
      return encoding(
        /** @type {BaseCode} */
        data[0]
      );
    }
    exports = module2.exports = multibase;
    exports.encode = encode4;
    exports.decode = decode5;
    exports.isEncoded = isEncoded;
    exports.encoding = encoding;
    exports.encodingFromData = encodingFromData;
    var names = Object.freeze(constants.names);
    var codes = Object.freeze(constants.codes);
    exports.names = names;
    exports.codes = codes;
  }
});

// ../../node_modules/multihashes/node_modules/varint/encode.js
var require_encode = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/encode.js"(exports, module2) {
    module2.exports = encode4;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode4(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode4.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// ../../node_modules/multihashes/node_modules/varint/decode.js
var require_decode = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/decode.js"(exports, module2) {
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// ../../node_modules/multihashes/node_modules/varint/length.js
var require_length = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/length.js"(exports, module2) {
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// ../../node_modules/multihashes/node_modules/varint/index.js
var require_varint = __commonJS({
  "../../node_modules/multihashes/node_modules/varint/index.js"(exports, module2) {
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// ../../node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/multihashes/src/constants.js"(exports, module2) {
    "use strict";
    var names = Object.freeze({
      "identity": 0,
      "sha1": 17,
      "sha2-256": 18,
      "sha2-512": 19,
      "sha3-512": 20,
      "sha3-384": 21,
      "sha3-256": 22,
      "sha3-224": 23,
      "shake-128": 24,
      "shake-256": 25,
      "keccak-224": 26,
      "keccak-256": 27,
      "keccak-384": 28,
      "keccak-512": 29,
      "blake3": 30,
      "murmur3-128": 34,
      "murmur3-32": 35,
      "dbl-sha2-256": 86,
      "md4": 212,
      "md5": 213,
      "bmt": 214,
      "sha2-256-trunc254-padded": 4114,
      "ripemd-128": 4178,
      "ripemd-160": 4179,
      "ripemd-256": 4180,
      "ripemd-320": 4181,
      "x11": 4352,
      "kangarootwelve": 7425,
      "sm3-256": 21325,
      "blake2b-8": 45569,
      "blake2b-16": 45570,
      "blake2b-24": 45571,
      "blake2b-32": 45572,
      "blake2b-40": 45573,
      "blake2b-48": 45574,
      "blake2b-56": 45575,
      "blake2b-64": 45576,
      "blake2b-72": 45577,
      "blake2b-80": 45578,
      "blake2b-88": 45579,
      "blake2b-96": 45580,
      "blake2b-104": 45581,
      "blake2b-112": 45582,
      "blake2b-120": 45583,
      "blake2b-128": 45584,
      "blake2b-136": 45585,
      "blake2b-144": 45586,
      "blake2b-152": 45587,
      "blake2b-160": 45588,
      "blake2b-168": 45589,
      "blake2b-176": 45590,
      "blake2b-184": 45591,
      "blake2b-192": 45592,
      "blake2b-200": 45593,
      "blake2b-208": 45594,
      "blake2b-216": 45595,
      "blake2b-224": 45596,
      "blake2b-232": 45597,
      "blake2b-240": 45598,
      "blake2b-248": 45599,
      "blake2b-256": 45600,
      "blake2b-264": 45601,
      "blake2b-272": 45602,
      "blake2b-280": 45603,
      "blake2b-288": 45604,
      "blake2b-296": 45605,
      "blake2b-304": 45606,
      "blake2b-312": 45607,
      "blake2b-320": 45608,
      "blake2b-328": 45609,
      "blake2b-336": 45610,
      "blake2b-344": 45611,
      "blake2b-352": 45612,
      "blake2b-360": 45613,
      "blake2b-368": 45614,
      "blake2b-376": 45615,
      "blake2b-384": 45616,
      "blake2b-392": 45617,
      "blake2b-400": 45618,
      "blake2b-408": 45619,
      "blake2b-416": 45620,
      "blake2b-424": 45621,
      "blake2b-432": 45622,
      "blake2b-440": 45623,
      "blake2b-448": 45624,
      "blake2b-456": 45625,
      "blake2b-464": 45626,
      "blake2b-472": 45627,
      "blake2b-480": 45628,
      "blake2b-488": 45629,
      "blake2b-496": 45630,
      "blake2b-504": 45631,
      "blake2b-512": 45632,
      "blake2s-8": 45633,
      "blake2s-16": 45634,
      "blake2s-24": 45635,
      "blake2s-32": 45636,
      "blake2s-40": 45637,
      "blake2s-48": 45638,
      "blake2s-56": 45639,
      "blake2s-64": 45640,
      "blake2s-72": 45641,
      "blake2s-80": 45642,
      "blake2s-88": 45643,
      "blake2s-96": 45644,
      "blake2s-104": 45645,
      "blake2s-112": 45646,
      "blake2s-120": 45647,
      "blake2s-128": 45648,
      "blake2s-136": 45649,
      "blake2s-144": 45650,
      "blake2s-152": 45651,
      "blake2s-160": 45652,
      "blake2s-168": 45653,
      "blake2s-176": 45654,
      "blake2s-184": 45655,
      "blake2s-192": 45656,
      "blake2s-200": 45657,
      "blake2s-208": 45658,
      "blake2s-216": 45659,
      "blake2s-224": 45660,
      "blake2s-232": 45661,
      "blake2s-240": 45662,
      "blake2s-248": 45663,
      "blake2s-256": 45664,
      "skein256-8": 45825,
      "skein256-16": 45826,
      "skein256-24": 45827,
      "skein256-32": 45828,
      "skein256-40": 45829,
      "skein256-48": 45830,
      "skein256-56": 45831,
      "skein256-64": 45832,
      "skein256-72": 45833,
      "skein256-80": 45834,
      "skein256-88": 45835,
      "skein256-96": 45836,
      "skein256-104": 45837,
      "skein256-112": 45838,
      "skein256-120": 45839,
      "skein256-128": 45840,
      "skein256-136": 45841,
      "skein256-144": 45842,
      "skein256-152": 45843,
      "skein256-160": 45844,
      "skein256-168": 45845,
      "skein256-176": 45846,
      "skein256-184": 45847,
      "skein256-192": 45848,
      "skein256-200": 45849,
      "skein256-208": 45850,
      "skein256-216": 45851,
      "skein256-224": 45852,
      "skein256-232": 45853,
      "skein256-240": 45854,
      "skein256-248": 45855,
      "skein256-256": 45856,
      "skein512-8": 45857,
      "skein512-16": 45858,
      "skein512-24": 45859,
      "skein512-32": 45860,
      "skein512-40": 45861,
      "skein512-48": 45862,
      "skein512-56": 45863,
      "skein512-64": 45864,
      "skein512-72": 45865,
      "skein512-80": 45866,
      "skein512-88": 45867,
      "skein512-96": 45868,
      "skein512-104": 45869,
      "skein512-112": 45870,
      "skein512-120": 45871,
      "skein512-128": 45872,
      "skein512-136": 45873,
      "skein512-144": 45874,
      "skein512-152": 45875,
      "skein512-160": 45876,
      "skein512-168": 45877,
      "skein512-176": 45878,
      "skein512-184": 45879,
      "skein512-192": 45880,
      "skein512-200": 45881,
      "skein512-208": 45882,
      "skein512-216": 45883,
      "skein512-224": 45884,
      "skein512-232": 45885,
      "skein512-240": 45886,
      "skein512-248": 45887,
      "skein512-256": 45888,
      "skein512-264": 45889,
      "skein512-272": 45890,
      "skein512-280": 45891,
      "skein512-288": 45892,
      "skein512-296": 45893,
      "skein512-304": 45894,
      "skein512-312": 45895,
      "skein512-320": 45896,
      "skein512-328": 45897,
      "skein512-336": 45898,
      "skein512-344": 45899,
      "skein512-352": 45900,
      "skein512-360": 45901,
      "skein512-368": 45902,
      "skein512-376": 45903,
      "skein512-384": 45904,
      "skein512-392": 45905,
      "skein512-400": 45906,
      "skein512-408": 45907,
      "skein512-416": 45908,
      "skein512-424": 45909,
      "skein512-432": 45910,
      "skein512-440": 45911,
      "skein512-448": 45912,
      "skein512-456": 45913,
      "skein512-464": 45914,
      "skein512-472": 45915,
      "skein512-480": 45916,
      "skein512-488": 45917,
      "skein512-496": 45918,
      "skein512-504": 45919,
      "skein512-512": 45920,
      "skein1024-8": 45921,
      "skein1024-16": 45922,
      "skein1024-24": 45923,
      "skein1024-32": 45924,
      "skein1024-40": 45925,
      "skein1024-48": 45926,
      "skein1024-56": 45927,
      "skein1024-64": 45928,
      "skein1024-72": 45929,
      "skein1024-80": 45930,
      "skein1024-88": 45931,
      "skein1024-96": 45932,
      "skein1024-104": 45933,
      "skein1024-112": 45934,
      "skein1024-120": 45935,
      "skein1024-128": 45936,
      "skein1024-136": 45937,
      "skein1024-144": 45938,
      "skein1024-152": 45939,
      "skein1024-160": 45940,
      "skein1024-168": 45941,
      "skein1024-176": 45942,
      "skein1024-184": 45943,
      "skein1024-192": 45944,
      "skein1024-200": 45945,
      "skein1024-208": 45946,
      "skein1024-216": 45947,
      "skein1024-224": 45948,
      "skein1024-232": 45949,
      "skein1024-240": 45950,
      "skein1024-248": 45951,
      "skein1024-256": 45952,
      "skein1024-264": 45953,
      "skein1024-272": 45954,
      "skein1024-280": 45955,
      "skein1024-288": 45956,
      "skein1024-296": 45957,
      "skein1024-304": 45958,
      "skein1024-312": 45959,
      "skein1024-320": 45960,
      "skein1024-328": 45961,
      "skein1024-336": 45962,
      "skein1024-344": 45963,
      "skein1024-352": 45964,
      "skein1024-360": 45965,
      "skein1024-368": 45966,
      "skein1024-376": 45967,
      "skein1024-384": 45968,
      "skein1024-392": 45969,
      "skein1024-400": 45970,
      "skein1024-408": 45971,
      "skein1024-416": 45972,
      "skein1024-424": 45973,
      "skein1024-432": 45974,
      "skein1024-440": 45975,
      "skein1024-448": 45976,
      "skein1024-456": 45977,
      "skein1024-464": 45978,
      "skein1024-472": 45979,
      "skein1024-480": 45980,
      "skein1024-488": 45981,
      "skein1024-496": 45982,
      "skein1024-504": 45983,
      "skein1024-512": 45984,
      "skein1024-520": 45985,
      "skein1024-528": 45986,
      "skein1024-536": 45987,
      "skein1024-544": 45988,
      "skein1024-552": 45989,
      "skein1024-560": 45990,
      "skein1024-568": 45991,
      "skein1024-576": 45992,
      "skein1024-584": 45993,
      "skein1024-592": 45994,
      "skein1024-600": 45995,
      "skein1024-608": 45996,
      "skein1024-616": 45997,
      "skein1024-624": 45998,
      "skein1024-632": 45999,
      "skein1024-640": 46e3,
      "skein1024-648": 46001,
      "skein1024-656": 46002,
      "skein1024-664": 46003,
      "skein1024-672": 46004,
      "skein1024-680": 46005,
      "skein1024-688": 46006,
      "skein1024-696": 46007,
      "skein1024-704": 46008,
      "skein1024-712": 46009,
      "skein1024-720": 46010,
      "skein1024-728": 46011,
      "skein1024-736": 46012,
      "skein1024-744": 46013,
      "skein1024-752": 46014,
      "skein1024-760": 46015,
      "skein1024-768": 46016,
      "skein1024-776": 46017,
      "skein1024-784": 46018,
      "skein1024-792": 46019,
      "skein1024-800": 46020,
      "skein1024-808": 46021,
      "skein1024-816": 46022,
      "skein1024-824": 46023,
      "skein1024-832": 46024,
      "skein1024-840": 46025,
      "skein1024-848": 46026,
      "skein1024-856": 46027,
      "skein1024-864": 46028,
      "skein1024-872": 46029,
      "skein1024-880": 46030,
      "skein1024-888": 46031,
      "skein1024-896": 46032,
      "skein1024-904": 46033,
      "skein1024-912": 46034,
      "skein1024-920": 46035,
      "skein1024-928": 46036,
      "skein1024-936": 46037,
      "skein1024-944": 46038,
      "skein1024-952": 46039,
      "skein1024-960": 46040,
      "skein1024-968": 46041,
      "skein1024-976": 46042,
      "skein1024-984": 46043,
      "skein1024-992": 46044,
      "skein1024-1000": 46045,
      "skein1024-1008": 46046,
      "skein1024-1016": 46047,
      "skein1024-1024": 46048,
      "poseidon-bls12_381-a2-fc1": 46081,
      "poseidon-bls12_381-a2-fc1-sc": 46082
    });
    module2.exports = { names };
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/vendor/base-x.js
var require_base_x = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/vendor/base-x.js"(exports, module2) {
    "use strict";
    function base(ALPHABET, name) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode4(source) {
        if (source instanceof Uint8Array)
          ;
        else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          pbegin++;
        }
        var it2 = size - length2;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str3 = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str3 += ALPHABET.charAt(b58[it2]);
        }
        return str3;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
          return;
        }
        var zeroes = 0;
        var length2 = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length2 = i2;
          psz++;
        }
        if (source[psz] === " ") {
          return;
        }
        var it4 = size - length2;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode5(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
          return buffer;
        }
        throw new Error(`Non-${name} character`);
      }
      return {
        encode: encode4,
        decodeUnsafe,
        decode: decode5
      };
    }
    var src = base;
    var _brrp__multiformats_scope_baseX = src;
    module2.exports = _brrp__multiformats_scope_baseX;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bytes.js
var require_bytes = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var empty2 = new Uint8Array(0);
    var toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    var fromHex = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty2;
    };
    var equals2 = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    var coerce2 = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    var isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    var fromString = (str3) => new TextEncoder().encode(str3);
    var toString = (b) => new TextDecoder().decode(b);
    exports.coerce = coerce2;
    exports.empty = empty2;
    exports.equals = equals2;
    exports.fromHex = fromHex;
    exports.fromString = fromString;
    exports.isBinary = isBinary;
    exports.toHex = toHex;
    exports.toString = toString;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base.js
var require_base2 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var baseX$1 = require_base_x();
    var bytes = require_bytes();
    var Encoder3 = class {
      constructor(name, prefix, baseEncode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes2) {
        if (bytes2 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes2)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    var Decoder2 = class {
      constructor(name, prefix, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
          throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = prefix.codePointAt(0);
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
          }
          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        return or2(this, decoder);
      }
    };
    var ComposedDecoder2 = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        return or2(this, decoder);
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    var or2 = (left, right) => new ComposedDecoder2({
      ...left.decoders || { [left.prefix]: left },
      ...right.decoders || { [right.prefix]: right }
    });
    var Codec2 = class {
      constructor(name, prefix, baseEncode, baseDecode) {
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder3(name, prefix, baseEncode);
        this.decoder = new Decoder2(name, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    var from3 = ({ name, prefix, encode: encode5, decode: decode6 }) => new Codec2(name, prefix, encode5, decode6);
    var baseX = ({ prefix, name, alphabet }) => {
      const { encode: encode5, decode: decode6 } = baseX$1(alphabet, name);
      return from3({
        prefix,
        name,
        encode: encode5,
        decode: (text) => bytes.coerce(decode6(text))
      });
    };
    var decode5 = (string, alphabet, bitsPerChar, name) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string.length;
      while (string[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    var encode4 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer = buffer << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    var rfc46482 = ({ name, prefix, bitsPerChar, alphabet }) => {
      return from3({
        prefix,
        name,
        encode(input) {
          return encode4(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode5(input, alphabet, bitsPerChar, name);
        }
      });
    };
    exports.Codec = Codec2;
    exports.baseX = baseX;
    exports.from = from3;
    exports.or = or2;
    exports.rfc4648 = rfc46482;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/identity.js
var require_identity = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var bytes = require_bytes();
    var identity = base.from({
      prefix: "\0",
      name: "identity",
      encode: (buf) => bytes.toString(buf),
      decode: (str3) => bytes.fromString(str3)
    });
    exports.identity = identity;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base2.js
var require_base22 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base2 = base.rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
    exports.base2 = base2;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base8.js
var require_base8 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base8 = base.rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
    exports.base8 = base8;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base10.js
var require_base10 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base10.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base10 = base.baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
    exports.base10 = base10;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base16.js
var require_base16 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base16.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base16 = base.rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    var base16upper = base.rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
    exports.base16 = base16;
    exports.base16upper = base16upper;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base32.js
var require_base32 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base32 = base.rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    var base32upper = base.rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    var base32pad = base.rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    var base32padupper = base.rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    var base32hex = base.rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    var base32hexupper = base.rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    var base32hexpad = base.rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    var base32hexpadupper = base.rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    var base32z = base.rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
    exports.base32 = base32;
    exports.base32hex = base32hex;
    exports.base32hexpad = base32hexpad;
    exports.base32hexpadupper = base32hexpadupper;
    exports.base32hexupper = base32hexupper;
    exports.base32pad = base32pad;
    exports.base32padupper = base32padupper;
    exports.base32upper = base32upper;
    exports.base32z = base32z;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base36.js
var require_base36 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base36.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base36 = base.baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    var base36upper = base.baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
    exports.base36 = base36;
    exports.base36upper = base36upper;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base58.js
var require_base58 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base58.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base58btc = base.baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    var base58flickr = base.baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
    exports.base58btc = base58btc;
    exports.base58flickr = base58flickr;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base64.js
var require_base64 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var base642 = base.rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    var base64pad2 = base.rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    var base64url2 = base.rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    var base64urlpad2 = base.rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
    exports.base64 = base642;
    exports.base64pad = base64pad2;
    exports.base64url = base64url2;
    exports.base64urlpad = base64urlpad2;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base256emoji.js
var require_base256emoji = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/bases/base256emoji.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = require_base2();
    var alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
    var alphabetBytesToChars = alphabet.reduce((p, c, i) => {
      p[i] = c;
      return p;
    }, []);
    var alphabetCharsToBytes = alphabet.reduce((p, c, i) => {
      p[c.codePointAt(0)] = i;
      return p;
    }, []);
    function encode4(data) {
      return data.reduce((p, c) => {
        p += alphabetBytesToChars[c];
        return p;
      }, "");
    }
    function decode5(str3) {
      const byts = [];
      for (const char of str3) {
        const byt = alphabetCharsToBytes[char.codePointAt(0)];
        if (byt === void 0) {
          throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
      }
      return new Uint8Array(byts);
    }
    var base256emoji = base.from({
      prefix: "\u{1F680}",
      name: "base256emoji",
      encode: encode4,
      decode: decode5
    });
    exports.base256emoji = base256emoji;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/vendor/varint.js
var require_varint2 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/vendor/varint.js"(exports, module2) {
    "use strict";
    var encode_12 = encode4;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode4(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode4.bytes = offset - oldOffset + 1;
      return out;
    }
    var decode5 = read2;
    var MSB$12 = 128;
    var REST$12 = 127;
    function read2(buf, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$12) << shift : (b & REST$12) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB$12);
      read2.bytes = counter - offset;
      return res;
    }
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    var length2 = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
    var varint2 = {
      encode: encode_12,
      decode: decode5,
      encodingLength: length2
    };
    var _brrp_varint2 = varint2;
    var varint$1 = _brrp_varint2;
    module2.exports = varint$1;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/varint.js
var require_varint3 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/varint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varint$1 = require_varint2();
    var decode5 = (data, offset = 0) => {
      const code = varint$1.decode(data, offset);
      return [
        code,
        varint$1.decode.bytes
      ];
    };
    var encodeTo2 = (int, target, offset = 0) => {
      varint$1.encode(int, target, offset);
      return target;
    };
    var encodingLength2 = (int) => {
      return varint$1.encodingLength(int);
    };
    exports.decode = decode5;
    exports.encodeTo = encodeTo2;
    exports.encodingLength = encodingLength2;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/digest.js
var require_digest = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/digest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var varint2 = require_varint3();
    var create2 = (code, digest) => {
      const size = digest.byteLength;
      const sizeOffset = varint2.encodingLength(code);
      const digestOffset = sizeOffset + varint2.encodingLength(size);
      const bytes2 = new Uint8Array(digestOffset + size);
      varint2.encodeTo(code, bytes2, 0);
      varint2.encodeTo(size, bytes2, sizeOffset);
      bytes2.set(digest, digestOffset);
      return new Digest2(code, size, digest, bytes2);
    };
    var decode5 = (multihash) => {
      const bytes$1 = bytes.coerce(multihash);
      const [code, sizeOffset] = varint2.decode(bytes$1);
      const [size, digestOffset] = varint2.decode(bytes$1.subarray(sizeOffset));
      const digest = bytes$1.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest2(code, size, digest, bytes$1);
    };
    var equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && bytes.equals(a.bytes, b.bytes);
      }
    };
    var Digest2 = class {
      constructor(code, size, digest, bytes2) {
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes2;
      }
    };
    exports.Digest = Digest2;
    exports.create = create2;
    exports.decode = decode5;
    exports.equals = equals2;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/hasher.js
var require_hasher = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/hasher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var digest = require_digest();
    var from3 = ({ name, code, encode: encode4 }) => new Hasher2(name, code, encode4);
    var Hasher2 = class {
      constructor(name, code, encode4) {
        this.name = name;
        this.code = code;
        this.encode = encode4;
      }
      digest(input) {
        if (input instanceof Uint8Array) {
          const result = this.encode(input);
          return result instanceof Uint8Array ? digest.create(this.code, result) : result.then((digest$1) => digest.create(this.code, digest$1));
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    exports.Hasher = Hasher2;
    exports.from = from3;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/sha2.js
var require_sha2 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var crypto2 = require("crypto");
    var hasher = require_hasher();
    var bytes = require_bytes();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto2);
    var sha2562 = hasher.from({
      name: "sha2-256",
      code: 18,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha256").update(input).digest())
    });
    var sha5122 = hasher.from({
      name: "sha2-512",
      code: 19,
      encode: (input) => bytes.coerce(crypto__default["default"].createHash("sha512").update(input).digest())
    });
    exports.sha256 = sha2562;
    exports.sha512 = sha5122;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/identity.js
var require_identity2 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/hashes/identity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var digest$1 = require_digest();
    var code = 0;
    var name = "identity";
    var encode4 = bytes.coerce;
    var digest = (input) => digest$1.create(code, encode4(input));
    var identity = {
      code,
      name,
      encode: encode4,
      digest
    };
    exports.identity = identity;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/codecs/raw.js
var require_raw = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/codecs/raw.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bytes = require_bytes();
    var name = "raw";
    var code = 85;
    var encode4 = (node) => bytes.coerce(node);
    var decode5 = (data) => bytes.coerce(data);
    exports.code = code;
    exports.decode = decode5;
    exports.encode = encode4;
    exports.name = name;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/codecs/json.js
var require_json = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/codecs/json.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    var name = "json";
    var code = 512;
    var encode4 = (node) => textEncoder.encode(JSON.stringify(node));
    var decode5 = (data) => JSON.parse(textDecoder.decode(data));
    exports.code = code;
    exports.decode = decode5;
    exports.encode = encode4;
    exports.name = name;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/cid.js
var require_cid = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/cid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var varint2 = require_varint3();
    var digest = require_digest();
    var base58 = require_base58();
    var base32 = require_base32();
    var bytes = require_bytes();
    var CID = class {
      constructor(version2, code, multihash, bytes2) {
        this.code = code;
        this.version = version2;
        this.multihash = multihash;
        this.bytes = bytes2;
        this.byteOffset = bytes2.byteOffset;
        this.byteLength = bytes2.byteLength;
        this.asCID = this;
        this._baseCache = /* @__PURE__ */ new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code, multihash } = this;
            if (code !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code, digest: digest$1 } = this.multihash;
            const multihash = digest.create(code, digest$1);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && digest.equals(this.multihash, other.multihash);
      }
      toString(base) {
        const { bytes: bytes2, version: version2, _baseCache } = this;
        switch (version2) {
          case 0:
            return toStringV0(bytes2, _baseCache, base || base58.base58btc.encoder);
          default:
            return toStringV1(bytes2, _baseCache, base || base32.base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version2, code, multihash, bytes: bytes2 } = value;
          return new CID(version2, code, multihash, bytes2 || encodeCID(version2, code, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version2, multihash, code } = value;
          const digest$1 = digest.decode(multihash);
          return CID.create(version2, code, digest$1);
        } else {
          return null;
        }
      }
      static create(version2, code, digest2) {
        if (typeof code !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version2) {
          case 0: {
            if (code !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version2, code, digest2, digest2.bytes);
            }
          }
          case 1: {
            const bytes2 = encodeCID(version2, code, digest2.bytes);
            return new CID(version2, code, digest2, bytes2);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest2) {
        return CID.create(0, DAG_PB_CODE, digest2);
      }
      static createV1(code, digest2) {
        return CID.create(1, code, digest2);
      }
      static decode(bytes2) {
        const [cid, remainder] = CID.decodeFirst(bytes2);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes$1) {
        const specs = CID.inspectBytes(bytes$1);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = bytes.coerce(bytes$1.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest$1 = new digest.Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest$1) : CID.createV1(specs.codec, digest$1);
        return [
          cid,
          bytes$1.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length2] = varint2.decode(initialBytes.subarray(offset));
          offset += length2;
          return i;
        };
        let version2 = next();
        let codec = DAG_PB_CODE;
        if (version2 === 18) {
          version2 = 0;
          offset = 0;
        } else if (version2 === 1) {
          codec = next();
        }
        if (version2 !== 0 && version2 !== 1) {
          throw new RangeError(`Invalid CID version ${version2}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version2,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base) {
        const [prefix, bytes2] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes2);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    var parseCIDtoBytes = (source, base) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder.decode(`${base58.base58btc.prefix}${source}`)
          ];
        }
        case base58.base58btc.prefix: {
          const decoder = base || base58.base58btc;
          return [
            base58.base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.base32.prefix: {
          const decoder = base || base32.base32;
          return [
            base32.base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base.decode(source)
          ];
        }
      }
    };
    var toStringV0 = (bytes2, cache, base) => {
      const { prefix } = base;
      if (prefix !== base58.base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
      }
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base.encode(bytes2).slice(1);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var toStringV1 = (bytes2, cache, base) => {
      const { prefix } = base;
      const cid = cache.get(prefix);
      if (cid == null) {
        const cid2 = base.encode(bytes2);
        cache.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    var DAG_PB_CODE = 112;
    var SHA_256_CODE = 18;
    var encodeCID = (version2, code, multihash) => {
      const codeOffset = varint2.encodingLength(version2);
      const hashOffset = codeOffset + varint2.encodingLength(code);
      const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
      varint2.encodeTo(version2, bytes2, 0);
      varint2.encodeTo(code, bytes2, codeOffset);
      bytes2.set(multihash, hashOffset);
      return bytes2;
    };
    var cidSymbol = Symbol.for("@ipld/js-cid/CID");
    var readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    var hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    var version = "0.0.0-dev";
    var deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    var IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    exports.CID = CID;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/index.js
var require_src3 = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cid = require_cid();
    var varint2 = require_varint3();
    var bytes = require_bytes();
    var hasher = require_hasher();
    var digest = require_digest();
    exports.CID = cid.CID;
    exports.varint = varint2;
    exports.bytes = bytes;
    exports.hasher = hasher;
    exports.digest = digest;
  }
});

// ../../node_modules/multihashes/node_modules/multiformats/cjs/src/basics.js
var require_basics = __commonJS({
  "../../node_modules/multihashes/node_modules/multiformats/cjs/src/basics.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var identity = require_identity();
    var base2 = require_base22();
    var base8 = require_base8();
    var base10 = require_base10();
    var base16 = require_base16();
    var base32 = require_base32();
    var base36 = require_base36();
    var base58 = require_base58();
    var base642 = require_base64();
    var base256emoji = require_base256emoji();
    var sha2 = require_sha2();
    var identity$1 = require_identity2();
    var raw = require_raw();
    var json = require_json();
    require_src3();
    var cid = require_cid();
    var hasher = require_hasher();
    var digest = require_digest();
    var varint2 = require_varint3();
    var bytes = require_bytes();
    var bases = {
      ...identity,
      ...base2,
      ...base8,
      ...base10,
      ...base16,
      ...base32,
      ...base36,
      ...base58,
      ...base642,
      ...base256emoji
    };
    var hashes = {
      ...sha2,
      ...identity$1
    };
    var codecs = {
      raw,
      json
    };
    exports.CID = cid.CID;
    exports.hasher = hasher;
    exports.digest = digest;
    exports.varint = varint2;
    exports.bytes = bytes;
    exports.bases = bases;
    exports.codecs = codecs;
    exports.hashes = hashes;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/util/as-uint8array.js
var require_as_uint8array = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/util/as-uint8array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function asUint8Array(buf) {
      if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      return buf;
    }
    exports.asUint8Array = asUint8Array;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/alloc.js
var require_alloc = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/alloc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var asUint8array = require_as_uint8array();
    function alloc(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.alloc(size));
      }
      return new Uint8Array(size);
    }
    function allocUnsafe(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.allocUnsafe(size));
      }
      return new Uint8Array(size);
    }
    exports.alloc = alloc;
    exports.allocUnsafe = allocUnsafe;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/util/bases.js
var require_bases = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/util/bases.js"(exports, module2) {
    "use strict";
    var basics = require_basics();
    var alloc = require_alloc();
    function createCodec(name, prefix, encode4, decode5) {
      return {
        name,
        prefix,
        encoder: {
          name,
          prefix,
          encode: encode4
        },
        decoder: { decode: decode5 }
      };
    }
    var string = createCodec("utf8", "u", (buf) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf);
    }, (str3) => {
      const encoder = new TextEncoder();
      return encoder.encode(str3.substring(1));
    });
    var ascii = createCodec("ascii", "a", (buf) => {
      let string2 = "a";
      for (let i = 0; i < buf.length; i++) {
        string2 += String.fromCharCode(buf[i]);
      }
      return string2;
    }, (str3) => {
      str3 = str3.substring(1);
      const buf = alloc.allocUnsafe(str3.length);
      for (let i = 0; i < str3.length; i++) {
        buf[i] = str3.charCodeAt(i);
      }
      return buf;
    });
    var BASES = {
      utf8: string,
      "utf-8": string,
      hex: basics.bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...basics.bases
    };
    module2.exports = BASES;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/to-string.js
var require_to_string = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/to-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bases = require_bases();
    function toString(array, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
      }
      return base.encoder.encode(array).substring(1);
    }
    exports.toString = toString;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/from-string.js
var require_from_string = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/from-string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var bases = require_bases();
    var asUint8array = require_as_uint8array();
    function fromString(string, encoding = "utf8") {
      const base = bases[encoding];
      if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
      }
      if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return asUint8array.asUint8Array(globalThis.Buffer.from(string, "utf-8"));
      }
      return base.decoder.decode(`${base.prefix}${string}`);
    }
    exports.fromString = fromString;
  }
});

// ../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/concat.js
var require_concat = __commonJS({
  "../../node_modules/multihashes/node_modules/uint8arrays/cjs/src/concat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var alloc = require_alloc();
    var asUint8array = require_as_uint8array();
    function concat(arrays, length2) {
      if (!length2) {
        length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc.allocUnsafe(length2);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return asUint8array.asUint8Array(output);
    }
    exports.concat = concat;
  }
});

// ../../node_modules/multihashes/src/index.js
var require_src4 = __commonJS({
  "../../node_modules/multihashes/src/index.js"(exports, module2) {
    "use strict";
    var multibase = require_src2();
    var varint2 = require_varint();
    var { names } = require_constants2();
    var { toString: uint8ArrayToString } = require_to_string();
    var { fromString: uint8ArrayFromString } = require_from_string();
    var { concat: uint8ArrayConcat } = require_concat();
    var codes = (
      /** @type {import('./types').CodeNameMap} */
      {}
    );
    for (const key in names) {
      const name = (
        /** @type {HashName} */
        key
      );
      codes[names[name]] = name;
    }
    Object.freeze(codes);
    function toHexString(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(hash, "base16");
    }
    function fromHexString(hash) {
      return uint8ArrayFromString(hash, "base16");
    }
    function toB58String(hash) {
      if (!(hash instanceof Uint8Array)) {
        throw new Error("must be passed a Uint8Array");
      }
      return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
    }
    function fromB58String(hash) {
      const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
      return multibase.decode("z" + encoded);
    }
    function decode5(bytes) {
      if (!(bytes instanceof Uint8Array)) {
        throw new Error("multihash must be a Uint8Array");
      }
      if (bytes.length < 2) {
        throw new Error("multihash too short. must be > 2 bytes.");
      }
      const code = (
        /** @type {HashCode} */
        varint2.decode(bytes)
      );
      if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
      }
      bytes = bytes.slice(varint2.decode.bytes);
      const len = varint2.decode(bytes);
      if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
      }
      bytes = bytes.slice(varint2.decode.bytes);
      if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
      }
      return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
      };
    }
    function encode4(digest, code, length2) {
      if (!digest || code === void 0) {
        throw new Error("multihash encode requires at least two args: digest, code");
      }
      const hashfn = coerceCode(code);
      if (!(digest instanceof Uint8Array)) {
        throw new Error("digest should be a Uint8Array");
      }
      if (length2 == null) {
        length2 = digest.length;
      }
      if (length2 && digest.length !== length2) {
        throw new Error("digest length should be equal to specified length.");
      }
      const hash = varint2.encode(hashfn);
      const len = varint2.encode(length2);
      return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);
    }
    function coerceCode(name) {
      let code = name;
      if (typeof name === "string") {
        if (names[name] === void 0) {
          throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
      }
      if (typeof code !== "number") {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
      }
      if (codes[code] === void 0 && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
      }
      return code;
    }
    function isAppCode(code) {
      return code > 0 && code < 16;
    }
    function isValidCode(code) {
      if (isAppCode(code)) {
        return true;
      }
      if (codes[code]) {
        return true;
      }
      return false;
    }
    function validate(multihash) {
      decode5(multihash);
    }
    function prefix(multihash) {
      validate(multihash);
      return multihash.subarray(0, 2);
    }
    module2.exports = {
      names,
      codes,
      toHexString,
      fromHexString,
      toB58String,
      fromB58String,
      decode: decode5,
      encode: encode4,
      coerceCode,
      isAppCode,
      validate,
      prefix,
      isValidCode
    };
  }
});

// dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DidIonMethod: () => DidIonMethod,
  DidKeyMethod: () => DidKeyMethod,
  DidResolver: () => DidResolver,
  DidResolverCacheLevel: () => DidResolverCacheLevel,
  DidResolverCacheNoop: () => DidResolverCacheNoop,
  utils: () => utils_exports
});
module.exports = __toCommonJS(esm_exports);

// dist/esm/did-ion.js
var import_common = require("@web5/common");
var import_ion_pow_sdk = __toESM(require("@decentralized-identity/ion-pow-sdk"), 1);
var import_crypto2 = require("@web5/crypto");

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/ErrorCode.js
var ErrorCode_default = {
  DeltaExceedsMaximumSize: "DeltaExceedsMaximumSize",
  DidDocumentPublicKeyIdDuplicated: "DidDocumentPublicKeyIdDuplicated",
  DidDocumentPublicKeyMissingOrIncorrectType: "DidDocumentPublicKeyMissingOrIncorrectType",
  DidDocumentServiceIdDuplicated: "DidDocumentServiceIdDuplicated",
  DidSuffixIncorrectLength: "DidSuffixIncorrectLength",
  EncodedStringIncorrectEncoding: "EncodedStringIncorrectEncoding",
  IdNotUsingBase64UrlCharacterSet: "IdNotUsingBase64UrlCharacterSet",
  IdTooLong: "IdTooLong",
  JwkEs256kMissingOrInvalidCrv: "JwkEs256kMissingOrInvalidCrv",
  JwkEs256kMissingOrInvalidKty: "JwkEs256kMissingOrInvalidKty",
  JwkEs256kHasIncorrectLengthOfX: "JwkEs256kHasIncorrectLengthOfX",
  JwkEs256kHasIncorrectLengthOfY: "JwkEs256kHasIncorrectLengthOfY",
  JwkEs256kHasIncorrectLengthOfD: "JwkEs256kHasIncorrectLengthOfD",
  MultihashStringNotAMultihash: "MultihashStringNotAMultihash",
  MultihashUnsupportedHashAlgorithm: "MultihashUnsupportedHashAlgorithm",
  PublicKeyJwkEs256kHasUnexpectedProperty: "PublicKeyJwkEs256kHasUnexpectedProperty",
  PublicKeyPurposeDuplicated: "PublicKeyPurposeDuplicated",
  ServiceEndpointCannotBeAnArray: "ServiceEndpointCannotBeAnArray",
  ServiceEndpointStringNotValidUri: "ServiceEndpointStringNotValidUri",
  ServiceTypeTooLong: "ServiceTypeTooLong"
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonError.js
var IonError = class extends Error {
  constructor(code, message) {
    super(`${code}: ${message}`);
    this.code = code;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bases/base.js
var Encoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(name, prefix, baseEncode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};
var Decoder = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = /** @type {number} */
    prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  /**
   * @param {string} text
   */
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
};
var ComposedDecoder = class {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(decoders) {
    this.decoders = decoders;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(decoder) {
    return or(this, decoder);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(input) {
    const prefix = (
      /** @type {Prefix} */
      input[0]
    );
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
};
var or = (left, right) => new ComposedDecoder(
  /** @type {Decoders<L|R>} */
  {
    ...left.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      left.prefix
    ]: left },
    ...right.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      right.prefix
    ]: right }
  }
);
var Codec = class {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(name, prefix, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix, baseEncode);
    this.decoder = new Decoder(name, prefix, baseDecode);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(input) {
    return this.encoder.encode(input);
  }
  /**
   * @param {string} input
   */
  decode(input) {
    return this.decoder.decode(input);
  }
};
var from = ({ name, prefix, encode: encode4, decode: decode5 }) => new Codec(name, prefix, encode4, decode5);
var decode = (string, alphabet, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i;
  }
  let end = string.length;
  while (string[end - 1] === "=") {
    --end;
  }
  const out = new Uint8Array(end * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end; ++i) {
    const value = codes[string[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
var encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
var rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
  return from({
    prefix,
    name,
    encode(input) {
      return encode(input, alphabet, bitsPerChar);
    },
    decode(input) {
      return decode(input, alphabet, bitsPerChar, name);
    }
  });
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
var base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
var base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
var base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Encoder.js
var Encoder2 = class {
  /**
   * Encodes given bytes into a Base64URL string.
   */
  static encode(content) {
    const encodedContent = base64url.baseEncode(content);
    return encodedContent;
  }
  /**
   * Decodes the given Base64URL string into bytes.
   */
  static decodeAsBytes(encodedContent, inputContextForErrorLogging) {
    if (!Encoder2.isBase64UrlString(encodedContent)) {
      throw new IonError(ErrorCode_default.EncodedStringIncorrectEncoding, `Given ${inputContextForErrorLogging} must be base64url string.`);
    }
    return base64url.baseDecode(encodedContent);
  }
  /**
   * Decodes the given Base64URL string into the original string.
   */
  static decodeAsString(encodedContent, inputContextForErrorLogging) {
    const rawBytes = Encoder2.decodeAsBytes(encodedContent, inputContextForErrorLogging);
    return Encoder2.bytesToString(rawBytes);
  }
  /**
   * Tests if the given string is a Base64URL string.
   */
  static isBase64UrlString(input) {
    const isBase64UrlString = /^[A-Za-z0-9_-]+$/.test(input);
    return isBase64UrlString;
  }
  /**
   * Converts input string to bytes.
   */
  static stringToBytes(input) {
    const bytes = new TextEncoder().encode(input);
    return bytes;
  }
  /**
   * Converts bytes to string.
   */
  static bytesToString(input) {
    const output = new TextDecoder().decode(input);
    return output;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonRequest.js
var URI = __toESM(require_uri_all(), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/OperationKeyType.js
var OperationKeyType;
(function(OperationKeyType2) {
  OperationKeyType2["Public"] = "public";
  OperationKeyType2["Private"] = "private";
})(OperationKeyType || (OperationKeyType = {}));
var OperationKeyType_default = OperationKeyType;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/InputValidator.js
var InputValidator = class {
  /**
   * Validates the schema of a ES256K JWK key.
   */
  static validateEs256kOperationKey(operationKeyJwk, operationKeyType) {
    const allowedProperties = /* @__PURE__ */ new Set(["kty", "crv", "x", "y"]);
    if (operationKeyType === OperationKeyType_default.Private) {
      allowedProperties.add("d");
    }
    for (const property in operationKeyJwk) {
      if (!allowedProperties.has(property)) {
        throw new IonError(ErrorCode_default.PublicKeyJwkEs256kHasUnexpectedProperty, `SECP256K1 JWK key has unexpected property '${property}'.`);
      }
    }
    if (operationKeyJwk.crv !== "secp256k1") {
      throw new IonError(ErrorCode_default.JwkEs256kMissingOrInvalidCrv, `SECP256K1 JWK 'crv' property must be 'secp256k1' but got '${operationKeyJwk.crv}.'`);
    }
    if (operationKeyJwk.kty !== "EC") {
      throw new IonError(ErrorCode_default.JwkEs256kMissingOrInvalidKty, `SECP256K1 JWK 'kty' property must be 'EC' but got '${operationKeyJwk.kty}.'`);
    }
    if (operationKeyJwk.x.length !== 43) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfX, `SECP256K1 JWK 'x' property must be 43 bytes.`);
    }
    if (operationKeyJwk.y.length !== 43) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfY, `SECP256K1 JWK 'y' property must be 43 bytes.`);
    }
    if (operationKeyType === OperationKeyType_default.Private && (operationKeyJwk.d === void 0 || operationKeyJwk.d.length !== 43)) {
      throw new IonError(ErrorCode_default.JwkEs256kHasIncorrectLengthOfD, `SECP256K1 JWK 'd' property must be 43 bytes.`);
    }
  }
  /**
   * Validates an `id` property (in `IonPublicKeyModel` and `IonServiceModel`).
   */
  static validateId(id) {
    const maxIdLength = 50;
    if (id.length > maxIdLength) {
      throw new IonError(ErrorCode_default.IdTooLong, `Key ID length ${id.length} exceed max allowed length of ${maxIdLength}.`);
    }
    if (!Encoder2.isBase64UrlString(id)) {
      throw new IonError(ErrorCode_default.IdNotUsingBase64UrlCharacterSet, `Key ID '${id}' is not a Base64URL string.`);
    }
  }
  /**
   * Validates the given public key purposes.
   */
  static validatePublicKeyPurposes(purposes) {
    if (purposes === void 0) {
      return;
    }
    const processedPurposes = /* @__PURE__ */ new Set();
    for (const purpose of purposes) {
      if (processedPurposes.has(purpose)) {
        throw new IonError(ErrorCode_default.PublicKeyPurposeDuplicated, `Public key purpose '${purpose}' already specified.`);
      }
      processedPurposes.add(purpose);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonSdkConfig.js
var IonSdkConfig = class {
};
IonSdkConfig.hashAlgorithmInMultihashCode = 18;
IonSdkConfig.maxCanonicalizedDeltaSizeInBytes = 1e3;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/JsonCanonicalizer.js
var canonicalize = __toESM(require("canonicalize"), 1);
var JsonCanonicalizer = class {
  /**
   * Canonicalizes the given content as bytes.
   */
  static canonicalizeAsBytes(content) {
    const contentWithoutUndefinedProperties = JsonCanonicalizer.removeAllUndefinedProperties(content);
    const canonicalizedString = canonicalize.default(contentWithoutUndefinedProperties);
    const contentBytes = Encoder2.stringToBytes(canonicalizedString);
    return contentBytes;
  }
  /**
   * Removes all properties within the given object with `undefined` as value.
   */
  static removeAllUndefinedProperties(content) {
    for (const key in content) {
      if (typeof content[key] === "object") {
        JsonCanonicalizer.removeAllUndefinedProperties(content[key]);
      } else if (content[key] === void 0) {
        delete content[key];
      }
    }
    return content;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Multihash.js
var multihashes = __toESM(require_src4(), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/sha2.js
var import_crypto = __toESM(require("crypto"), 1);

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/vendor/varint.js
var encode_1 = encode2;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode2(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode2.bytes = offset - oldOffset + 1;
  return out;
}
var decode2 = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode2,
  encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/varint.js
var encodeTo = (int, target, offset = 0) => {
  varint_default.encode(int, target, offset);
  return target;
};
var encodingLength = (int) => {
  return varint_default.encodingLength(int);
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/digest.js
var create = (code, digest) => {
  const size = digest.byteLength;
  const sizeOffset = encodingLength(code);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes = new Uint8Array(digestOffset + size);
  encodeTo(code, bytes, 0);
  encodeTo(size, bytes, sizeOffset);
  bytes.set(digest, digestOffset);
  return new Digest(code, size, digest, bytes);
};
var Digest = class {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(code, size, digest, bytes) {
    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/hasher.js
var from2 = ({ name, code, encode: encode4 }) => new Hasher(name, code, encode4);
var Hasher = class {
  /**
   *
   * @param {Name} name
   * @param {Code} code
   * @param {(input: Uint8Array) => Await<Uint8Array>} encode
   */
  constructor(name, code, encode4) {
    this.name = name;
    this.code = code;
    this.encode = encode4;
  }
  /**
   * @param {Uint8Array} input
   * @returns {Await<Digest.Digest<Code, number>>}
   */
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create(this.code, result) : result.then((digest) => create(this.code, digest));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/node_modules/multiformats/src/hashes/sha2.js
var sha256 = from2({
  name: "sha2-256",
  code: 18,
  encode: (input) => coerce(import_crypto.default.createHash("sha256").update(input).digest())
});
var sha512 = from2({
  name: "sha2-512",
  code: 19,
  encode: (input) => coerce(import_crypto.default.createHash("sha512").update(input).digest())
});

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/Multihash.js
var __awaiter = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Multihash = class {
  /**
   * Hashes the content using the hashing algorithm specified.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   */
  static hash(content, hashAlgorithmInMultihashCode) {
    return __awaiter(this, void 0, void 0, function* () {
      const conventionalHash = yield this.hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode);
      const multihash = multihashes.encode(conventionalHash, hashAlgorithmInMultihashCode);
      return multihash;
    });
  }
  /**
   * Hashes the content using the hashing algorithm specified as a generic (non-multihash) hash.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   * @returns A multihash bytes.
   */
  static hashAsNonMultihashBytes(content, hashAlgorithmInMultihashCode) {
    return __awaiter(this, void 0, void 0, function* () {
      let hash;
      switch (hashAlgorithmInMultihashCode) {
        case 18:
          hash = yield sha256.encode(content);
          break;
        default:
          throw new IonError(ErrorCode_default.MultihashUnsupportedHashAlgorithm, `Hash algorithm defined in multihash code ${hashAlgorithmInMultihashCode} is not supported.`);
      }
      return hash;
    });
  }
  /**
   * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
   * Mainly used for testing purposes.
   */
  static canonicalizeThenHashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter(this, void 0, void 0, function* () {
      const canonicalizedStringBytes = JsonCanonicalizer.canonicalizeAsBytes(content);
      const multihashEncodedString = yield Multihash.hashThenEncode(canonicalizedStringBytes, hashAlgorithmInMultihashCode);
      return multihashEncodedString;
    });
  }
  /**
   * Canonicalize the given content, then double hashes the result using the latest supported hash algorithm, then encodes the multihash.
   * Mainly used for testing purposes.
   */
  static canonicalizeThenDoubleHashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter(this, void 0, void 0, function* () {
      const contentBytes = JsonCanonicalizer.canonicalizeAsBytes(content);
      const intermediateHashBytes = yield Multihash.hashAsNonMultihashBytes(contentBytes, hashAlgorithmInMultihashCode);
      const multihashEncodedString = yield Multihash.hashThenEncode(intermediateHashBytes, hashAlgorithmInMultihashCode);
      return multihashEncodedString;
    });
  }
  /**
   * Hashes the content using the hashing algorithm specified then encodes the multihash bytes as string.
   * @param hashAlgorithmInMultihashCode The hashing algorithm to use.
   */
  static hashThenEncode(content, hashAlgorithmInMultihashCode) {
    return __awaiter(this, void 0, void 0, function* () {
      const multihashBytes = yield Multihash.hash(content, hashAlgorithmInMultihashCode);
      const multihashEncodedString = Encoder2.encode(multihashBytes);
      return multihashEncodedString;
    });
  }
  /**
   * Checks if the given encoded hash is a multihash computed using the configured hashing algorithm.
   */
  static validateEncodedHashComputedUsingSupportedHashAlgorithm(encodedMultihash, inputContextForErrorLogging) {
    let multihash;
    const multihashBytes = Encoder2.decodeAsBytes(encodedMultihash, inputContextForErrorLogging);
    try {
      multihash = multihashes.decode(multihashBytes);
    } catch (_a) {
      throw new IonError(ErrorCode_default.MultihashStringNotAMultihash, `Given ${inputContextForErrorLogging} string '${encodedMultihash}' is not a multihash after decoding.`);
    }
    const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
    if (hashAlgorithmInMultihashCode !== multihash.code) {
      throw new IonError(ErrorCode_default.MultihashUnsupportedHashAlgorithm, `Given ${inputContextForErrorLogging} uses unsupported multihash algorithm with code ${multihash.code}, should use ${hashAlgorithmInMultihashCode} or change IonSdkConfig to desired hashing algorithm.`);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/OperationType.js
var OperationType;
(function(OperationType3) {
  OperationType3["Create"] = "create";
  OperationType3["Update"] = "update";
  OperationType3["Deactivate"] = "deactivate";
  OperationType3["Recover"] = "recover";
})(OperationType || (OperationType = {}));
var OperationType_default = OperationType;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/PatchAction.js
var PatchAction;
(function(PatchAction2) {
  PatchAction2["Replace"] = "replace";
  PatchAction2["AddPublicKeys"] = "add-public-keys";
  PatchAction2["RemovePublicKeys"] = "remove-public-keys";
  PatchAction2["AddServices"] = "add-services";
  PatchAction2["RemoveServices"] = "remove-services";
})(PatchAction || (PatchAction = {}));
var PatchAction_default = PatchAction;

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonRequest.js
var __awaiter2 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IonRequest = class {
  /**
   * Creates an ION DID create request.
   * @param input.document The initial state to be associate with the ION DID to be created using a `replace` document patch action.
   */
  static createCreateRequest(input) {
    return __awaiter2(this, void 0, void 0, function* () {
      const recoveryKey = input.recoveryKey;
      const updateKey = input.updateKey;
      const didDocumentKeys = input.document.publicKeys;
      const services = input.document.services;
      InputValidator.validateEs256kOperationKey(recoveryKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(updateKey, OperationKeyType_default.Public);
      IonRequest.validateDidDocumentKeys(didDocumentKeys);
      IonRequest.validateServices(services);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const patches = [{
        action: PatchAction_default.Replace,
        document: input.document
      }];
      const delta = {
        updateCommitment: yield Multihash.canonicalizeThenDoubleHashThenEncode(updateKey, hashAlgorithmInMultihashCode),
        patches
      };
      IonRequest.validateDeltaSize(delta);
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const suffixData = {
        deltaHash,
        recoveryCommitment: yield Multihash.canonicalizeThenDoubleHashThenEncode(recoveryKey, hashAlgorithmInMultihashCode)
      };
      const operationRequest = {
        type: OperationType_default.Create,
        suffixData,
        delta
      };
      return operationRequest;
    });
  }
  static createDeactivateRequest(input) {
    return __awaiter2(this, void 0, void 0, function* () {
      IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_default.Public);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        didSuffix: input.didSuffix,
        recoveryKey: input.recoveryPublicKey
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Deactivate,
        didSuffix: input.didSuffix,
        revealValue,
        signedData: compactJws
      };
    });
  }
  static createRecoverRequest(input) {
    return __awaiter2(this, void 0, void 0, function* () {
      IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.recoveryPublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextRecoveryPublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextUpdatePublicKey, OperationKeyType_default.Public);
      IonRequest.validateDidDocumentKeys(input.document.publicKeys);
      IonRequest.validateServices(input.document.services);
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.recoveryPublicKey, hashAlgorithmInMultihashCode);
      const patches = [{
        action: PatchAction_default.Replace,
        document: input.document
      }];
      const nextUpdateCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextUpdatePublicKey, hashAlgorithmInMultihashCode);
      const delta = {
        patches,
        updateCommitment: nextUpdateCommitmentHash
      };
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const nextRecoveryCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextRecoveryPublicKey, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        recoveryCommitment: nextRecoveryCommitmentHash,
        recoveryKey: input.recoveryPublicKey,
        deltaHash
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Recover,
        didSuffix: input.didSuffix,
        revealValue,
        delta,
        signedData: compactJws
      };
    });
  }
  static createUpdateRequest(input) {
    return __awaiter2(this, void 0, void 0, function* () {
      IonRequest.validateDidSuffix(input.didSuffix);
      InputValidator.validateEs256kOperationKey(input.updatePublicKey, OperationKeyType_default.Public);
      InputValidator.validateEs256kOperationKey(input.nextUpdatePublicKey, OperationKeyType_default.Public);
      IonRequest.validateServices(input.servicesToAdd);
      IonRequest.validateDidDocumentKeys(input.publicKeysToAdd);
      if (input.idsOfServicesToRemove !== void 0) {
        for (const id of input.idsOfServicesToRemove) {
          InputValidator.validateId(id);
        }
      }
      if (input.idsOfPublicKeysToRemove !== void 0) {
        for (const id of input.idsOfPublicKeysToRemove) {
          InputValidator.validateId(id);
        }
      }
      const patches = [];
      const servicesToAdd = input.servicesToAdd;
      if (servicesToAdd !== void 0 && servicesToAdd.length > 0) {
        const patch = {
          action: PatchAction_default.AddServices,
          services: servicesToAdd
        };
        patches.push(patch);
      }
      const idsOfServicesToRemove = input.idsOfServicesToRemove;
      if (idsOfServicesToRemove !== void 0 && idsOfServicesToRemove.length > 0) {
        const patch = {
          action: PatchAction_default.RemoveServices,
          ids: idsOfServicesToRemove
        };
        patches.push(patch);
      }
      const publicKeysToAdd = input.publicKeysToAdd;
      if (publicKeysToAdd !== void 0 && publicKeysToAdd.length > 0) {
        const patch = {
          action: PatchAction_default.AddPublicKeys,
          publicKeys: publicKeysToAdd
        };
        patches.push(patch);
      }
      const idsOfPublicKeysToRemove = input.idsOfPublicKeysToRemove;
      if (idsOfPublicKeysToRemove !== void 0 && idsOfPublicKeysToRemove.length > 0) {
        const patch = {
          action: PatchAction_default.RemovePublicKeys,
          ids: idsOfPublicKeysToRemove
        };
        patches.push(patch);
      }
      const hashAlgorithmInMultihashCode = IonSdkConfig.hashAlgorithmInMultihashCode;
      const revealValue = yield Multihash.canonicalizeThenHashThenEncode(input.updatePublicKey, hashAlgorithmInMultihashCode);
      const nextUpdateCommitmentHash = yield Multihash.canonicalizeThenDoubleHashThenEncode(input.nextUpdatePublicKey, hashAlgorithmInMultihashCode);
      const delta = {
        patches,
        updateCommitment: nextUpdateCommitmentHash
      };
      const deltaHash = yield Multihash.canonicalizeThenHashThenEncode(delta, hashAlgorithmInMultihashCode);
      const dataToBeSigned = {
        updateKey: input.updatePublicKey,
        deltaHash
      };
      const compactJws = yield input.signer.sign({ alg: "ES256K" }, dataToBeSigned);
      return {
        type: OperationType_default.Update,
        didSuffix: input.didSuffix,
        revealValue,
        delta,
        signedData: compactJws
      };
    });
  }
  static validateDidSuffix(didSuffix) {
    Multihash.validateEncodedHashComputedUsingSupportedHashAlgorithm(didSuffix, "didSuffix");
  }
  static validateDidDocumentKeys(publicKeys) {
    if (publicKeys === void 0) {
      return;
    }
    const publicKeyIdSet = /* @__PURE__ */ new Set();
    for (const publicKey of publicKeys) {
      if (Array.isArray(publicKey.publicKeyJwk)) {
        throw new IonError(ErrorCode_default.DidDocumentPublicKeyMissingOrIncorrectType, `DID Document key 'publicKeyJwk' property is not a non-array object.`);
      }
      InputValidator.validateId(publicKey.id);
      if (publicKeyIdSet.has(publicKey.id)) {
        throw new IonError(ErrorCode_default.DidDocumentPublicKeyIdDuplicated, `DID Document key with ID '${publicKey.id}' already exists.`);
      }
      publicKeyIdSet.add(publicKey.id);
      InputValidator.validatePublicKeyPurposes(publicKey.purposes);
    }
  }
  static validateServices(services) {
    if (services !== void 0 && services.length !== 0) {
      const serviceIdSet = /* @__PURE__ */ new Set();
      for (const service of services) {
        IonRequest.validateService(service);
        if (serviceIdSet.has(service.id)) {
          throw new IonError(ErrorCode_default.DidDocumentServiceIdDuplicated, "Service id has to be unique");
        }
        serviceIdSet.add(service.id);
      }
    }
  }
  static validateService(service) {
    InputValidator.validateId(service.id);
    const maxTypeLength = 30;
    if (service.type.length > maxTypeLength) {
      const errorMessage = `Service endpoint type length ${service.type.length} exceeds max allowed length of ${maxTypeLength}.`;
      throw new IonError(ErrorCode_default.ServiceTypeTooLong, errorMessage);
    }
    if (Array.isArray(service.serviceEndpoint)) {
      const errorMessage = "Service endpoint value cannot be an array.";
      throw new IonError(ErrorCode_default.ServiceEndpointCannotBeAnArray, errorMessage);
    }
    if (typeof service.serviceEndpoint === "string") {
      const uri = URI.parse(service.serviceEndpoint);
      if (uri.error !== void 0) {
        throw new IonError(ErrorCode_default.ServiceEndpointStringNotValidUri, `Service endpoint string '${service.serviceEndpoint}' is not a URI.`);
      }
    }
  }
  static validateDeltaSize(delta) {
    const deltaBytes = JsonCanonicalizer.canonicalizeAsBytes(delta);
    if (deltaBytes.length > IonSdkConfig.maxCanonicalizedDeltaSizeInBytes) {
      const errorMessage = `Delta of ${deltaBytes.length} bytes exceeded limit of ${IonSdkConfig.maxCanonicalizedDeltaSizeInBytes} bytes.`;
      throw new IonError(ErrorCode_default.DeltaExceedsMaximumSize, errorMessage);
    }
  }
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/IonDid.js
var __awaiter3 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var IonDid = class {
  /**
   * Creates a long-form DID.
   * @param input.document The initial state to be associate with the ION DID to be created using a `replace` document patch action.
   */
  static createLongFormDid(input) {
    return __awaiter3(this, void 0, void 0, function* () {
      const createRequest = yield IonRequest.createCreateRequest(input);
      const didUniqueSuffix = yield IonDid.computeDidUniqueSuffix(createRequest.suffixData);
      let shortFormDid;
      if (IonSdkConfig.network === void 0 || IonSdkConfig.network === "mainnet") {
        shortFormDid = `did:ion:${didUniqueSuffix}`;
      } else {
        shortFormDid = `did:ion:${IonSdkConfig.network}:${didUniqueSuffix}`;
      }
      const initialState = {
        suffixData: createRequest.suffixData,
        delta: createRequest.delta
      };
      const canonicalizedInitialStateBytes = JsonCanonicalizer.canonicalizeAsBytes(initialState);
      const encodedCanonicalizedInitialStateString = Encoder2.encode(canonicalizedInitialStateBytes);
      const longFormDid = `${shortFormDid}:${encodedCanonicalizedInitialStateString}`;
      return longFormDid;
    });
  }
  /**
   * Computes the DID unique suffix given the encoded suffix data string.
   */
  static computeDidUniqueSuffix(suffixData) {
    return __awaiter3(this, void 0, void 0, function* () {
      const canonicalizedStringBytes = JsonCanonicalizer.canonicalizeAsBytes(suffixData);
      const multihash = yield Multihash.hash(canonicalizedStringBytes, IonSdkConfig.hashAlgorithmInMultihashCode);
      const encodedMultihash = Encoder2.encode(multihash);
      return encodedMultihash;
    });
  }
};

// ../../node_modules/@noble/ed25519/index.js
var P = 2n ** 255n - 19n;
var N = 2n ** 252n + 27742317777372353535851937790883648493n;
var Gx = 0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51an;
var Gy = 0x6666666666666666666666666666666666666666666666666666666666666658n;
var CURVE = {
  a: -1n,
  d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,
  p: P,
  n: N,
  h: 8,
  Gx,
  Gy
  // field prime, curve (group) order, cofactor
};
var err = (m = "") => {
  throw new Error(m);
};
var str = (s) => typeof s === "string";
var au8 = (a, l) => (
  // is Uint8Array (of specific length)
  !(a instanceof Uint8Array) || typeof l === "number" && l > 0 && a.length !== l ? err("Uint8Array expected") : a
);
var u8n = (data) => new Uint8Array(data);
var toU8 = (a, len) => au8(str(a) ? h2b(a) : u8n(a), len);
var mod = (a, b = P) => {
  let r = a % b;
  return r >= 0n ? r : b + r;
};
var isPoint = (p) => p instanceof Point ? p : err("Point expected");
var Gpows = void 0;
var Point = class {
  constructor(ex, ey, ez, et) {
    this.ex = ex;
    this.ey = ey;
    this.ez = ez;
    this.et = et;
  }
  static fromAffine(p) {
    return new Point(p.x, p.y, 1n, mod(p.x * p.y));
  }
  static fromHex(hex, strict = true) {
    const { d } = CURVE;
    hex = toU8(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y = b2n_LE(normed);
    if (y === 0n) {
    } else {
      if (strict && !(0n < y && y < P))
        err("bad y coord 1");
      if (!strict && !(0n < y && y < 2n ** 256n))
        err("bad y coord 2");
    }
    const y2 = mod(y * y);
    const u = mod(y2 - 1n);
    const v = mod(d * y2 + 1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      err("bad y coordinate 3");
    const isXOdd = (x & 1n) === 1n;
    const isHeadOdd = (hex[31] & 128) !== 0;
    if (isHeadOdd !== isXOdd)
      x = mod(-x);
    return new Point(x, y, 1n, mod(x * y));
  }
  get x() {
    return this.toAffine().x;
  }
  // .x, .y will call expensive toAffine.
  get y() {
    return this.toAffine().y;
  }
  // Should be used with care.
  equals(other) {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { ex: X2, ey: Y2, ez: Z2 } = isPoint(other);
    const X1Z2 = mod(X1 * Z2), X2Z1 = mod(X2 * Z1);
    const Y1Z2 = mod(Y1 * Z2), Y2Z1 = mod(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  is0() {
    return this.equals(I);
  }
  negate() {
    return new Point(mod(-this.ex), this.ey, this.ez, mod(-this.et));
  }
  double() {
    const { ex: X1, ey: Y1, ez: Z1 } = this;
    const { a } = CURVE;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(2n * mod(Z1 * Z1));
    const D = mod(a * A);
    const x1y1 = X1 + Y1;
    const E = mod(mod(x1y1 * x1y1) - A - B);
    const G3 = D + B;
    const F = G3 - C;
    const H = D - B;
    const X3 = mod(E * F);
    const Y3 = mod(G3 * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G3);
    return new Point(X3, Y3, Z3, T3);
  }
  add(other) {
    const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
    const { ex: X2, ey: Y2, ez: Z2, et: T2 } = isPoint(other);
    const { a, d } = CURVE;
    const A = mod(X1 * X2);
    const B = mod(Y1 * Y2);
    const C = mod(T1 * d * T2);
    const D = mod(Z1 * Z2);
    const E = mod((X1 + Y1) * (X2 + Y2) - A - B);
    const F = mod(D - C);
    const G3 = mod(D + C);
    const H = mod(B - a * A);
    const X3 = mod(E * F);
    const Y3 = mod(G3 * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G3);
    return new Point(X3, Y3, Z3, T3);
  }
  mul(n, safe = true) {
    if (n === 0n)
      return safe === true ? err("cannot multiply by 0") : I;
    if (!(typeof n === "bigint" && 0n < n && n < N))
      err("invalid scalar, must be < L");
    if (!safe && this.is0() || n === 1n)
      return this;
    if (this.equals(G))
      return wNAF(n).p;
    let p = I, f = G;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  multiply(scalar) {
    return this.mul(scalar);
  }
  // Aliases for compatibilty
  clearCofactor() {
    return this.mul(BigInt(CURVE.h), false);
  }
  // multiply by cofactor
  isSmallOrder() {
    return this.clearCofactor().is0();
  }
  // check if P is small order
  isTorsionFree() {
    let p = this.mul(N / 2n, false).double();
    if (N % 2n)
      p = p.add(this);
    return p.is0();
  }
  toAffine() {
    const { ex: x, ey: y, ez: z } = this;
    if (this.is0())
      return { x: 0n, y: 0n };
    const iz = invert(z);
    if (mod(z * iz) !== 1n)
      err("invalid inverse");
    return { x: mod(x * iz), y: mod(y * iz) };
  }
  toRawBytes() {
    const { x, y } = this.toAffine();
    const b = n2b_32LE(y);
    b[31] |= x & 1n ? 128 : 0;
    return b;
  }
  toHex() {
    return b2h(this.toRawBytes());
  }
  // encode to hex string
};
Point.BASE = new Point(Gx, Gy, 1n, mod(Gx * Gy));
Point.ZERO = new Point(0n, 1n, 1n, 0n);
var { BASE: G, ZERO: I } = Point;
var padh = (num, pad) => num.toString(16).padStart(pad, "0");
var b2h = (b) => Array.from(b).map((e) => padh(e, 2)).join("");
var h2b = (hex) => {
  const l = hex.length;
  if (!str(hex) || l % 2)
    err("hex invalid 1");
  const arr = u8n(l / 2);
  for (let i = 0; i < arr.length; i++) {
    const j = i * 2;
    const h = hex.slice(j, j + 2);
    const b = Number.parseInt(h, 16);
    if (Number.isNaN(b) || b < 0)
      err("hex invalid 2");
    arr[i] = b;
  }
  return arr;
};
var n2b_32LE = (num) => h2b(padh(num, 32 * 2)).reverse();
var b2n_LE = (b) => BigInt("0x" + b2h(u8n(au8(b)).reverse()));
var concatB = (...arrs) => {
  const r = u8n(arrs.reduce((sum, a) => sum + au8(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
var invert = (num, md = P) => {
  if (num === 0n || md <= 0n)
    err("no inverse n=" + num + " mod=" + md);
  let a = mod(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? mod(x, md) : err("no inverse");
};
var pow2 = (x, power) => {
  let r = x;
  while (power-- > 0n) {
    r *= r;
    r %= P;
  }
  return r;
};
var pow_2_252_3 = (x) => {
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, 2n) * b2 % P;
  const b5 = pow2(b4, 1n) * x % P;
  const b10 = pow2(b5, 5n) * b5 % P;
  const b20 = pow2(b10, 10n) * b10 % P;
  const b40 = pow2(b20, 20n) * b20 % P;
  const b80 = pow2(b40, 40n) * b40 % P;
  const b160 = pow2(b80, 80n) * b80 % P;
  const b240 = pow2(b160, 80n) * b80 % P;
  const b250 = pow2(b240, 10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, 2n) * x % P;
  return { pow_p_5_8, b2 };
};
var RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;
var uvRatio = (u, v) => {
  const v3 = mod(v * v * v);
  const v7 = mod(v3 * v3 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v3 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * RM1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * RM1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if ((mod(x) & 1n) === 1n)
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
};
var _shaS;
var cr = () => (
  // We support: 1) browsers 2) node.js 19+
  typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
var etc = {
  bytesToHex: b2h,
  hexToBytes: h2b,
  concatBytes: concatB,
  mod,
  invert,
  randomBytes: (len) => {
    const crypto2 = cr();
    if (!crypto2)
      err("crypto.getRandomValues must be defined");
    return crypto2.getRandomValues(u8n(len));
  },
  sha512Async: async (...messages) => {
    const crypto2 = cr();
    if (!crypto2)
      err("crypto.subtle or etc.sha512Async must be defined");
    const m = concatB(...messages);
    return u8n(await crypto2.subtle.digest("SHA-512", m.buffer));
  },
  sha512Sync: void 0
  // Actual logic below
};
Object.defineProperties(etc, { sha512Sync: {
  configurable: false,
  get() {
    return _shaS;
  },
  set(f) {
    if (!_shaS)
      _shaS = f;
  }
} });
var W = 8;
var precompute = () => {
  const points = [];
  const windows = 256 / W + 1;
  let p = G, b = p;
  for (let w = 0; w < windows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < 2 ** (W - 1); i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var wNAF = (n) => {
  const comp = Gpows || (Gpows = precompute());
  const neg = (cnd, p2) => {
    let n2 = p2.negate();
    return cnd ? n2 : p2;
  };
  let p = I, f = G;
  const windows = 1 + 256 / W;
  const wsize = 2 ** (W - 1);
  const mask = BigInt(2 ** W - 1);
  const maxNum = 2 ** W;
  const shiftBy = BigInt(W);
  for (let w = 0; w < windows; w++) {
    const off = w * wsize;
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > wsize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off1 = off, off2 = off + Math.abs(wbits) - 1;
    const cnd1 = w % 2 !== 0, cnd2 = wbits < 0;
    if (wbits === 0) {
      f = f.add(neg(cnd1, comp[off1]));
    } else {
      p = p.add(neg(cnd2, comp[off2]));
    }
  }
  return { p, f };
};

// ../../node_modules/@noble/secp256k1/index.js
var B256 = 2n ** 256n;
var P2 = B256 - 0x1000003d1n;
var N10 = B256 - 0x14551231950b75fc4402da1732fc9bebfn;
var Gx2 = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798n;
var Gy2 = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8n;
var CURVE2 = { p: P2, n: N10, a: 0n, b: 7n, Gx: Gx2, Gy: Gy2 };
var fLen = 32;
var crv = (x) => mod2(mod2(x * x) * x + CURVE2.b);
var err2 = (m = "") => {
  throw new Error(m);
};
var big = (n) => typeof n === "bigint";
var str2 = (s) => typeof s === "string";
var fe = (n) => big(n) && 0n < n && n < P2;
var ge = (n) => big(n) && 0n < n && n < N10;
var au82 = (a, l) => (
  // is Uint8Array (of specific length)
  !(a instanceof Uint8Array) || typeof l === "number" && l > 0 && a.length !== l ? err2("Uint8Array expected") : a
);
var u8n2 = (data) => new Uint8Array(data);
var toU82 = (a, len) => au82(str2(a) ? h2b2(a) : u8n2(a), len);
var mod2 = (a, b = P2) => {
  let r = a % b;
  return r >= 0n ? r : b + r;
};
var isPoint2 = (p) => p instanceof Point2 ? p : err2("Point expected");
var Gpows2 = void 0;
var Point2 = class {
  constructor(px, py, pz) {
    this.px = px;
    this.py = py;
    this.pz = pz;
  }
  //3d=less inversions
  static fromAffine(p) {
    return new Point2(p.x, p.y, 1n);
  }
  static fromHex(hex) {
    hex = toU82(hex);
    let p = void 0;
    const head = hex[0], tail = hex.subarray(1);
    const x = slcNum(tail, 0, fLen), len = hex.length;
    if (len === 33 && [2, 3].includes(head)) {
      if (!fe(x))
        err2("Point hex invalid: x not FE");
      let y = sqrt(crv(x));
      const isYOdd = (y & 1n) === 1n;
      const headOdd = (head & 1) === 1;
      if (headOdd !== isYOdd)
        y = mod2(-y);
      p = new Point2(x, y, 1n);
    }
    if (len === 65 && head === 4)
      p = new Point2(x, slcNum(tail, fLen, 2 * fLen), 1n);
    return p ? p.ok() : err2("Point is not on curve");
  }
  static fromPrivateKey(k) {
    return G2.mul(toPriv(k));
  }
  // Create point from a private key.
  get x() {
    return this.aff().x;
  }
  // .x, .y will call expensive toAffine:
  get y() {
    return this.aff().y;
  }
  // should be used with care.
  equals(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = isPoint2(other);
    const X1Z2 = mod2(X1 * Z2), X2Z1 = mod2(X2 * Z1);
    const Y1Z2 = mod2(Y1 * Z2), Y2Z1 = mod2(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new Point2(this.px, mod2(-this.py), this.pz);
  }
  // Flip point over y coord
  double() {
    return this.add(this);
  }
  // Point doubling: P+P, complete formula.
  add(other) {
    const { px: X1, py: Y1, pz: Z1 } = this;
    const { px: X2, py: Y2, pz: Z2 } = isPoint2(other);
    const { a, b } = CURVE2;
    let X3 = 0n, Y3 = 0n, Z3 = 0n;
    const b3 = mod2(b * 3n);
    let t0 = mod2(X1 * X2), t1 = mod2(Y1 * Y2), t2 = mod2(Z1 * Z2), t3 = mod2(X1 + Y1);
    let t4 = mod2(X2 + Y2);
    t3 = mod2(t3 * t4);
    t4 = mod2(t0 + t1);
    t3 = mod2(t3 - t4);
    t4 = mod2(X1 + Z1);
    let t5 = mod2(X2 + Z2);
    t4 = mod2(t4 * t5);
    t5 = mod2(t0 + t2);
    t4 = mod2(t4 - t5);
    t5 = mod2(Y1 + Z1);
    X3 = mod2(Y2 + Z2);
    t5 = mod2(t5 * X3);
    X3 = mod2(t1 + t2);
    t5 = mod2(t5 - X3);
    Z3 = mod2(a * t4);
    X3 = mod2(b3 * t2);
    Z3 = mod2(X3 + Z3);
    X3 = mod2(t1 - Z3);
    Z3 = mod2(t1 + Z3);
    Y3 = mod2(X3 * Z3);
    t1 = mod2(t0 + t0);
    t1 = mod2(t1 + t0);
    t2 = mod2(a * t2);
    t4 = mod2(b3 * t4);
    t1 = mod2(t1 + t2);
    t2 = mod2(t0 - t2);
    t2 = mod2(a * t2);
    t4 = mod2(t4 + t2);
    t0 = mod2(t1 * t4);
    Y3 = mod2(Y3 + t0);
    t0 = mod2(t5 * t4);
    X3 = mod2(t3 * X3);
    X3 = mod2(X3 - t0);
    t0 = mod2(t3 * t1);
    Z3 = mod2(t5 * Z3);
    Z3 = mod2(Z3 + t0);
    return new Point2(X3, Y3, Z3);
  }
  mul(n, safe = true) {
    if (!safe && n === 0n)
      return I2;
    if (!ge(n))
      err2("invalid scalar");
    if (this.equals(G2))
      return wNAF2(n).p;
    let p = I2, f = G2;
    for (let d = this; n > 0n; d = d.double(), n >>= 1n) {
      if (n & 1n)
        p = p.add(d);
      else if (safe)
        f = f.add(d);
    }
    return p;
  }
  mulAddQUns(R, u1, u2) {
    return this.mul(u1, false).add(R.mul(u2, false)).ok();
  }
  // to private keys. Doesn't use Shamir trick
  toAffine() {
    const { px: x, py: y, pz: z } = this;
    if (this.equals(I2))
      return { x: 0n, y: 0n };
    if (z === 1n)
      return { x, y };
    const iz = inv(z);
    if (mod2(z * iz) !== 1n)
      err2("invalid inverse");
    return { x: mod2(x * iz), y: mod2(y * iz) };
  }
  assertValidity() {
    const { x, y } = this.aff();
    if (!fe(x) || !fe(y))
      err2("Point invalid: x or y");
    return mod2(y * y) === crv(x) ? (
      // y = x + ax + b, must be equal
      this
    ) : err2("Point invalid: not on curve");
  }
  multiply(n) {
    return this.mul(n);
  }
  // Aliases to compress code
  aff() {
    return this.toAffine();
  }
  ok() {
    return this.assertValidity();
  }
  toHex(isCompressed = true) {
    const { x, y } = this.aff();
    const head = isCompressed ? (y & 1n) === 0n ? "02" : "03" : "04";
    return head + n2h(x) + (isCompressed ? "" : n2h(y));
  }
  toRawBytes(isCompressed = true) {
    return h2b2(this.toHex(isCompressed));
  }
};
Point2.BASE = new Point2(Gx2, Gy2, 1n);
Point2.ZERO = new Point2(0n, 1n, 0n);
var { BASE: G2, ZERO: I2 } = Point2;
var padh2 = (n, pad) => n.toString(16).padStart(pad, "0");
var b2h2 = (b) => Array.from(b).map((e) => padh2(e, 2)).join("");
var h2b2 = (hex) => {
  const l = hex.length;
  if (!str2(hex) || l % 2)
    err2("hex invalid 1");
  const arr = u8n2(l / 2);
  for (let i = 0; i < arr.length; i++) {
    const j = i * 2;
    const h = hex.slice(j, j + 2);
    const b = Number.parseInt(h, 16);
    if (Number.isNaN(b) || b < 0)
      err2("hex invalid 2");
    arr[i] = b;
  }
  return arr;
};
var b2n = (b) => BigInt("0x" + (b2h2(b) || "0"));
var slcNum = (b, from3, to) => b2n(b.slice(from3, to));
var n2b = (num) => {
  return big(num) && num >= 0n && num < B256 ? h2b2(padh2(num, 2 * fLen)) : err2("bigint expected");
};
var n2h = (num) => b2h2(n2b(num));
var concatB2 = (...arrs) => {
  const r = u8n2(arrs.reduce((sum, a) => sum + au82(a).length, 0));
  let pad = 0;
  arrs.forEach((a) => {
    r.set(a, pad);
    pad += a.length;
  });
  return r;
};
var inv = (num, md = P2) => {
  if (num === 0n || md <= 0n)
    err2("no inverse n=" + num + " mod=" + md);
  let a = mod2(num, md), b = md, x = 0n, y = 1n, u = 1n, v = 0n;
  while (a !== 0n) {
    const q = b / a, r = b % a;
    const m = x - u * q, n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  return b === 1n ? mod2(x, md) : err2("no inverse");
};
var sqrt = (n) => {
  let r = 1n;
  for (let num = n, e = (P2 + 1n) / 4n; e > 0n; e >>= 1n) {
    if (e & 1n)
      r = r * num % P2;
    num = num * num % P2;
  }
  return mod2(r * r) === n ? r : err2("sqrt invalid");
};
var toPriv = (p) => {
  if (!big(p))
    p = b2n(toU82(p, fLen));
  return ge(p) ? p : err2("private key out of range");
};
var cr2 = () => (
  // We support: 1) browsers 2) node.js 19+ 3) deno, other envs with crypto
  typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0
);
var _hmacSync;
function hashToPrivateKey(hash) {
  hash = toU82(hash);
  const minLen = fLen + 8;
  if (hash.length < minLen || hash.length > 1024)
    err2("expected proper params");
  const num = mod2(b2n(hash), N10 - 1n) + 1n;
  return n2b(num);
}
var etc2 = {
  hexToBytes: h2b2,
  bytesToHex: b2h2,
  concatBytes: concatB2,
  bytesToNumberBE: b2n,
  numberToBytesBE: n2b,
  mod: mod2,
  invert: inv,
  hmacSha256Async: async (key, ...msgs) => {
    const crypto2 = cr2();
    if (!crypto2)
      return err2("etc.hmacSha256Async not set");
    const s = crypto2.subtle;
    const k = await s.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    return u8n2(await s.sign("HMAC", k, concatB2(...msgs)));
  },
  hmacSha256Sync: _hmacSync,
  hashToPrivateKey,
  randomBytes: (len) => {
    const crypto2 = cr2();
    if (!crypto2)
      err2("crypto.getRandomValues must be defined");
    return crypto2.getRandomValues(u8n2(len));
  }
};
Object.defineProperties(etc2, { hmacSha256Sync: {
  configurable: false,
  get() {
    return _hmacSync;
  },
  set(f) {
    if (!_hmacSync)
      _hmacSync = f;
  }
} });
var W2 = 8;
var precompute2 = () => {
  const points = [];
  const windows = 256 / W2 + 1;
  let p = G2, b = p;
  for (let w = 0; w < windows; w++) {
    b = p;
    points.push(b);
    for (let i = 1; i < 2 ** (W2 - 1); i++) {
      b = b.add(p);
      points.push(b);
    }
    p = b.double();
  }
  return points;
};
var wNAF2 = (n) => {
  const comp = Gpows2 || (Gpows2 = precompute2());
  const neg = (cnd, p2) => {
    let n2 = p2.negate();
    return cnd ? n2 : p2;
  };
  let p = I2, f = G2;
  const windows = 1 + 256 / W2;
  const wsize = 2 ** (W2 - 1);
  const mask = BigInt(2 ** W2 - 1);
  const maxNum = 2 ** W2;
  const shiftBy = BigInt(W2);
  for (let w = 0; w < windows; w++) {
    const off = w * wsize;
    let wbits = Number(n & mask);
    n >>= shiftBy;
    if (wbits > wsize) {
      wbits -= maxNum;
      n += 1n;
    }
    const off1 = off, off2 = off + Math.abs(wbits) - 1;
    const cnd1 = w % 2 !== 0, cnd2 = wbits < 0;
    if (wbits === 0) {
      f = f.add(neg(cnd1, comp[off1]));
    } else {
      p = p.add(neg(cnd2, comp[off2]));
    }
  }
  return { p, f };
};

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/IonNetwork.js
var IonNetwork;
(function(IonNetwork2) {
  IonNetwork2["Mainnet"] = "mainnet";
  IonNetwork2["Testnet"] = "test";
})(IonNetwork || (IonNetwork = {}));

// ../../node_modules/@decentralized-identity/ion-sdk/dist/lib/enums/IonPublicKeyPurpose.js
var IonPublicKeyPurpose;
(function(IonPublicKeyPurpose2) {
  IonPublicKeyPurpose2["Authentication"] = "authentication";
  IonPublicKeyPurpose2["AssertionMethod"] = "assertionMethod";
  IonPublicKeyPurpose2["CapabilityInvocation"] = "capabilityInvocation";
  IonPublicKeyPurpose2["CapabilityDelegation"] = "capabilityDelegation";
  IonPublicKeyPurpose2["KeyAgreement"] = "keyAgreement";
})(IonPublicKeyPurpose || (IonPublicKeyPurpose = {}));
var IonPublicKeyPurpose_default = IonPublicKeyPurpose;

// dist/esm/utils.js
var utils_exports = {};
__export(utils_exports, {
  DID_REGEX: () => DID_REGEX,
  getServices: () => getServices,
  getVerificationMethodIds: () => getVerificationMethodIds,
  getVerificationMethodTypes: () => getVerificationMethodTypes,
  isDwnServiceEndpoint: () => isDwnServiceEndpoint,
  parseDid: () => parseDid
});
var import_did_resolver = require("did-resolver");
var DID_REGEX = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\/[^#?]*)?([?][^#]*)?(#.*)?$/;
function getServices(options) {
  var _a, _b;
  const { didDocument, id, type } = options !== null && options !== void 0 ? options : {};
  return (_b = (_a = didDocument === null || didDocument === void 0 ? void 0 : didDocument.service) === null || _a === void 0 ? void 0 : _a.filter((service) => {
    if (id && service.id !== id)
      return false;
    if (type && service.type !== type)
      return false;
    return true;
  })) !== null && _b !== void 0 ? _b : [];
}
function getVerificationMethodIds(options) {
  const { didDocument, publicKeyJwk, publicKeyMultibase } = options;
  if (!didDocument)
    throw new Error(`Required parameter missing: 'didDocument'`);
  if (!didDocument.verificationMethod)
    throw new Error("Given `didDocument` is missing `verificationMethod` entries.");
  for (let method of didDocument.verificationMethod) {
    if (publicKeyMultibase && "publicKeyMultibase" in method) {
      if (publicKeyMultibase === method.publicKeyMultibase) {
        return method.id;
      }
    } else if (publicKeyJwk && "crv" in publicKeyJwk && "publicKeyJwk" in method && "crv" in method.publicKeyJwk) {
      if (publicKeyJwk.crv === method.publicKeyJwk.crv && publicKeyJwk.x === method.publicKeyJwk.x) {
        return method.id;
      }
    }
  }
}
function getVerificationMethodTypes(options) {
  const { didDocument } = options;
  let types = [];
  for (let key in didDocument) {
    if (typeof didDocument[key] === "object") {
      types = types.concat(getVerificationMethodTypes({
        didDocument: didDocument[key]
      }));
    } else if (key === "type") {
      types.push(didDocument[key]);
    }
  }
  return [...new Set(types)];
}
function isDwnServiceEndpoint(endpoint) {
  return endpoint !== void 0 && typeof endpoint !== "string" && !Array.isArray(endpoint) && "nodes" in endpoint && "signingKeys" in endpoint;
}
function parseDid({ didUrl }) {
  const parsedDid = (0, import_did_resolver.parse)(didUrl);
  return parsedDid;
}

// dist/esm/did-ion.js
var __awaiter4 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OperationType2;
(function(OperationType3) {
  OperationType3["Create"] = "create";
  OperationType3["Update"] = "update";
  OperationType3["Deactivate"] = "deactivate";
  OperationType3["Recover"] = "recover";
})(OperationType2 || (OperationType2 = {}));
var VerificationRelationshipToIonPublicKeyPurpose = {
  assertionMethod: IonPublicKeyPurpose_default.AssertionMethod,
  authentication: IonPublicKeyPurpose_default.Authentication,
  capabilityDelegation: IonPublicKeyPurpose_default.CapabilityDelegation,
  capabilityInvocation: IonPublicKeyPurpose_default.CapabilityInvocation,
  keyAgreement: IonPublicKeyPurpose_default.KeyAgreement
};
var DidIonMethod = class {
  static anchor(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { challengeEnabled = true, challengeEndpoint = "https://beta.ion.msidentity.com/api/v1.0/proof-of-work-challenge", keySet, services, operationsEndpoint = "https://beta.ion.msidentity.com/api/v1.0/operations" } = options;
      const ionDocument = yield DidIonMethod.createIonDocument({
        keySet,
        services
      });
      const createRequest = yield DidIonMethod.getIonCreateRequest({
        ionDocument,
        recoveryPublicKeyJwk: keySet.recoveryKey.publicKeyJwk,
        updatePublicKeyJwk: keySet.updateKey.publicKeyJwk
      });
      let resolutionResult;
      if (challengeEnabled) {
        const response = yield import_ion_pow_sdk.default.submitIonRequest(challengeEndpoint, operationsEndpoint, JSON.stringify(createRequest));
        if (response !== void 0 && (0, import_common.universalTypeOf)(response) === "String") {
          resolutionResult = JSON.parse(response);
        }
      } else {
        const response = yield fetch(operationsEndpoint, {
          method: "POST",
          mode: "cors",
          body: JSON.stringify(createRequest),
          headers: {
            "Content-Type": "application/json"
          }
        });
        if (response.ok) {
          resolutionResult = yield response.json();
        }
      }
      return resolutionResult;
    });
  }
  static create(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      let { anchor, keyAlgorithm, keySet, services } = options !== null && options !== void 0 ? options : {};
      const did = {};
      did.keySet = yield DidIonMethod.generateKeySet({ keyAlgorithm, keySet });
      did.did = yield DidIonMethod.getLongFormDid({
        keySet: did.keySet,
        services
      });
      did.canonicalId = yield DidIonMethod.getShortFormDid({ didUrl: did.did });
      let didResolutionResult;
      if (anchor) {
        didResolutionResult = yield DidIonMethod.anchor({
          keySet: did.keySet,
          services
        });
      } else {
        didResolutionResult = yield DidIonMethod.resolve({ didUrl: did.did });
      }
      did.document = didResolutionResult.didDocument;
      return did;
    });
  }
  static decodeLongFormDid(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { didUrl } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        throw new Error(`DidIonMethod: Unable to parse DID: ${didUrl}`);
      }
      const decodedLongFormDid = import_common.Convert.base64Url(parsedDid.id.split(":").pop()).toObject();
      const createRequest = Object.assign(Object.assign({}, decodedLongFormDid), { type: OperationType2.Create });
      return createRequest;
    });
  }
  /**
   * Generates two key pairs used for authorization and encryption purposes
   * when interfacing with DWNs. The IDs of these keys are referenced in the
   * service object that includes the dwnUrls provided.
   */
  static generateDwnOptions(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const {
        signingKeyAlgorithm = "Ed25519",
        // Generate Ed25519 key pairs, by default.
        serviceId = "#dwn",
        // Use default ID value, unless overridden.
        signingKeyId = "#dwn-sig",
        // Use default key ID value, unless overridden.
        encryptionKeyId = "#dwn-enc",
        // Use default key ID value, unless overridden.
        serviceEndpointNodes
      } = options;
      const signingKeyPair = yield DidIonMethod.generateJwkKeyPair({
        keyAlgorithm: signingKeyAlgorithm,
        keyId: signingKeyId
      });
      const encryptionKeyPair = yield DidIonMethod.generateJwkKeyPair({
        keyAlgorithm: "secp256k1",
        keyId: encryptionKeyId
      });
      const keySet = {
        verificationMethodKeys: [
          Object.assign(Object.assign({}, signingKeyPair), { relationships: ["authentication"] }),
          Object.assign(Object.assign({}, encryptionKeyPair), { relationships: ["keyAgreement"] })
        ]
      };
      const serviceEndpoint = {
        encryptionKeys: [encryptionKeyId],
        nodes: serviceEndpointNodes,
        signingKeys: [signingKeyId]
      };
      const services = [{
        id: serviceId,
        serviceEndpoint,
        type: "DecentralizedWebNode"
      }];
      return { keySet, services };
    });
  }
  static generateJwkKeyPair(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { keyAlgorithm, keyId } = options;
      let cryptoKeyPair;
      switch (keyAlgorithm) {
        case "Ed25519": {
          cryptoKeyPair = yield new import_crypto2.EdDsaAlgorithm().generateKey({
            algorithm: { name: "EdDSA", namedCurve: "Ed25519" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        case "secp256k1": {
          cryptoKeyPair = yield new import_crypto2.EcdsaAlgorithm().generateKey({
            algorithm: { name: "ECDSA", namedCurve: "secp256k1" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        default: {
          throw new Error(`Unsupported crypto algorithm: '${keyAlgorithm}'`);
        }
      }
      const jwkKeyPair = yield import_crypto2.Jose.cryptoKeyToJwkPair({ keyPair: cryptoKeyPair });
      if (keyId) {
        jwkKeyPair.privateKeyJwk.kid = keyId;
        jwkKeyPair.publicKeyJwk.kid = keyId;
      } else {
        const jwkThumbprint = yield import_crypto2.Jose.jwkThumbprint({ key: jwkKeyPair.publicKeyJwk });
        jwkKeyPair.privateKeyJwk.kid = jwkThumbprint;
        jwkKeyPair.publicKeyJwk.kid = jwkThumbprint;
      }
      return jwkKeyPair;
    });
  }
  static generateKeySet(options) {
    var _a, _b;
    var _c, _d;
    return __awaiter4(this, void 0, void 0, function* () {
      let { keyAlgorithm = "Ed25519", keySet = {} } = options !== null && options !== void 0 ? options : {};
      if (keySet.verificationMethodKeys === void 0) {
        const authenticationkeyPair = yield DidIonMethod.generateJwkKeyPair({
          keyAlgorithm,
          keyId: "dwn-sig"
        });
        keySet.verificationMethodKeys = [Object.assign(Object.assign({}, authenticationkeyPair), { relationships: ["authentication"] })];
      }
      if (keySet.recoveryKey === void 0) {
        keySet.recoveryKey = yield DidIonMethod.generateJwkKeyPair({
          keyAlgorithm: "secp256k1",
          keyId: "ion-recovery-1"
        });
      }
      if (keySet.updateKey === void 0) {
        keySet.updateKey = yield DidIonMethod.generateJwkKeyPair({
          keyAlgorithm: "secp256k1",
          keyId: "ion-update-1"
        });
      }
      for (const key of [...keySet.verificationMethodKeys, keySet.recoveryKey, keySet.updateKey]) {
        if ("publicKeyJwk" in key)
          (_a = (_c = key.publicKeyJwk).kid) !== null && _a !== void 0 ? _a : _c.kid = yield import_crypto2.Jose.jwkThumbprint({ key: key.publicKeyJwk });
        if ("privateKeyJwk" in key)
          (_b = (_d = key.privateKeyJwk).kid) !== null && _b !== void 0 ? _b : _d.kid = yield import_crypto2.Jose.jwkThumbprint({ key: key.privateKeyJwk });
      }
      return keySet;
    });
  }
  /**
   * Given the W3C DID Document of a `did:ion` DID, return the identifier of
   * the verification method key that will be used for signing messages and
   * credentials, by default.
   *
   * @param document = DID Document to get the default signing key from.
   * @returns Verification method identifier for the default signing key.
   */
  static getDefaultSigningKey(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { didDocument } = options;
      if (!didDocument.id) {
        throw new Error(`DidIonMethod: DID document is missing 'id' property`);
      }
      const [dwnService] = getServices({ didDocument, type: "DecentralizedWebNode" });
      if (isDwnServiceEndpoint(dwnService === null || dwnService === void 0 ? void 0 : dwnService.serviceEndpoint)) {
        const [verificationMethodId] = dwnService.serviceEndpoint.signingKeys;
        const did = didDocument.id;
        const signingKeyId = `${did}${verificationMethodId}`;
        return signingKeyId;
      }
      if (didDocument.authentication && Array.isArray(didDocument.authentication) && didDocument.authentication.length > 0 && typeof didDocument.authentication[0] === "string") {
        const [verificationMethodId] = didDocument.authentication;
        const did = didDocument.id;
        const signingKeyId = `${did}${verificationMethodId}`;
        return signingKeyId;
      }
    });
  }
  static getLongFormDid(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { services = [], keySet } = options;
      const ionDocument = yield DidIonMethod.createIonDocument({
        keySet,
        services
      });
      const recoveryKey = DidIonMethod.jwkToIonJwk({ key: keySet.recoveryKey.publicKeyJwk });
      const updateKey = DidIonMethod.jwkToIonJwk({ key: keySet.updateKey.publicKeyJwk });
      const did = yield IonDid.createLongFormDid({
        document: ionDocument,
        recoveryKey,
        updateKey
      });
      return did;
    });
  }
  static getShortFormDid(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { didUrl } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        throw new Error(`DidIonMethod: Unable to parse DID: ${didUrl}`);
      }
      const shortFormDid = parsedDid.did.split(":", 3).join(":");
      return shortFormDid;
    });
  }
  static resolve(options) {
    var _a;
    return __awaiter4(this, void 0, void 0, function* () {
      const { didUrl, resolutionOptions = {} } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      if (parsedDid.method !== "ion") {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const { resolutionEndpoint = "https://discover.did.msidentity.com/1.0/identifiers/" } = resolutionOptions;
      const normalizeUrl = (url) => url.endsWith("/") ? url : url + "/";
      const resolutionUrl = `${normalizeUrl(resolutionEndpoint)}${parsedDid.did}`;
      const response = yield fetch(resolutionUrl);
      let resolutionResult;
      try {
        resolutionResult = yield response.json();
      } catch (error2) {
        resolutionResult = {};
      }
      if (response.ok) {
        return resolutionResult;
      }
      if ("didResolutionMetadata" in resolutionResult) {
        return resolutionResult;
      }
      let error = "internalError";
      let errorMessage = `DID resolver responded with HTTP status code: ${response.status}`;
      if ("error" in resolutionResult && typeof resolutionResult.error === "object" && "code" in resolutionResult.error && typeof resolutionResult.error.code === "string" && "message" in resolutionResult.error && typeof resolutionResult.error.message === "string") {
        error = resolutionResult.error.code.includes("not_found") ? "notFound" : error;
        errorMessage = (_a = resolutionResult.error.message) !== null && _a !== void 0 ? _a : errorMessage;
      }
      return {
        "@context": "https://w3id.org/did-resolution/v1",
        didDocument: void 0,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          contentType: "application/did+ld+json",
          error,
          errorMessage
        }
      };
    });
  }
  static createIonDocument(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { services = [], keySet } = options;
      const ionPublicKeys = [];
      for (const key of keySet.verificationMethodKeys) {
        const ionPurposes = [];
        for (const relationship of key.relationships) {
          ionPurposes.push(VerificationRelationshipToIonPublicKeyPurpose[relationship]);
        }
        const publicKeyId = key.publicKeyJwk.kid.startsWith("#") ? key.publicKeyJwk.kid.substring(1) : key.publicKeyJwk.kid;
        const publicKey = {
          id: publicKeyId,
          publicKeyJwk: DidIonMethod.jwkToIonJwk({ key: key.publicKeyJwk }),
          purposes: ionPurposes,
          type: "JsonWebKey2020"
        };
        ionPublicKeys.push(publicKey);
      }
      const ionServices = services.map((service) => Object.assign(Object.assign({}, service), { id: service.id.startsWith("#") ? service.id.substring(1) : service.id }));
      const ionDocumentModel = {
        publicKeys: ionPublicKeys,
        services: ionServices
      };
      return ionDocumentModel;
    });
  }
  static getIonCreateRequest(options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { ionDocument, recoveryPublicKeyJwk, updatePublicKeyJwk } = options;
      const createRequest = yield IonRequest.createCreateRequest({
        document: ionDocument,
        recoveryKey: DidIonMethod.jwkToIonJwk({ key: recoveryPublicKeyJwk }),
        updateKey: DidIonMethod.jwkToIonJwk({ key: updatePublicKeyJwk })
      });
      return createRequest;
    });
  }
  static jwkToIonJwk({ key }) {
    let ionJwk = {};
    if ("crv" in key) {
      ionJwk.crv = key.crv;
      ionJwk.kty = key.kty;
      ionJwk.x = key.x;
      if ("d" in key)
        ionJwk.d = key.d;
      if ("y" in key && key.y) {
        return Object.assign(Object.assign({}, ionJwk), { y: key.y });
      }
      return Object.assign({}, ionJwk);
    }
    throw new Error(`jwkToIonJwk: Unsupported key algorithm.`);
  }
};
DidIonMethod.methodName = "ion";

// dist/esm/did-key.js
var import_common2 = require("@web5/common");
var import_utils2 = require("@web5/crypto/utils");
var import_crypto3 = require("@web5/crypto");
var __awaiter5 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SupportedPublicKeyFormats = [
  "Ed25519VerificationKey2020",
  "JsonWebKey2020",
  "X25519KeyAgreementKey2020"
];
var VERIFICATION_METHOD_TYPES = {
  "Ed25519VerificationKey2020": "https://w3id.org/security/suites/ed25519-2020/v1",
  "JsonWebKey2020": "https://w3id.org/security/suites/jws-2020/v1",
  "X25519KeyAgreementKey2020": "https://w3id.org/security/suites/x25519-2020/v1"
};
var MULTICODEC_PUBLIC_KEY_LENGTH = {
  // secp256k1-pub - Secp256k1 public key (compressed) - 33 bytes
  231: 33,
  // x25519-pub - Curve25519 public key - 32 bytes
  236: 32,
  // ed25519-pub - Ed25519 public key - 32 bytes
  237: 32
};
var DidKeyMethod = class {
  static create(options) {
    var _a, _b;
    return __awaiter5(this, void 0, void 0, function* () {
      let { enableEncryptionKeyDerivation = false, keyAlgorithm, keySet, publicKeyFormat = "JsonWebKey2020" } = options !== null && options !== void 0 ? options : {};
      if (keySet === void 0) {
        keySet = yield DidKeyMethod.generateKeySet({ keyAlgorithm });
      }
      const portableDid = {};
      let multibaseId = "";
      if ((_b = (_a = keySet.verificationMethodKeys) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.publicKeyJwk) {
        const publicKeyJwk = keySet.verificationMethodKeys[0].publicKeyJwk;
        multibaseId = yield import_crypto3.Jose.jwkToMultibaseId({ key: publicKeyJwk });
      }
      if (!multibaseId) {
        throw new Error("DidKeyMethod: Failed to create DID with given input.");
      }
      portableDid.did = `did:key:${multibaseId}`;
      portableDid.document = yield DidKeyMethod.createDocument({
        did: portableDid.did,
        publicKeyFormat,
        enableEncryptionKeyDerivation
      });
      portableDid.keySet = keySet;
      return portableDid;
    });
  }
  /**
   * Expands a did:key identifier to a DID Document.
   *
   * Reference: https://w3c-ccg.github.io/did-method-key/#document-creation-algorithm
   *
   * @param options
   * @returns - A DID dodcument.
   */
  static createDocument(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { defaultContext = "https://www.w3.org/ns/did/v1", did, enableEncryptionKeyDerivation = false, enableExperimentalPublicKeyTypes = false, publicKeyFormat = "JsonWebKey2020" } = options;
      const document = {};
      let multibaseValue;
      try {
        ({ id: multibaseValue } = parseDid({ didUrl: did }));
      } catch (error) {
        throw new Error(`invalidDid: Unknown format: ${did}`);
      }
      if (!DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      const signatureVerificationMethod = yield DidKeyMethod.createSignatureMethod({
        did,
        enableExperimentalPublicKeyTypes,
        multibaseValue,
        publicKeyFormat
      });
      document.id = did;
      document.verificationMethod = [signatureVerificationMethod];
      document.authentication = [signatureVerificationMethod.id];
      document.assertionMethod = [signatureVerificationMethod.id];
      document.capabilityInvocation = [signatureVerificationMethod.id];
      document.capabilityDelegation = [signatureVerificationMethod.id];
      if (enableEncryptionKeyDerivation === true) {
        const encryptionPublicKeyFormat = publicKeyFormat === "Ed25519VerificationKey2020" ? "X25519KeyAgreementKey2020" : "JsonWebKey2020";
        const encryptionVerificationMethod = yield this.createEncryptionMethod({
          did,
          enableExperimentalPublicKeyTypes,
          multibaseValue,
          publicKeyFormat: encryptionPublicKeyFormat
        });
        document.verificationMethod.push(encryptionVerificationMethod);
        document.keyAgreement = [encryptionVerificationMethod.id];
      }
      const contextArray = [defaultContext];
      const verificationMethodTypes = getVerificationMethodTypes({ didDocument: document });
      verificationMethodTypes.forEach((typeName) => {
        const typeUrl = VERIFICATION_METHOD_TYPES[typeName];
        contextArray.push(typeUrl);
      });
      document["@context"] = contextArray;
      return document;
    });
  }
  /**
   * Decoding a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying that encrypted information will be
   * received by the intended recipient.
   */
  static createEncryptionMethod(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { did, enableExperimentalPublicKeyTypes, multibaseValue, publicKeyFormat } = options;
      const verificationMethod = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue } = yield DidKeyMethod.deriveEncryptionKey({ multibaseValue });
      const actualLength = rawPublicKeyBytes.byteLength;
      const expectedLength = MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new Error(`invalidPublicKeyLength: Expected ${actualLength} bytes. Actual ${expectedLength} bytes.`);
      }
      const kemMultibaseValue = (0, import_utils2.keyToMultibaseId)({
        key: rawPublicKeyBytes,
        multicodecCode: multicodecValue
      });
      verificationMethod.id = `${did}#${kemMultibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new Error("invalidDidUrl: Verification Method ID is not a valid DID URL.");
      }
      if (!SupportedPublicKeyFormats.includes(publicKeyFormat)) {
        throw new Error(`unsupportedPublicKeyType: Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "X25519KeyAgreementKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new Error(`invalidPublicKeyType: Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = did;
      if (!DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      if (publicKeyFormat === "X25519KeyAgreementKey2020") {
        verificationMethod.publicKeyMultibase = kemMultibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const jwkParams = yield import_crypto3.Jose.multicodecToJose({ code: multicodecValue });
        const jsonWebKey = yield import_crypto3.Jose.keyToJwk(Object.assign({ keyMaterial: rawPublicKeyBytes, keyType: "public" }, jwkParams));
        if ("x" in jsonWebKey && !("d" in jsonWebKey)) {
          verificationMethod.publicKeyJwk = jsonWebKey;
        }
      }
      return verificationMethod;
    });
  }
  /**
   * Transform a multibase-encoded multicodec value to public encryption key
   * components that are suitable for encrypting messages to a receiver. A
   * mathematical proof elaborating on the safety of performing this operation
   * is available in:
   * {@link https://eprint.iacr.org/2021/509.pdf | On using the same key pair for Ed25519 and an X25519 based KEM}
   */
  static deriveEncryptionKey(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { multibaseValue } = options;
      let publicEncryptionKey = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue } = (0, import_utils2.multibaseIdToKey)({ multibaseKeyId: multibaseValue });
      if (multicodecValue === 237) {
        const generatedPublicEncryptionKeyBytes = yield import_crypto3.Ed25519.convertPublicKeyToX25519({
          publicKey: rawPublicKeyBytes
        });
        publicEncryptionKey = {
          key: generatedPublicEncryptionKeyBytes,
          multicodecCode: 236
        };
      }
      return publicEncryptionKey;
    });
  }
  /**
   * Decodes a multibase-encoded multicodec value into a verification method
   * that is suitable for verifying digital signatures.
   * @param options - Signature method creation algorithm inputs.
   * @returns - A verification method.
   */
  static createSignatureMethod(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { did, enableExperimentalPublicKeyTypes, multibaseValue, publicKeyFormat } = options;
      const verificationMethod = {};
      const { key: rawPublicKeyBytes, multicodecCode: multicodecValue, multicodecName } = (0, import_utils2.multibaseIdToKey)({ multibaseKeyId: multibaseValue });
      const actualLength = rawPublicKeyBytes.byteLength;
      const expectedLength = MULTICODEC_PUBLIC_KEY_LENGTH[multicodecValue];
      if (actualLength !== expectedLength) {
        throw new Error(`invalidPublicKeyLength: Expected ${actualLength} bytes. Actual ${expectedLength} bytes.`);
      }
      let isValid = false;
      switch (multicodecName) {
        case "secp256k1-pub":
          isValid = yield import_crypto3.Secp256k1.validatePublicKey({ key: rawPublicKeyBytes });
          break;
        case "ed25519-pub":
          isValid = yield import_crypto3.Ed25519.validatePublicKey({ key: rawPublicKeyBytes });
          break;
        case "x25519-pub":
          isValid = true;
          break;
      }
      if (!isValid) {
        throw new Error("invalidPublicKey: Invalid public key detected.");
      }
      verificationMethod.id = `${did}#${multibaseValue}`;
      try {
        new URL(verificationMethod.id);
      } catch (error) {
        throw new Error("invalidDidUrl: Verification Method ID is not a valid DID URL.");
      }
      if (!SupportedPublicKeyFormats.includes(publicKeyFormat)) {
        throw new Error(`unsupportedPublicKeyType: Unsupported format: ${publicKeyFormat}`);
      }
      const StandardPublicKeyTypes = ["Multikey", "JsonWebKey2020", "Ed25519VerificationKey2020"];
      if (enableExperimentalPublicKeyTypes === false && !StandardPublicKeyTypes.includes(publicKeyFormat)) {
        throw new Error(`invalidPublicKeyType: Specified '${publicKeyFormat}' without setting enableExperimentalPublicKeyTypes to true.`);
      }
      verificationMethod.type = publicKeyFormat;
      verificationMethod.controller = did;
      if (!DidKeyMethod.validateIdentifier({ did })) {
        throw new Error(`invalidDid: Invalid identifier format: ${did}`);
      }
      if (publicKeyFormat === "Ed25519VerificationKey2020") {
        verificationMethod.publicKeyMultibase = multibaseValue;
      }
      if (publicKeyFormat === "JsonWebKey2020") {
        const jwkParams = yield import_crypto3.Jose.multicodecToJose({ code: multicodecValue });
        const jsonWebKey = yield import_crypto3.Jose.keyToJwk(Object.assign({ keyMaterial: rawPublicKeyBytes, keyType: "public" }, jwkParams));
        if ("x" in jsonWebKey && !("d" in jsonWebKey)) {
          verificationMethod.publicKeyJwk = jsonWebKey;
        }
      }
      return verificationMethod;
    });
  }
  static generateKeySet(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { keyAlgorithm = "Ed25519" } = options !== null && options !== void 0 ? options : {};
      let keyPair;
      switch (keyAlgorithm) {
        case "Ed25519": {
          keyPair = yield new import_crypto3.EdDsaAlgorithm().generateKey({
            algorithm: { name: "EdDSA", namedCurve: "Ed25519" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        case "secp256k1": {
          keyPair = yield new import_crypto3.EcdsaAlgorithm().generateKey({
            algorithm: { name: "ECDSA", namedCurve: "secp256k1" },
            extractable: true,
            keyUsages: ["sign", "verify"]
          });
          break;
        }
        default: {
          throw new Error(`Unsupported crypto algorithm: '${keyAlgorithm}'`);
        }
      }
      const publicKeyJwk = yield import_crypto3.Jose.cryptoKeyToJwk({ key: keyPair.publicKey });
      const privateKeyJwk = yield import_crypto3.Jose.cryptoKeyToJwk({ key: keyPair.privateKey });
      const keySet = {
        verificationMethodKeys: [{
          publicKeyJwk,
          privateKeyJwk,
          relationships: ["authentication"]
        }]
      };
      return keySet;
    });
  }
  /**
   * Given the W3C DID Document of a `did:key` DID, return the identifier of
   * the verification method key that will be used for signing messages and
   * credentials, by default.
   *
   * @param document = DID Document to get the default signing key from.
   * @returns Verification method identifier for the default signing key.
   */
  static getDefaultSigningKey(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { didDocument } = options;
      if (didDocument.authentication && Array.isArray(didDocument.authentication) && didDocument.authentication.length > 0 && typeof didDocument.authentication[0] === "string") {
        const [verificationMethodId] = didDocument.authentication;
        const signingKeyId = verificationMethodId;
        return signingKeyId;
      }
    });
  }
  static resolve(options) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { didUrl, resolutionOptions: _ } = options;
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      if (parsedDid.method !== "key") {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const didDocument = yield DidKeyMethod.createDocument({ did: parsedDid.did });
      return {
        "@context": "https://w3id.org/did-resolution/v1",
        didDocument,
        didDocumentMetadata: {},
        didResolutionMetadata: {
          contentType: "application/did+ld+json",
          did: {
            didString: parsedDid.did,
            methodSpecificId: parsedDid.id,
            method: parsedDid.method
          }
        }
      };
    });
  }
  static validateIdentifier(options) {
    const { did } = options;
    const { method, id: multibaseValue } = parseDid({ didUrl: did });
    const [scheme] = did.split(":", 1);
    const version = "1";
    return scheme !== "did" || method !== "key" || parseInt(version) > 0 || (0, import_common2.universalTypeOf)(multibaseValue) !== "String" || !multibaseValue.startsWith("z");
  }
};
DidKeyMethod.methodName = "key";

// dist/esm/resolver-cache-noop.js
var DidResolverCacheNoop = {
  get: function(_key) {
    return null;
  },
  set: function(_key, _value) {
    return null;
  },
  delete: function(_key) {
    return null;
  },
  clear: function() {
    return null;
  },
  close: function() {
    return null;
  }
};

// dist/esm/did-resolver.js
var __awaiter6 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidResolver = class {
  /**
   * Constructs a new `DidResolver`.
   *
   * @param options - The options for constructing the `DidResolver`.
   * @param options.didResolvers - An array of `DidMethodResolver` instances.
   * @param options.cache - Optional. A cache for storing resolved DID documents. If not provided, a no-operation cache is used.
   */
  constructor(options) {
    this.didResolvers = /* @__PURE__ */ new Map();
    this.cache = options.cache || DidResolverCacheNoop;
    for (const resolver of options.didResolvers) {
      this.didResolvers.set(resolver.methodName, resolver);
    }
  }
  /**
   * Resolves a DID to a DID Resolution Result.
   * If the DID Resolution Result is present in the cache, it returns the cached
   * result. Otherwise, it uses the appropriate method resolver to resolve
   * the DID, stores the resolution result in the cache, and returns the
   * resolultion result.
   *
   * Note: The method signature for resolve() in this implementation must match
   * the `DidResolver` implementation in
   * {@link https://github.com/TBD54566975/dwn-sdk-js | dwn-sdk-js} so that
   * Web5 apps and the underlying DWN instance can share the same DID
   * resolution cache.
   *
   * @param didUrl - The DID or DID URL to resolve.
   * @returns A promise that resolves to the DID Resolution Result.
   */
  resolve(didUrl, resolutionOptions) {
    return __awaiter6(this, void 0, void 0, function* () {
      const parsedDid = parseDid({ didUrl });
      if (!parsedDid) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "invalidDid",
            errorMessage: `Cannot parse DID: ${didUrl}`
          }
        };
      }
      const resolver = this.didResolvers.get(parsedDid.method);
      if (!resolver) {
        return {
          "@context": "https://w3id.org/did-resolution/v1",
          didDocument: void 0,
          didDocumentMetadata: {},
          didResolutionMetadata: {
            contentType: "application/did+ld+json",
            error: "methodNotSupported",
            errorMessage: `Method not supported: ${parsedDid.method}`
          }
        };
      }
      const cachedResolutionResult = yield this.cache.get(parsedDid.did);
      if (cachedResolutionResult) {
        return cachedResolutionResult;
      } else {
        const resolutionResult = yield resolver.resolve({
          didUrl: parsedDid.did,
          resolutionOptions
        });
        yield this.cache.set(parsedDid.did, resolutionResult);
        return resolutionResult;
      }
    });
  }
};

// dist/esm/resolver-cache-level.js
var import_ms = __toESM(require("ms"), 1);
var import_level = require("level");
var __awaiter7 = function(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DidResolverCacheLevel = class {
  constructor(options = {}) {
    let { location, ttl } = options;
    location !== null && location !== void 0 ? location : location = DidResolverCacheLevel.defaultOptions.location;
    ttl !== null && ttl !== void 0 ? ttl : ttl = DidResolverCacheLevel.defaultOptions.ttl;
    this.cache = new import_level.Level(location);
    this.ttl = (0, import_ms.default)(ttl);
  }
  get(did) {
    return __awaiter7(this, void 0, void 0, function* () {
      try {
        const str3 = yield this.cache.get(did);
        const cacheWrapper = JSON.parse(str3);
        if (Date.now() >= cacheWrapper.ttlMillis) {
          this.cache.nextTick(() => this.cache.del(did));
          return;
        } else {
          return cacheWrapper.value;
        }
      } catch (error) {
        if (error.code === "LEVEL_NOT_FOUND") {
          return;
        }
        throw error;
      }
    });
  }
  set(did, value) {
    const cacheWrapper = { ttlMillis: Date.now() + this.ttl, value };
    const str3 = JSON.stringify(cacheWrapper);
    return this.cache.put(did, str3);
  }
  delete(did) {
    return this.cache.del(did);
  }
  clear() {
    return this.cache.clear();
  }
  close() {
    return this.cache.close();
  }
};
DidResolverCacheLevel.defaultOptions = {
  location: "DATA/AGENT/DID_RESOLVERCACHE",
  ttl: "15m"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DidIonMethod,
  DidKeyMethod,
  DidResolver,
  DidResolverCacheLevel,
  DidResolverCacheNoop,
  utils
});
/*! Bundled license information:

uri-js/dist/es5/uri.all.js:
  (** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js *)

@noble/ed25519/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/secp256k1/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.js.map
