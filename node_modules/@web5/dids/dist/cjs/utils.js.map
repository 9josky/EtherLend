{
  "version": 3,
  "sources": ["../../src/utils.ts"],
  "sourcesContent": ["import type { PublicKeyJwk } from '@web5/crypto';\nimport { parse, type ParsedDID } from 'did-resolver';\n\nimport type { DidDocument, DidService, DidServiceEndpoint, DwnServiceEndpoint } from './types.js';\n\nexport interface ParsedDid {\n  did: string\n  didUrl: string\n  method: string\n  id: string\n  path?: string\n  fragment?: string\n  query?: string\n  params?: ParsedDID['params']\n}\n\nexport const DID_REGEX = /^did:([a-z0-9]+):((?:(?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))*:)*((?:[a-zA-Z0-9._-]|(?:%[0-9a-fA-F]{2}))+))((;[a-zA-Z0-9_.:%-]+=[a-zA-Z0-9_.:%-]*)*)(\\/[^#?]*)?([?][^#]*)?(#.*)?$/;\n\n/**\n * Retrieves services from a given DID document based on provided options.\n * If no `id` or `type` filters are provided, all defined services are returned.\n *\n * Note: The DID document must adhere to the W3C DID specification.\n *\n * @param options - An object containing input parameters for retrieving services.\n * @param options.didDocument - The DID document from which services are retrieved.\n * @param options.id - Optional. A string representing the specific service ID to match. If provided, only the service with this ID will be returned.\n * @param options.type - Optional. A string representing the specific service type to match. If provided, only the service(s) of this type will be returned.\n *\n * @returns An array of services. If no matching service is found, an empty array is returned.\n *\n * @example\n *\n * const didDoc = { ... }; // W3C DID document\n * const services = getServices({ didDocument: didDoc, type: 'DecentralizedWebNode' });\n */\nexport function getServices(options: {\n  didDocument: DidDocument,\n  id?: string,\n  type?: string\n}): DidService[] {\n  const { didDocument, id, type } = options ?? {};\n\n  return didDocument?.service?.filter(service => {\n    if (id && service.id !== id) return false;\n    if (type && service.type !== type) return false;\n    return true;\n  }) ?? [ ];\n}\n\nexport function getVerificationMethodIds(options: {\n  didDocument: DidDocument,\n  publicKeyJwk?: PublicKeyJwk,\n  publicKeyMultibase?: string\n}): string | undefined {\n  const { didDocument, publicKeyJwk, publicKeyMultibase } = options;\n  if (!didDocument) throw new Error(`Required parameter missing: 'didDocument'`);\n  if (!didDocument.verificationMethod) throw new Error('Given `didDocument` is missing `verificationMethod` entries.');\n\n  for (let method of didDocument.verificationMethod) {\n    if (publicKeyMultibase && 'publicKeyMultibase' in method) {\n      if (publicKeyMultibase === method.publicKeyMultibase) {\n        return method.id;\n      }\n    } else if (publicKeyJwk && 'crv' in publicKeyJwk &&\n               'publicKeyJwk' in method && 'crv' in method.publicKeyJwk) {\n      if (publicKeyJwk.crv === method.publicKeyJwk.crv &&\n            publicKeyJwk.x === method.publicKeyJwk.x) {\n        return method.id;\n      }\n    }\n  }\n}\n\n/**\n * Retrieves DID verification method types from a given DID document.\n *\n * Note: The DID document must adhere to the W3C DID specification.\n *\n * @param options - An object containing input parameters for retrieving types.\n * @param options.didDocument - The DID document from which types are retrieved.\n *\n * @returns An array of types. If no types were found, an empty array is returned.\n */\nexport function getVerificationMethodTypes(options: {\n  didDocument: Record<string, any>\n}): string[] {\n  const { didDocument } = options;\n\n  let types: string[] = [];\n\n  for (let key in didDocument) {\n    if (typeof didDocument[key] === 'object') {\n      types = types.concat(getVerificationMethodTypes({\n        didDocument: didDocument[key]\n      }));\n\n    } else if (key === 'type') {\n      types.push(didDocument[key]);\n    }\n  }\n\n  return [...new Set(types)]; // return only unique types\n}\n\n/**\n * Type guard function to check if the given endpoint is a DwnServiceEndpoint.\n *\n * @param key The endpoint to check.\n * @returns True if the endpoint is a DwnServiceEndpoint, false otherwise.\n */\nexport function isDwnServiceEndpoint(endpoint: string | DidServiceEndpoint | DidServiceEndpoint[]): endpoint is DwnServiceEndpoint {\n  return endpoint !== undefined &&\n    typeof endpoint !== 'string' &&\n    !Array.isArray(endpoint) &&\n    'nodes' in endpoint &&\n    'signingKeys' in endpoint;\n}\n\nexport function parseDid({ didUrl }: { didUrl: string }): ParsedDid | undefined {\n  const parsedDid: ParsedDid = parse(didUrl);\n\n  return parsedDid;\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AACA;;;;;;;;;;0BAAsC;AAe/B,IAAM,YAAY;AAoBnB,SAAU,YAAY,SAI3B;;AACC,QAAM,EAAE,aAAa,IAAI,KAAI,IAAK,YAAO,QAAP,YAAO,SAAP,UAAW,CAAA;AAE7C,UAAO,MAAA,KAAA,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,aAAO,QAAA,OAAA,SAAA,SAAA,GAAE,OAAO,aAAU;AAC5C,QAAI,MAAM,QAAQ,OAAO;AAAI,aAAO;AACpC,QAAI,QAAQ,QAAQ,SAAS;AAAM,aAAO;AAC1C,WAAO;EACT,CAAC,OAAC,QAAA,OAAA,SAAA,KAAI,CAAA;AACR;AAEM,SAAU,yBAAyB,SAIxC;AACC,QAAM,EAAE,aAAa,cAAc,mBAAkB,IAAK;AAC1D,MAAI,CAAC;AAAa,UAAM,IAAI,MAAM,2CAA2C;AAC7E,MAAI,CAAC,YAAY;AAAoB,UAAM,IAAI,MAAM,8DAA8D;AAEnH,WAAS,UAAU,YAAY,oBAAoB;AACjD,QAAI,sBAAsB,wBAAwB,QAAQ;AACxD,UAAI,uBAAuB,OAAO,oBAAoB;AACpD,eAAO,OAAO;;eAEP,gBAAgB,SAAS,gBACzB,kBAAkB,UAAU,SAAS,OAAO,cAAc;AACnE,UAAI,aAAa,QAAQ,OAAO,aAAa,OACvC,aAAa,MAAM,OAAO,aAAa,GAAG;AAC9C,eAAO,OAAO;;;;AAItB;AAYM,SAAU,2BAA2B,SAE1C;AACC,QAAM,EAAE,YAAW,IAAK;AAExB,MAAI,QAAkB,CAAA;AAEtB,WAAS,OAAO,aAAa;AAC3B,QAAI,OAAO,YAAY,GAAG,MAAM,UAAU;AACxC,cAAQ,MAAM,OAAO,2BAA2B;QAC9C,aAAa,YAAY,GAAG;OAC7B,CAAC;eAEO,QAAQ,QAAQ;AACzB,YAAM,KAAK,YAAY,GAAG,CAAC;;;AAI/B,SAAO,CAAC,GAAG,IAAI,IAAI,KAAK,CAAC;AAC3B;AAQM,SAAU,qBAAqB,UAA4D;AAC/F,SAAO,aAAa,UAClB,OAAO,aAAa,YACpB,CAAC,MAAM,QAAQ,QAAQ,KACvB,WAAW,YACX,iBAAiB;AACrB;AAEM,SAAU,SAAS,EAAE,OAAM,GAAsB;AACrD,QAAM,gBAAuB,2BAAM,MAAM;AAEzC,SAAO;AACT;",
  "names": []
}
