var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { isEmptyObject } from '@web5/common';
import { DwnInterfaceName, DwnMethodName } from '@tbd54566975/dwn-sdk-js';
import { Record } from './record.js';
import { Protocol } from './protocol.js';
import { dataToBlob } from './utils.js';
/**
 * Interface to interact with DWN Records and Protocols
 *
 * @beta
 */
export class DwnApi {
    constructor(options) {
        this.agent = options.agent;
        this.connectedDid = options.connectedDid;
    }
    /**
     * API to interact with DWN protocols (e.g., `dwn.protocols.configure()`).
     */
    get protocols() {
        return {
            /**
             * Configure method, used to setup a new protocol (or update) with the passed definitions
             */
            configure: (request) => __awaiter(this, void 0, void 0, function* () {
                const agentResponse = yield this.agent.processDwnRequest({
                    target: this.connectedDid,
                    author: this.connectedDid,
                    messageOptions: request.message,
                    messageType: DwnInterfaceName.Protocols + DwnMethodName.Configure
                });
                const { message, messageCid, reply: { status } } = agentResponse;
                const response = { status };
                if (status.code < 300) {
                    const metadata = { author: this.connectedDid, messageCid };
                    response.protocol = new Protocol(this.agent, message, metadata);
                }
                return response;
            }),
            /**
             * Query the available protocols
             */
            query: (request) => __awaiter(this, void 0, void 0, function* () {
                const agentRequest = {
                    author: this.connectedDid,
                    messageOptions: request.message,
                    messageType: DwnInterfaceName.Protocols + DwnMethodName.Query,
                    target: request.from || this.connectedDid
                };
                let agentResponse;
                if (request.from) {
                    agentResponse = yield this.agent.sendDwnRequest(agentRequest);
                }
                else {
                    agentResponse = yield this.agent.processDwnRequest(agentRequest);
                }
                const { reply: { entries = [], status } } = agentResponse;
                const protocols = entries.map((entry) => {
                    const metadata = { author: this.connectedDid, };
                    // FIXME: dwn-sdk-js actually returns the entire ProtocolsConfigure message,
                    //        but the type claims that it returns the message without authorization.
                    //        When dwn-sdk-js fixes the type, we should remove `as ProtocolsConfigureMessage`
                    return new Protocol(this.agent, entry, metadata);
                });
                return { protocols, status };
            })
        };
    }
    /**
     * API to interact with DWN records (e.g., `dwn.records.create()`).
     */
    get records() {
        return {
            /**
             * Alias for the `write` method
             */
            create: (request) => __awaiter(this, void 0, void 0, function* () {
                return this.records.write(request);
            }),
            /**
             * Write a record based on an existing one (useful for updating an existing record)
             */
            createFrom: (request) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const _b = request.record.toJSON(), { author: inheritedAuthor } = _b, inheritedProperties = __rest(_b, ["author"]);
                // Remove target from inherited properties since target is being explicitly defined in method parameters.
                delete inheritedProperties.target;
                // If `data` is being updated then `dataCid` and `dataSize` must not be present.
                if (request.data !== undefined) {
                    delete inheritedProperties.dataCid;
                    delete inheritedProperties.dataSize;
                }
                // If `published` is set to false, ensure that `datePublished` is undefined. Otherwise, DWN SDK's schema validation
                // will throw an error if `published` is false but `datePublished` is set.
                if (((_a = request.message) === null || _a === void 0 ? void 0 : _a.published) === false && inheritedProperties.datePublished !== undefined) {
                    delete inheritedProperties.datePublished;
                    delete inheritedProperties.published;
                }
                // If the request changes the `author` or message `descriptor` then the deterministic `recordId` will change.
                // As a result, we will discard the `recordId` if either of these changes occur.
                if (!isEmptyObject(request.message) || (request.author && request.author !== inheritedAuthor)) {
                    delete inheritedProperties.recordId;
                }
                return this.records.write({
                    data: request.data,
                    message: Object.assign(Object.assign({}, inheritedProperties), request.message),
                });
            }),
            /**
             * Delete a record
             */
            delete: (request) => __awaiter(this, void 0, void 0, function* () {
                const agentRequest = {
                    author: this.connectedDid,
                    messageOptions: request.message,
                    messageType: DwnInterfaceName.Records + DwnMethodName.Delete,
                    target: request.from || this.connectedDid
                };
                let agentResponse;
                if (request.from) {
                    agentResponse = yield this.agent.sendDwnRequest(agentRequest);
                }
                else {
                    agentResponse = yield this.agent.processDwnRequest(agentRequest);
                }
                //! TODO: (Frank -> Moe): This quirk is the result of how 4XX errors are being returned by `dwn-server`
                //!                       When DWN SDK returns 404, agentResponse is { status: { code: 404 }} and that's it.
                //!                       Need to decide how to resolve.
                let status;
                if (agentResponse.reply) {
                    ({ reply: { status } } = agentResponse);
                }
                else {
                    ({ status } = agentResponse);
                }
                return { status };
            }),
            /**
             * Query a single or multiple records based on the given filter
             */
            query: (request) => __awaiter(this, void 0, void 0, function* () {
                const agentRequest = {
                    author: this.connectedDid,
                    messageOptions: request.message,
                    messageType: DwnInterfaceName.Records + DwnMethodName.Query,
                    target: request.from || this.connectedDid
                };
                let agentResponse;
                if (request.from) {
                    agentResponse = yield this.agent.sendDwnRequest(agentRequest);
                }
                else {
                    agentResponse = yield this.agent.processDwnRequest(agentRequest);
                }
                const { reply: { entries, status } } = agentResponse;
                const records = entries.map((entry) => {
                    const recordOptions = Object.assign({ author: this.connectedDid, target: this.connectedDid }, entry);
                    const record = new Record(this.agent, recordOptions);
                    return record;
                });
                return { records, status };
            }),
            /**
             * Read a single record based on the given filter
             */
            read: (request) => __awaiter(this, void 0, void 0, function* () {
                const agentRequest = {
                    author: this.connectedDid,
                    messageOptions: request.message,
                    messageType: DwnInterfaceName.Records + DwnMethodName.Read,
                    target: request.from || this.connectedDid
                };
                let agentResponse;
                if (request.from) {
                    agentResponse = yield this.agent.sendDwnRequest(agentRequest);
                }
                else {
                    agentResponse = yield this.agent.processDwnRequest(agentRequest);
                }
                //! TODO: (Frank -> Moe): This quirk is the result of how 4XX errors are being returned by `dwn-server`
                //!                       When DWN SDK returns 404, agentResponse is { status: { code: 404 }} and that's it.
                //!                       Need to decide how to resolve.
                let responseRecord;
                let status;
                if (agentResponse.reply) {
                    ({ reply: { record: responseRecord, status } } = agentResponse);
                }
                else {
                    ({ status } = agentResponse);
                }
                let record;
                if (200 <= status.code && status.code <= 299) {
                    const recordOptions = Object.assign({ author: this.connectedDid, target: this.connectedDid }, responseRecord);
                    record = new Record(this.agent, recordOptions);
                }
                return { record, status };
            }),
            /**
             * Writes a record to the DWN
             *
             * As a convenience, the Record instance returned will cache a copy of the data if the
             * data size, in bytes, is less than the DWN 'max data size allowed to be encoded'
             * parameter of 10KB. This is done to maintain consistency with other DWN methods,
             * like RecordsQuery, that include relatively small data payloads when returning
             * RecordsWrite message properties. Regardless of data size, methods such as
             * `record.data.stream()` will return the data when called even if it requires fetching
             * from the DWN datastore.
             */
            write: (request) => __awaiter(this, void 0, void 0, function* () {
                const messageOptions = Object.assign({}, request.message);
                const { dataBlob, dataFormat } = dataToBlob(request.data, messageOptions.dataFormat);
                messageOptions.dataFormat = dataFormat;
                const agentResponse = yield this.agent.processDwnRequest({
                    author: this.connectedDid,
                    dataStream: dataBlob,
                    messageOptions,
                    messageType: DwnInterfaceName.Records + DwnMethodName.Write,
                    store: request.store,
                    target: this.connectedDid
                });
                const { message, reply: { status } } = agentResponse;
                const responseMessage = message;
                let record;
                if (200 <= status.code && status.code <= 299) {
                    const recordOptions = Object.assign({ author: this.connectedDid, encodedData: dataBlob, target: this.connectedDid }, responseMessage);
                    record = new Record(this.agent, recordOptions);
                }
                return { record, status };
            }),
        };
    }
}
