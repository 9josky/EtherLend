import type { Web5Crypto } from '../types/web5-crypto.js';
export declare abstract class CryptoAlgorithm {
    /**
     * Name of the algorithm
     */
    abstract readonly name: string;
    /**
     * Indicates which cryptographic operations are permissible to be used with this algorithm.
     */
    abstract readonly keyUsages: Web5Crypto.KeyUsage[] | Web5Crypto.KeyPairUsage;
    checkAlgorithmName(options: {
        algorithmName: string;
    }): void;
    checkCryptoKey(options: {
        key: Web5Crypto.CryptoKey;
    }): void;
    checkKeyAlgorithm(options: {
        keyAlgorithmName: string;
    }): void;
    checkKeyType(options: {
        keyType: Web5Crypto.KeyType;
        allowedKeyType: Web5Crypto.KeyType;
    }): void;
    checkKeyUsages(options: {
        keyUsages: Web5Crypto.KeyUsage[];
        allowedKeyUsages: Web5Crypto.KeyUsage[] | Web5Crypto.KeyPairUsage;
    }): void;
    /**
     * Creates an instance of the class on which it is called.
     *
     * This is a generic factory method that creates an instance of any
     * crypto algorithm that extends this abstract class.
     *
     * @template T The type of the instance to be created.
     * @returns An instance of the class it is called on.
     * @throws {TypeError} If the class it is called on cannot be constructed.
     */
    static create<T extends CryptoAlgorithm>(this: new () => T): T;
    abstract decrypt(options: {
        algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.AesCtrOptions | Web5Crypto.AesGcmOptions;
        key: Web5Crypto.CryptoKey;
        data: Uint8Array;
    }): Promise<Uint8Array>;
    abstract deriveBits(options: {
        algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.EcdhDeriveKeyOptions;
        baseKey: Web5Crypto.CryptoKey;
        length: number | null;
    }): Promise<Uint8Array>;
    abstract encrypt(options: {
        algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.AesCtrOptions | Web5Crypto.AesGcmOptions;
        key: Web5Crypto.CryptoKey;
        data: Uint8Array;
    }): Promise<Uint8Array>;
    abstract generateKey(options: {
        algorithm: Partial<Web5Crypto.GenerateKeyOptions>;
        extractable: boolean;
        keyUsages: Web5Crypto.KeyUsage[];
    }): Promise<Web5Crypto.CryptoKey | Web5Crypto.CryptoKeyPair>;
    abstract sign(options: {
        algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.EcdsaOptions | Web5Crypto.EdDsaOptions;
        key: Web5Crypto.CryptoKey;
        data: Uint8Array;
    }): Promise<Uint8Array>;
    abstract verify(options: {
        algorithm: Web5Crypto.AlgorithmIdentifier | Web5Crypto.EcdsaOptions | Web5Crypto.EdDsaOptions;
        key: Web5Crypto.CryptoKey;
        signature: Uint8Array;
        data: Uint8Array;
    }): Promise<boolean>;
}
//# sourceMappingURL=crypto-algorithm.d.ts.map