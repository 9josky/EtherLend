"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoKeyWithJwk = exports.CryptoKeyToJwkMixin = exports.Jose = void 0;
var sha256_1 = require("@noble/hashes/sha256");
var common_1 = require("@web5/common");
var utils_js_1 = require("./utils.js");
var index_js_1 = require("./algorithms-api/index.js");
var index_js_2 = require("./crypto-primitives/index.js");
var joseToWebCryptoMapping = {
    'Ed25519': { name: 'EdDSA', namedCurve: 'Ed25519' },
    'Ed448': { name: 'EdDSA', namedCurve: 'Ed448' },
    'X25519': { name: 'ECDH', namedCurve: 'X25519' },
    'secp256k1:ES256K': { name: 'ECDSA', namedCurve: 'secp256k1' },
    'secp256k1': { name: 'ECDH', namedCurve: 'secp256k1' },
    'P-256': { name: 'ECDSA', namedCurve: 'P-256' },
    'P-384': { name: 'ECDSA', namedCurve: 'P-384' },
    'P-521': { name: 'ECDSA', namedCurve: 'P-521' },
    'A128CBC': { name: 'AES-CBC', length: 128 },
    'A192CBC': { name: 'AES-CBC', length: 192 },
    'A256CBC': { name: 'AES-CBC', length: 256 },
    'A128CTR': { name: 'AES-CTR', length: 128 },
    'A192CTR': { name: 'AES-CTR', length: 192 },
    'A256CTR': { name: 'AES-CTR', length: 256 },
    'A128GCM': { name: 'AES-GCM', length: 128 },
    'A192GCM': { name: 'AES-GCM', length: 192 },
    'A256GCM': { name: 'AES-GCM', length: 256 },
    'HS256': { name: 'HMAC', hash: { name: 'SHA-256' } },
    'HS384': { name: 'HMAC', hash: { name: 'SHA-384' } },
    'HS512': { name: 'HMAC', hash: { name: 'SHA-512' } },
};
var webCryptoToJoseMapping = {
    'EdDSA:Ed25519': { alg: 'EdDSA', crv: 'Ed25519', kty: 'OKP' },
    'EdDSA:Ed448': { alg: 'EdDSA', crv: 'Ed448', kty: 'OKP' },
    'ECDH:X25519': { crv: 'X25519', kty: 'OKP' },
    'ECDSA:secp256k1': { alg: 'ES256K', crv: 'secp256k1', kty: 'EC' },
    'ECDH:secp256k1': { crv: 'secp256k1', kty: 'EC' },
    'ECDSA:P-256': { alg: 'ES256', crv: 'P-256', kty: 'EC' },
    'ECDSA:P-384': { alg: 'ES384', crv: 'P-384', kty: 'EC' },
    'ECDSA:P-521': { alg: 'ES512', crv: 'P-521', kty: 'EC' },
    'AES-CBC:128': { alg: 'A128CBC', kty: 'oct' },
    'AES-CBC:192': { alg: 'A192CBC', kty: 'oct' },
    'AES-CBC:256': { alg: 'A256CBC', kty: 'oct' },
    'AES-CTR:128': { alg: 'A128CTR', kty: 'oct' },
    'AES-CTR:192': { alg: 'A192CTR', kty: 'oct' },
    'AES-CTR:256': { alg: 'A256CTR', kty: 'oct' },
    'AES-GCM:128': { alg: 'A128GCM', kty: 'oct' },
    'AES-GCM:192': { alg: 'A192GCM', kty: 'oct' },
    'AES-GCM:256': { alg: 'A256GCM', kty: 'oct' },
    'HMAC:SHA-256': { alg: 'HS256', kty: 'oct' },
    'HMAC:SHA-384': { alg: 'HS384', kty: 'oct' },
    'HMAC:SHA-512': { alg: 'HS512', kty: 'oct' },
};
var multicodecToJoseMapping = {
    'ed25519-pub': { alg: 'EdDSA', crv: 'Ed25519', kty: 'OKP', x: '' },
    'ed25519-priv': { alg: 'EdDSA', crv: 'Ed25519', kty: 'OKP', x: '', d: '' },
    'secp256k1-pub': { alg: 'ES256K', crv: 'secp256k1', kty: 'EC', x: '', y: '' },
    'secp256k1-priv': { alg: 'ES256K', crv: 'secp256k1', kty: 'EC', x: '', y: '', d: '' },
    'x25519-pub': { crv: 'X25519', kty: 'OKP', x: '' },
    'x25519-priv': { crv: 'X25519', kty: 'OKP', x: '', d: '' },
};
var joseToMulticodecMapping = {
    'Ed25519:public': 'ed25519-pub',
    'Ed25519:private': 'ed25519-priv',
    'secp256k1:public': 'secp256k1-pub',
    'secp256k1:private': 'secp256k1-priv',
    'X25519:public': 'x25519-pub',
    'X25519:private': 'x25519-priv',
};
var Jose = /** @class */ (function () {
    function Jose() {
    }
    Jose.cryptoKeyToJwk = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, algorithm, extractable, material, type, usages, jsonWebKey;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = options.key, algorithm = _a.algorithm, extractable = _a.extractable, material = _a.material, type = _a.type, usages = _a.usages;
                        jsonWebKey = Jose.webCryptoToJose(algorithm);
                        // Set extractable parameter.
                        jsonWebKey.ext = extractable ? 'true' : 'false';
                        // Set key use parameter.
                        jsonWebKey.key_ops = usages;
                        return [4 /*yield*/, Jose.keyToJwk(__assign({ keyMaterial: material, keyType: type }, jsonWebKey))];
                    case 1:
                        jsonWebKey = _b.sent();
                        return [2 /*return*/, __assign({}, jsonWebKey)];
                }
            });
        });
    };
    Jose.cryptoKeyToJwkPair = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var keyPair, privateKeyJwk, publicKeyJwk, jwkKeyPair;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        keyPair = options.keyPair;
                        return [4 /*yield*/, Jose.cryptoKeyToJwk({ key: keyPair.privateKey })];
                    case 1:
                        privateKeyJwk = _a.sent();
                        return [4 /*yield*/, Jose.cryptoKeyToJwk({ key: keyPair.publicKey })];
                    case 2:
                        publicKeyJwk = _a.sent();
                        jwkKeyPair = { privateKeyJwk: privateKeyJwk, publicKeyJwk: publicKeyJwk };
                        return [2 /*return*/, __assign({}, jwkKeyPair)];
                }
            });
        });
    };
    Jose.joseToMulticodec = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonWebKey, params, lookupKey, name, code;
            return __generator(this, function (_a) {
                jsonWebKey = options.key;
                params = [];
                if ('crv' in jsonWebKey) {
                    params.push(jsonWebKey.crv);
                    if ('d' in jsonWebKey) {
                        params.push('private');
                    }
                    else {
                        params.push('public');
                    }
                }
                lookupKey = params.join(':');
                name = joseToMulticodecMapping[lookupKey];
                if (name === undefined) {
                    throw new Error("Unsupported JOSE to Multicodec conversion: '".concat(lookupKey, "'"));
                }
                code = common_1.Multicodec.getCodeFromName({ name: name });
                return [2 /*return*/, { code: code, name: name }];
            });
        });
    };
    Jose.joseToWebCrypto = function (options) {
        var params = [];
        /**
         * All Elliptic Curve (EC) and Octet Key Pair (OKP) JSON Web Keys
         * set a value for the "crv" parameter.
         */
        if ('crv' in options && options.crv) {
            params.push(options.crv);
            // Special case for secp256k1. If alg is "ES256K", then ECDSA. Else ECDH.
            if (options.crv === 'secp256k1' && options.alg === 'ES256K') {
                params.push(options.alg);
            }
            /**
             * All Octet Sequence (oct) JSON Web Keys omit "crv" and
             * set a value for the "alg" parameter.
             */
        }
        else if (options.alg !== undefined) {
            params.push(options.alg);
        }
        else {
            throw new TypeError("One or more parameters missing: 'alg' or 'crv'");
        }
        var lookupKey = params.join(':');
        var webCrypto = joseToWebCryptoMapping[lookupKey];
        if (webCrypto === undefined) {
            throw new Error("Unsupported JOSE to WebCrypto conversion: '".concat(lookupKey, "'"));
        }
        return __assign({}, webCrypto);
    };
    /**
     * Computes the thumbprint of a JSON Web Key (JWK) using the method
     * specified in RFC 7638. This function accepts RSA, EC, OKP, and oct keys
     * and returns the thumbprint as a base64url encoded SHA-256 hash of the
     * JWK's required members, serialized and sorted lexicographically.
     *
     * Purpose:
     * - Uniquely Identifying Keys: The thumbprint allows the unique
     *   identification of a specific JWK within a set of JWKs. It provides a
     *   deterministic way to generate a value that can be used as a key
     *   identifier (kid) or to match a specific key.
     *
     * - Simplifying Key Management: In systems where multiple keys are used,
     *   managing and identifying individual keys can become complex. The
     *   thumbprint method simplifies this by creating a standardized, unique
     *   identifier for each key.
     *
     * - Enabling Interoperability: By standardizing the method to compute a
     *   thumbprint, different systems can compute the same thumbprint value for
     *   a given JWK. This enables interoperability among systems that use JWKs.
     *
     * - Secure Comparison: The thumbprint provides a way to securely compare
     *   JWKs to determine if they are equivalent.
     *
     * @param jwk - The JSON Web Key for which the thumbprint will be computed.
     *              This must be an RSA, EC, OKP, or oct key.
     * @returns The thumbprint as a base64url encoded string.
     * @throws {Error} Throws an error if the provided key type is unsupported.
     *
     * @example
     * const jwk: PublicKeyJwk = {
     *   'kty': 'EC',
     *   'crv': 'secp256k1',
     *   'x': '61iPYuGefxotzBdQZtDvv6cWHZmXrTTscY-u7Y2pFZc',
     *   'y': '88nPCVLfrAY9i-wg5ORcwVbHWC_tbeAd1JE2e0co0lU'
     * };
     *
     * const thumbprint = jwkThumbprint(jwk);
     * console.log(`JWK thumbprint: ${thumbprint}`);
     *
     * @see {@link https://datatracker.ietf.org/doc/html/rfc7638 | RFC7638} for
     * the specification of JWK thumbprint computation.
     */
    Jose.jwkThumbprint = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, keyType, normalizedJwk, serializedJwk, utf8Bytes, digest, thumbprint;
            return __generator(this, function (_a) {
                key = options.key;
                keyType = key.kty;
                if (keyType === 'EC') {
                    normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x, y: key.y };
                }
                else if (keyType === 'oct') {
                    normalizedJwk = { k: key.k, kty: key.kty };
                }
                else if (keyType === 'OKP') {
                    normalizedJwk = { crv: key.crv, kty: key.kty, x: key.x };
                }
                else if (keyType === 'RSA') {
                    normalizedJwk = { e: key.e, kty: key.kty, n: key.n };
                }
                else {
                    throw new Error("Unsupported key type: ".concat(keyType));
                }
                (0, common_1.removeUndefinedProperties)(normalizedJwk);
                serializedJwk = Jose.canonicalize(normalizedJwk);
                utf8Bytes = common_1.Convert.string(serializedJwk).toUint8Array();
                digest = (0, sha256_1.sha256)(utf8Bytes);
                thumbprint = common_1.Convert.uint8Array(digest).toBase64Url();
                return [2 /*return*/, thumbprint];
            });
        });
    };
    Jose.jwkToCryptoKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonWebKey, _a, keyMaterial, keyType, algorithm, extractable, keyUsage, cryptoKey;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        jsonWebKey = options.key;
                        return [4 /*yield*/, Jose.jwkToKey({ key: jsonWebKey })];
                    case 1:
                        _a = _b.sent(), keyMaterial = _a.keyMaterial, keyType = _a.keyType;
                        algorithm = Jose.joseToWebCrypto(jsonWebKey);
                        if ('ext' in jsonWebKey && jsonWebKey.ext !== undefined) {
                            extractable = jsonWebKey.ext === 'true' ? true : false;
                        }
                        else {
                            throw new Error("Conversion from JWK to CryptoKey failed. Required parameter missing: 'ext'");
                        }
                        if ('key_ops' in jsonWebKey && jsonWebKey.key_ops !== undefined) {
                            keyUsage = jsonWebKey.key_ops;
                        }
                        else {
                            throw new Error("Conversion from JWK to CryptoKey failed. Required parameter missing: 'key_ops'");
                        }
                        cryptoKey = new index_js_1.CryptoKey(algorithm, extractable, keyMaterial, keyType, keyUsage);
                        return [2 /*return*/, cryptoKey];
                }
            });
        });
    };
    Jose.jwkToKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonWebKey, keyMaterial, keyType, prefix, x, y, publicKey;
            return __generator(this, function (_a) {
                jsonWebKey = options.key;
                // Asymmetric private key ("EC" or "OKP" - Curve25519 or SECG curves).
                if ('d' in jsonWebKey) {
                    keyMaterial = common_1.Convert.base64Url(jsonWebKey.d).toUint8Array();
                    keyType = 'private';
                }
                // Asymmetric public key ("EC" - secp256k1, secp256r1, secp384r1, secp521r1).
                else if ('y' in jsonWebKey && jsonWebKey.y) {
                    prefix = new Uint8Array([0x04]);
                    x = common_1.Convert.base64Url(jsonWebKey.x).toUint8Array();
                    y = common_1.Convert.base64Url(jsonWebKey.y).toUint8Array();
                    publicKey = new Uint8Array(__spreadArray(__spreadArray(__spreadArray([], __read(prefix), false), __read(x), false), __read(y), false));
                    keyMaterial = publicKey;
                    keyType = 'public';
                }
                // Asymmetric public key ("OKP" - Ed25519, X25519).
                else if ('x' in jsonWebKey) {
                    keyMaterial = common_1.Convert.base64Url(jsonWebKey.x).toUint8Array();
                    keyType = 'public';
                }
                // Symmetric encryption or signature key ("oct" - AES, HMAC)
                else if ('k' in jsonWebKey) {
                    keyMaterial = common_1.Convert.base64Url(jsonWebKey.k).toUint8Array();
                    keyType = 'private';
                }
                else {
                    throw new Error('Jose: Unknown JSON Web Key format.');
                }
                return [2 /*return*/, { keyMaterial: keyMaterial, keyType: keyType }];
            });
        });
    };
    /**
    * Note: All secp public keys are converted to compressed point encoding
    *    before the multibase identifier is computed.
    *
    * Per {@link https://github.com/multiformats/multicodec/blob/master/table.csv | Multicodec table}:
    *    public keys for Elliptic Curve cryptography algorithms (e.g., secp256k1,
    *    secp256k1r1, secp384r1, etc.) are always represented with compressed point
    *    encoding (e.g., secp256k1-pub, p256-pub, p384-pub, etc.).
    *
    * Per {@link https://datatracker.ietf.org/doc/html/rfc8812#name-jose-and-cose-secp256k1-cur | RFC 8812}:
    *    "As a compressed point encoding representation is not defined for JWK
    *    elliptic curve points, the uncompressed point encoding defined there
    *    MUST be used. The x and y values represented MUST both be exactly
    *    256 bits, with any leading zeros preserved.
    *
    */
    Jose.jwkToMultibaseId = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var jsonWebKey, multicodecName, keyMaterial, _a, multibaseId;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        jsonWebKey = options.key;
                        return [4 /*yield*/, Jose.joseToMulticodec({ key: jsonWebKey })];
                    case 1:
                        multicodecName = (_b.sent()).name;
                        return [4 /*yield*/, Jose.jwkToKey({ key: jsonWebKey })];
                    case 2:
                        keyMaterial = (_b.sent()).keyMaterial;
                        if (!('crv' in jsonWebKey && !('d' in jsonWebKey))) return [3 /*break*/, 5];
                        _a = jsonWebKey.crv;
                        switch (_a) {
                            case 'secp256k1': return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, index_js_2.Secp256k1.convertPublicKey({
                            publicKey: keyMaterial,
                            compressedPublicKey: true
                        })];
                    case 4:
                        keyMaterial = _b.sent();
                        return [3 /*break*/, 5];
                    case 5:
                        multibaseId = (0, utils_js_1.keyToMultibaseId)({ key: keyMaterial, multicodecName: multicodecName });
                        return [2 /*return*/, multibaseId];
                }
            });
        });
    };
    Jose.keyToJwk = function (options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var keyMaterial, keyType, jsonWebKeyOptions, jsonWebKey, _d, publicKey, _e, publicKey, _f, points;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        keyMaterial = options.keyMaterial, keyType = options.keyType, jsonWebKeyOptions = __rest(options, ["keyMaterial", "keyType"]);
                        jsonWebKey = __assign({}, jsonWebKeyOptions);
                        if (!('crv' in jsonWebKey)) return [3 /*break*/, 13];
                        _d = jsonWebKey.crv;
                        switch (_d) {
                            case 'Ed25519': return [3 /*break*/, 1];
                            case 'X25519': return [3 /*break*/, 5];
                            case 'secp256k1': return [3 /*break*/, 9];
                        }
                        return [3 /*break*/, 11];
                    case 1:
                        if (!(keyType === 'private')) return [3 /*break*/, 3];
                        return [4 /*yield*/, index_js_2.Ed25519.getPublicKey({ privateKey: keyMaterial })];
                    case 2:
                        _e = _g.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _e = keyMaterial;
                        _g.label = 4;
                    case 4:
                        publicKey = _e;
                        jsonWebKey.x = common_1.Convert.uint8Array(publicKey).toBase64Url();
                        (_a = jsonWebKey.kty) !== null && _a !== void 0 ? _a : (jsonWebKey.kty = 'OKP');
                        return [3 /*break*/, 12];
                    case 5:
                        if (!(keyType === 'private')) return [3 /*break*/, 7];
                        return [4 /*yield*/, index_js_2.X25519.getPublicKey({ privateKey: keyMaterial })];
                    case 6:
                        _f = _g.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        _f = keyMaterial;
                        _g.label = 8;
                    case 8:
                        publicKey = _f;
                        jsonWebKey.x = common_1.Convert.uint8Array(publicKey).toBase64Url();
                        (_b = jsonWebKey.kty) !== null && _b !== void 0 ? _b : (jsonWebKey.kty = 'OKP');
                        return [3 /*break*/, 12];
                    case 9: return [4 /*yield*/, index_js_2.Secp256k1.getCurvePoints({ key: keyMaterial })];
                    case 10:
                        points = _g.sent();
                        jsonWebKey.x = common_1.Convert.uint8Array(points.x).toBase64Url();
                        jsonWebKey.y = common_1.Convert.uint8Array(points.y).toBase64Url();
                        (_c = jsonWebKey.kty) !== null && _c !== void 0 ? _c : (jsonWebKey.kty = 'EC');
                        return [3 /*break*/, 12];
                    case 11:
                        {
                            throw new Error("Unsupported key to JWK conversion: ".concat(jsonWebKey.crv));
                        }
                        _g.label = 12;
                    case 12:
                        if (keyType === 'private') {
                            jsonWebKey = __assign({ d: common_1.Convert.uint8Array(keyMaterial).toBase64Url() }, jsonWebKey);
                        }
                        _g.label = 13;
                    case 13:
                        /**
                         * All Octet Sequence (oct) symmetric encryption and signature keys
                         * specify only an "alg" parameter.
                         */
                        if (!('crv' in jsonWebKey) && jsonWebKey.kty === 'oct') {
                            jsonWebKey.k = common_1.Convert.uint8Array(keyMaterial).toBase64Url();
                        }
                        return [2 /*return*/, __assign({}, jsonWebKey)];
                }
            });
        });
    };
    Jose.multicodecToJose = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var code, name, lookupKey, jose;
            return __generator(this, function (_a) {
                code = options.code, name = options.name;
                // Either code or name must be specified, but not both.
                if (!(name ? !code : code)) {
                    throw new Error("Either 'name' or 'code' must be defined, but not both.");
                }
                // If name is undefined, lookup by code.
                name = (name === undefined) ? common_1.Multicodec.getNameFromCode({ code: code }) : name;
                lookupKey = name;
                jose = multicodecToJoseMapping[lookupKey];
                if (jose === undefined) {
                    throw new Error("Unsupported Multicodec to JOSE conversion: '".concat(options.name, "'"));
                }
                return [2 /*return*/, __assign({}, jose)];
            });
        });
    };
    Jose.webCryptoToJose = function (options) {
        var params = [];
        /**
         * All WebCrypto algorithms have the "named" parameter.
         */
        params.push(options.name);
        /**
         * All Elliptic Curve (EC) WebCrypto algorithms
         * set a value for the "namedCurve" parameter.
         */
        if ('namedCurve' in options) {
            params.push(options.namedCurve);
            /**
             * All symmetric encryption (AES) WebCrypto algorithms
             * set a value for the "length" parameter.
             */
        }
        else if ('length' in options && options.length !== undefined) {
            params.push(options.length.toString());
            /**
             * All symmetric signature (HMAC) WebCrypto algorithms
             * set a value for the "hash" parameter.
             */
        }
        else if ('hash' in options) {
            params.push(options.hash.name);
        }
        else {
            throw new TypeError("One or more parameters missing: 'name', 'namedCurve', 'length', or 'hash'");
        }
        var lookupKey = params.join(':');
        var jose = webCryptoToJoseMapping[lookupKey];
        if (jose === undefined) {
            throw new Error("Unsupported WebCrypto to JOSE conversion: '".concat(lookupKey, "'"));
        }
        return __assign({}, jose);
    };
    Jose.canonicalize = function (obj) {
        var sortedKeys = Object.keys(obj).sort();
        var sortedObj = sortedKeys.reduce(function (acc, key) {
            acc[key] = obj[key];
            return acc;
        }, {});
        return JSON.stringify(sortedObj);
    };
    return Jose;
}());
exports.Jose = Jose;
function CryptoKeyToJwkMixin(Base) {
    return /** @class */ (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.toJwk = function () {
            return __awaiter(this, void 0, void 0, function () {
                var jwk;
                return __generator(this, function (_a) {
                    jwk = Jose.cryptoKeyToJwk({ key: this });
                    return [2 /*return*/, jwk];
                });
            });
        };
        return class_1;
    }(Base));
}
exports.CryptoKeyToJwkMixin = CryptoKeyToJwkMixin;
exports.CryptoKeyWithJwk = CryptoKeyToJwkMixin(index_js_1.CryptoKey);
