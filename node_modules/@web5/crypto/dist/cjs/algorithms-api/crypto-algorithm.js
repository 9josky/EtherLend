"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoAlgorithm = void 0;
var errors_js_1 = require("./errors.js");
var CryptoAlgorithm = /** @class */ (function () {
    function CryptoAlgorithm() {
    }
    CryptoAlgorithm.prototype.checkAlgorithmName = function (options) {
        var algorithmName = options.algorithmName;
        if (algorithmName === undefined) {
            throw new TypeError("Required parameter missing: 'algorithmName'");
        }
        if (algorithmName !== this.name) {
            throw new errors_js_1.NotSupportedError("Algorithm not supported: '".concat(algorithmName, "'"));
        }
    };
    CryptoAlgorithm.prototype.checkCryptoKey = function (options) {
        var key = options.key;
        if (!('algorithm' in key && 'extractable' in key && 'type' in key && 'usages' in key)) {
            throw new TypeError('Object is not a CryptoKey');
        }
    };
    CryptoAlgorithm.prototype.checkKeyAlgorithm = function (options) {
        var keyAlgorithmName = options.keyAlgorithmName;
        if (keyAlgorithmName === undefined) {
            throw new TypeError("Required parameter missing: 'keyAlgorithmName'");
        }
        if (keyAlgorithmName && keyAlgorithmName !== this.name) {
            throw new errors_js_1.InvalidAccessError("Algorithm '".concat(this.name, "' does not match the provided '").concat(keyAlgorithmName, "' key."));
        }
    };
    CryptoAlgorithm.prototype.checkKeyType = function (options) {
        var keyType = options.keyType, allowedKeyType = options.allowedKeyType;
        if (keyType === undefined || allowedKeyType === undefined) {
            throw new TypeError("One or more required parameters missing: 'keyType, allowedKeyType'");
        }
        if (keyType && keyType !== allowedKeyType) {
            throw new errors_js_1.InvalidAccessError("Requested operation is not valid for the provided '".concat(keyType, "' key."));
        }
    };
    CryptoAlgorithm.prototype.checkKeyUsages = function (options) {
        var keyUsages = options.keyUsages, allowedKeyUsages = options.allowedKeyUsages;
        if (!(keyUsages && keyUsages.length > 0)) {
            throw new TypeError("Required parameter missing or empty: 'keyUsages'");
        }
        var allowedUsages = (Array.isArray(allowedKeyUsages)) ? allowedKeyUsages : __spreadArray(__spreadArray([], __read(allowedKeyUsages.privateKey), false), __read(allowedKeyUsages.publicKey), false);
        if (!keyUsages.every(function (usage) { return allowedUsages.includes(usage); })) {
            throw new errors_js_1.InvalidAccessError("Requested operation(s) '".concat(keyUsages.join(', '), "' is not valid for the provided key."));
        }
    };
    /**
     * Creates an instance of the class on which it is called.
     *
     * This is a generic factory method that creates an instance of any
     * crypto algorithm that extends this abstract class.
     *
     * @template T The type of the instance to be created.
     * @returns An instance of the class it is called on.
     * @throws {TypeError} If the class it is called on cannot be constructed.
     */
    CryptoAlgorithm.create = function () {
        return new this();
    };
    return CryptoAlgorithm;
}());
exports.CryptoAlgorithm = CryptoAlgorithm;
