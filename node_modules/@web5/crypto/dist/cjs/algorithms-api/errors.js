"use strict";
/**
 * The methods of KeyManager and KeyManagementSystem interfaces return
 * errors by rejecting the returned promise with a predefined exception
 * defined in ECMAScript [ECMA-262] or DOMException.
 *
 * The following predefined exceptions are used: TypeError.
 *
 * The following DOMException types from [DOM4] are used:
 *   DataError: Data provided to an operation does not meet requirements
 *   InvalidAccessError: The requested operation is not valid for the provided key
 *   NotSupportedError: The algorithm is not supported
 *   OperationError: The operation failed for an operation-specific reason
 *   SyntaxError: A required parameter was missing or out-of-range
 *
 * Reference: https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-Exceptions
 *            Section 14.4. Exceptions
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyntaxError = exports.OperationError = exports.NotSupportedError = exports.InvalidAccessError = exports.DataError = exports.CryptoError = void 0;
var CryptoError = /** @class */ (function (_super) {
    __extends(CryptoError, _super);
    function CryptoError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CryptoError;
}(Error));
exports.CryptoError = CryptoError;
var DataError = /** @class */ (function (_super) {
    __extends(DataError, _super);
    function DataError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DataError;
}(CryptoError));
exports.DataError = DataError;
var InvalidAccessError = /** @class */ (function (_super) {
    __extends(InvalidAccessError, _super);
    function InvalidAccessError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InvalidAccessError;
}(CryptoError));
exports.InvalidAccessError = InvalidAccessError;
var NotSupportedError = /** @class */ (function (_super) {
    __extends(NotSupportedError, _super);
    function NotSupportedError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NotSupportedError;
}(CryptoError));
exports.NotSupportedError = NotSupportedError;
var OperationError = /** @class */ (function (_super) {
    __extends(OperationError, _super);
    function OperationError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OperationError;
}(CryptoError));
exports.OperationError = OperationError;
var SyntaxError = /** @class */ (function (_super) {
    __extends(SyntaxError, _super);
    function SyntaxError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SyntaxError;
}(CryptoError));
exports.SyntaxError = SyntaxError;
