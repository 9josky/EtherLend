"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Secp256k1 = void 0;
var sha256_1 = require("@noble/hashes/sha256");
var secp256k1_1 = require("@noble/curves/secp256k1");
var utils_1 = require("@noble/curves/abstract/utils");
/**
 * The `Secp256k1` class provides an interface for generating secp256k1 key pairs,
 * computing public keys from private keys, generating shaerd secrets, and
 * signing and verifying messages.
 *
 * The class uses the '@noble/secp256k1' package for the cryptographic operations,
 * and the '@noble/hashes/sha256' package for generating the hash digests needed
 * for the signing and verification operations.
 *
 * The methods of this class are all asynchronous and return Promises. They all use
 * the Uint8Array type for keys, signatures, and data, providing a consistent
 * interface for working with binary data.
 *
 * Example usage:
 *
 * ```ts
 * const keyPair = await Secp256k1.generateKeyPair();
 * const message = new TextEncoder().encode('Hello, world!');
 * const signature = await Secp256k1.sign({
 *   algorithm: { hash: 'SHA-256' },
 *   key: keyPair.privateKey,
 *   data: message
 * });
 * const isValid = await Secp256k1.verify({
 *   algorithm: { hash: 'SHA-256' },
 *   key: keyPair.publicKey,
 *   signature,
 *   data: message
 * });
 * console.log(isValid); // true
 * ```
 */
var Secp256k1 = exports.Secp256k1 = /** @class */ (function () {
    function Secp256k1() {
    }
    /**
     * Converts a public key between its compressed and uncompressed forms.
     *
     * Given a public key, this method can either compress or decompress it
     * depending on the provided `compressedPublicKey` option. The conversion
     * process involves decoding the Weierstrass points from the key bytes
     * and then returning the key in the desired format.
     *
     * This is useful in scenarios where space is a consideration or when
     * interfacing with systems that expect a specific public key format.
     *
     * @param options - The options for the public key conversion.
     * @param options.publicKey - The original public key, represented as a Uint8Array.
     * @param options.compressedPublicKey - A boolean indicating whether the output
     *                                      should be in compressed form. If true, the
     *                                      method returns the compressed form of the
     *                                      provided public key. If false, it returns
     *                                      the uncompressed form.
     *
     * @returns A Promise that resolves to the converted public key as a Uint8Array.
     */
    Secp256k1.convertPublicKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var publicKey, compressedPublicKey, point;
            return __generator(this, function (_a) {
                publicKey = options.publicKey, compressedPublicKey = options.compressedPublicKey;
                point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicKey);
                // Return either the compressed or uncompressed form of hte public key.
                return [2 /*return*/, point.toRawBytes(compressedPublicKey)];
            });
        });
    };
    /**
     * Generates a secp256k1 key pair.
     *
     * @param options - Optional parameters for the key generation.
     * @param options.compressedPublicKey - If true, generates a compressed public key. Defaults to true.
     * @returns A Promise that resolves to an object containing the private and public keys as Uint8Array.
     */
    Secp256k1.generateKeyPair = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var compressedPublicKey, privateKey, publicKey, keyPair;
            return __generator(this, function (_a) {
                compressedPublicKey = (options !== null && options !== void 0 ? options : {}).compressedPublicKey;
                compressedPublicKey !== null && compressedPublicKey !== void 0 ? compressedPublicKey : (compressedPublicKey = true); // Default to compressed public key, matching the default of @noble/secp256k1.
                privateKey = secp256k1_1.secp256k1.utils.randomPrivateKey();
                publicKey = secp256k1_1.secp256k1.getPublicKey(privateKey, compressedPublicKey);
                keyPair = {
                    privateKey: privateKey,
                    publicKey: publicKey
                };
                return [2 /*return*/, keyPair];
            });
        });
    };
    /**
     * Returns the elliptic curve points (x and y coordinates) for a given secp256k1 key.
     *
     * In the case of a private key, the public key is first computed from the private key,
     * then the x and y coordinates of the public key point on the elliptic curve are returned.
     *
     * In the case of a public key, the x and y coordinates of the key point on the elliptic
     * curve are returned directly.
     *
     * The returned coordinates can be used to perform various operations on the elliptic curve,
     * such as addition and multiplication of points, which can be used in various cryptographic
     * schemes and protocols.
     *
     * @param options - The options for the operation.
     * @param options.key - The key for which to get the elliptic curve points.
     *                      Can be either a private key or a public key.
     *                      The key should be passed as a Uint8Array.
     * @returns A Promise that resolves to an object with properties 'x' and 'y',
     *          each being a Uint8Array representing the x and y coordinates of the key point on the elliptic curve.
     */
    Secp256k1.getCurvePoints = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, point, x, y;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        key = options.key;
                        if (!(key.byteLength === 32)) return [3 /*break*/, 2];
                        return [4 /*yield*/, Secp256k1.getPublicKey({ privateKey: key })];
                    case 1:
                        key = _a.sent();
                        _a.label = 2;
                    case 2:
                        point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(key);
                        x = (0, utils_1.numberToBytesBE)(point.x, 32);
                        y = (0, utils_1.numberToBytesBE)(point.y, 32);
                        return [2 /*return*/, { x: x, y: y }];
                }
            });
        });
    };
    /**
     * Computes the public key from a given private key.
     * If compressedPublicKey=true then the output is a 33-byte public key.
     * If compressedPublicKey=false then the output is a 65-byte public key.
     *
     * @param options - The options for the public key computation.
     * @param options.privateKey - The 32-byte private key from which to compute the public key.
     * @param options.compressedPublicKey - If true, returns a compressed public key. Defaults to true.
     * @returns A Promise that resolves to the computed public key as a Uint8Array.
     */
    Secp256k1.getPublicKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, compressedPublicKey, publicKey;
            return __generator(this, function (_a) {
                privateKey = options.privateKey, compressedPublicKey = options.compressedPublicKey;
                compressedPublicKey !== null && compressedPublicKey !== void 0 ? compressedPublicKey : (compressedPublicKey = true); // Default to compressed public key, matching the default of @noble/secp256k1.
                publicKey = secp256k1_1.secp256k1.getPublicKey(privateKey, compressedPublicKey);
                return [2 /*return*/, publicKey];
            });
        });
    };
    /**
     * Generates a RFC6090 ECDH shared secret given the private key of one party
     * and the public key another party.
     *
     * Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement,
     * the resulting shared secret is a point on the elliptic curve, which
     * consists of an x-coordinate and a y-coordinate. With a 256-bit curve like
     * secp256k1, each of these coordinates is 32 bytes (256 bits) long. However,
     * in the ECDH process, it's standard practice to use only the x-coordinate
     * of the shared secret point as the resulting shared key. This is because
     * the y-coordinate does not add to the entropy of the key, and both parties
     * can independently compute the x-coordinate, so using just the x-coordinate
     * simplifies matters.
     */
    Secp256k1.sharedSecret = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, publicKey, sharedSecret;
            return __generator(this, function (_a) {
                privateKey = options.privateKey, publicKey = options.publicKey;
                sharedSecret = secp256k1_1.secp256k1.getSharedSecret(privateKey, publicKey);
                // Remove the leading byte that indicates the sign of the y-coordinate
                // of the point on the elliptic curve.  See note above.
                return [2 /*return*/, sharedSecret.slice(1)];
            });
        });
    };
    /**
     * Generates a RFC6979 ECDSA signature of given data with a given private key and hash algorithm.
     *
     * @param options - The options for the signing operation.
     * @param options.data - The data to sign.
     * @param options.hash - The hash algorithm to use to generate a digest of the data.
     * @param options.key - The private key to use for signing.
     * @returns A Promise that resolves to the signature as a Uint8Array.
     */
    Secp256k1.sign = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var data, hash, key, hashFunction, digest, signatureObject, signature;
            return __generator(this, function (_a) {
                data = options.data, hash = options.hash, key = options.key;
                hashFunction = this.hashAlgorithms[hash];
                digest = hashFunction(data);
                signatureObject = secp256k1_1.secp256k1.sign(digest, key);
                signature = signatureObject.toCompactRawBytes();
                return [2 /*return*/, signature];
            });
        });
    };
    /**
     * Validates a given private key to ensure that it's a valid 32-byte number
     * that is less than the secp256k1 curve's order.
     *
     * This method checks the byte length of the key and its numerical validity
     * according to the secp256k1 curve's parameters. It doesn't verify whether
     * the key corresponds to a known or authorized entity or whether it has
     * been compromised.
     *
     * @param options - The options for the key validation.
     * @param options.key - The private key to validate, represented as a Uint8Array.
     * @returns A Promise that resolves to a boolean indicating whether the private
     *          key is a valid 32-byte number less than the secp256k1 curve's order.
     */
    Secp256k1.validatePrivateKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key;
            return __generator(this, function (_a) {
                key = options.key;
                return [2 /*return*/, secp256k1_1.secp256k1.utils.isValidPrivateKey(key)];
            });
        });
    };
    /**
     * Validates a given public key to ensure that it corresponds to a
     * valid point on the secp256k1 elliptic curve.
     *
     * This method decodes the Weierstrass points from the key bytes and
     * asserts their validity on the curve. If the points are not valid,
     * the method returns false. If the points are valid, the method
     * returns true.
     *
     * Note: This method does not check whether the key corresponds to a
     * known or authorized entity, or whether it has been compromised.
     * It only checks the mathematical validity of the key.
     *
     * @param options - The options for the key validation.
     * @param options.key - The key to validate, represented as a Uint8Array.
     * @returns A Promise that resolves to a boolean indicating whether the key
     *          corresponds to a valid point on the secp256k1 elliptic curve.
     */
    Secp256k1.validatePublicKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, point;
            return __generator(this, function (_a) {
                key = options.key;
                try {
                    point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(key);
                    // Check if points are on the Short Weierstrass curve.
                    point.assertValidity();
                }
                catch (error) {
                    return [2 /*return*/, false];
                }
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Verifies a RFC6979 ECDSA signature of given data with a given public key and hash algorithm.
     *
     * @param options - The options for the verification operation.
     * @param options.data - The data that was signed.
     * @param options.hash - The hash algorithm to use to generate a digest of the data.
     * @param options.key - The public key to use for verification.
     * @param options.signature - The signature to verify.
     * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
     */
    Secp256k1.verify = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var data, hash, key, signature, hashFunction, digest, isValid;
            return __generator(this, function (_a) {
                data = options.data, hash = options.hash, key = options.key, signature = options.signature;
                hashFunction = this.hashAlgorithms[hash];
                digest = hashFunction(data);
                isValid = secp256k1_1.secp256k1.verify(signature, digest, key, { lowS: false });
                return [2 /*return*/, isValid];
            });
        });
    };
    /**
     * A private static field containing a map of hash algorithm names to their
     * corresponding hash functions.  The map is used in the 'sign' and 'verify'
     * methods to get the specified hash function.
     */
    Secp256k1.hashAlgorithms = {
        'SHA-256': sha256_1.sha256
    };
    return Secp256k1;
}());
