"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ed25519 = void 0;
var ed25519_1 = require("@noble/curves/ed25519");
/**
 * The `Ed25519` class provides an interface for generating Ed25519 key pairs,
 * computing public keys from private keys, and signing and verifying messages.
 *
 * The class uses the '@noble/curves' package for the cryptographic operations.
 *
 * The methods of this class are all asynchronous and return Promises. They all use
 * the Uint8Array type for keys, signatures, and data, providing a consistent
 * interface for working with binary data.
 *
 * Example usage:
 *
 * ```ts
 * const keyPair = await Ed25519.generateKeyPair();
 * const message = new TextEncoder().encode('Hello, world!');
 * const signature = await Ed25519.sign({
 *   key: keyPair.privateKey,
 *   data: message
 * });
 * const isValid = await Ed25519.verify({
 *   key: keyPair.publicKey,
 *   signature,
 *   data: message
 * });
 * console.log(isValid); // true
 * ```
 */
var Ed25519 = /** @class */ (function () {
    function Ed25519() {
    }
    /**
     * Converts an Ed25519 private key to its X25519 counterpart.
     *
     * Similar to the public key conversion, this method aids in transitioning
     * from signing to encryption operations. By converting an Ed25519 private
     * key to X25519 format, one can use the same key pair for both digital
     * signatures and key exchange operations.
     *
     * @param options - The options for the conversion.
     * @param options.privateKey - The Ed25519 private key to convert, represented as a Uint8Array.
     * @returns A Promise that resolves to the X25519 private key as a Uint8Array.
     */
    Ed25519.convertPrivateKeyToX25519 = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, montgomeryPrivateKey;
            return __generator(this, function (_a) {
                privateKey = options.privateKey;
                montgomeryPrivateKey = (0, ed25519_1.edwardsToMontgomeryPriv)(privateKey);
                return [2 /*return*/, montgomeryPrivateKey];
            });
        });
    };
    /**
   * Converts an Ed25519 public key to its X25519 counterpart.
   *
   * This method is useful when transitioning from signing to encryption
   * operations, as Ed25519 and X25519 keys share the same mathematical
   * foundation but serve different purposes. Ed25519 keys are used for
   * digital signatures, while X25519 keys are used for key exchange in
   * encryption protocols like Diffie-Hellman.
   *
   * @param options - The options for the conversion.
   * @param options.publicKey - The Ed25519 public key to convert, represented as a Uint8Array.
   * @returns A Promise that resolves to the X25519 public key as a Uint8Array.
   */
    Ed25519.convertPublicKeyToX25519 = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var publicKey, isValid, montgomeryPublicKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        publicKey = options.publicKey;
                        return [4 /*yield*/, Ed25519.validatePublicKey({ key: publicKey })];
                    case 1:
                        isValid = _a.sent();
                        if (!isValid) {
                            throw new Error('Ed25519: Invalid public key.');
                        }
                        montgomeryPublicKey = (0, ed25519_1.edwardsToMontgomeryPub)(publicKey);
                        return [2 /*return*/, montgomeryPublicKey];
                }
            });
        });
    };
    /**
     * Generates an Ed25519 key pair.
     *
     * @returns A Promise that resolves to an object containing the private and public keys as Uint8Array.
     */
    Ed25519.generateKeyPair = function () {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, publicKey, keyPair;
            return __generator(this, function (_a) {
                privateKey = ed25519_1.ed25519.utils.randomPrivateKey();
                publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
                keyPair = {
                    privateKey: privateKey,
                    publicKey: publicKey
                };
                return [2 /*return*/, keyPair];
            });
        });
    };
    /**
     * Computes the public key from a given private key.
     *
     * @param options - The options for the public key computation.
     * @param options.privateKey - The 32-byte private key from which to compute the public key.
     * @returns A Promise that resolves to the computed 32-byte public key as a Uint8Array.
     */
    Ed25519.getPublicKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKey, publicKey;
            return __generator(this, function (_a) {
                privateKey = options.privateKey;
                publicKey = ed25519_1.ed25519.getPublicKey(privateKey);
                return [2 /*return*/, publicKey];
            });
        });
    };
    /**
     * Generates a RFC8032 EdDSA signature of given data with a given private key.
     *
     * @param options - The options for the signing operation.
     * @param options.key - The private key to use for signing.
     * @param options.data - The data to sign.
     * @returns A Promise that resolves to the signature as a Uint8Array.
     */
    Ed25519.sign = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, data, signature;
            return __generator(this, function (_a) {
                key = options.key, data = options.data;
                signature = ed25519_1.ed25519.sign(data, key);
                return [2 /*return*/, signature];
            });
        });
    };
    /**
     * Validates a given public key to ensure that it corresponds to a
     * valid point on the Ed25519 elliptic curve.
     *
     * This method decodes the Edwards points from the key bytes and
     * asserts their validity on the curve. If the points are not valid,
     * the method returns false. If the points are valid, the method
     * returns true.
     *
     * Note: This method does not check whether the key corresponds to a
     * known or authorized entity, or whether it has been compromised.
     * It only checks the mathematical validity of the key.
     *
     * @param options - The options for the key validation.
     * @param options.key - The key to validate, represented as a Uint8Array.
     * @returns A Promise that resolves to a boolean indicating whether the key
     *          corresponds to a valid point on the Edwards curve.
     */
    Ed25519.validatePublicKey = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, point;
            return __generator(this, function (_a) {
                key = options.key;
                try {
                    point = ed25519_1.ed25519.ExtendedPoint.fromHex(key);
                    // Check if points are on the Twisted Edwards curve.
                    point.assertValidity();
                }
                catch (error) {
                    return [2 /*return*/, false];
                }
                return [2 /*return*/, true];
            });
        });
    };
    /**
     * Verifies a RFC8032 EdDSA signature of given data with a given public key.
     *
     * @param options - The options for the verification operation.
     * @param options.key - The public key to use for verification.
     * @param options.signature - The signature to verify.
     * @param options.data - The data that was signed.
     * @returns A Promise that resolves to a boolean indicating whether the signature is valid.
     */
    Ed25519.verify = function (options) {
        return __awaiter(this, void 0, void 0, function () {
            var key, signature, data, isValid;
            return __generator(this, function (_a) {
                key = options.key, signature = options.signature, data = options.data;
                isValid = ed25519_1.ed25519.verify(signature, data, key);
                return [2 /*return*/, isValid];
            });
        });
    };
    return Ed25519;
}());
exports.Ed25519 = Ed25519;
