"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("@noble/curves/secp256k1");
var hkdf_1 = require("@noble/hashes/hkdf");
var sha256_1 = require("@noble/hashes/sha256");
var consts_1 = require("../consts");
var utils_1 = require("../utils");
var PublicKey = /** @class */ (function () {
    function PublicKey(buffer) {
        this.uncompressed = Buffer.from(secp256k1_1.secp256k1.getSharedSecret(consts_1.ONE, buffer, false));
        this.compressed = Buffer.from(secp256k1_1.secp256k1.getSharedSecret(consts_1.ONE, buffer, true));
    }
    PublicKey.fromHex = function (hex) {
        var decoded = (0, utils_1.decodeHex)(hex);
        if (decoded.length === consts_1.UNCOMPRESSED_PUBLIC_KEY_SIZE - 1) {
            // eth public key
            var prefix = Buffer.from([0x04]);
            var fixed = Buffer.concat([prefix, decoded]);
            return new PublicKey(fixed);
        }
        return new PublicKey(decoded);
    };
    PublicKey.prototype.toHex = function (compressed) {
        if (compressed === void 0) { compressed = true; }
        if (compressed) {
            return this.compressed.toString("hex");
        }
        else {
            return this.uncompressed.toString("hex");
        }
    };
    PublicKey.prototype.decapsulate = function (priv) {
        var master = Buffer.concat([this.uncompressed, priv.multiply(this)]);
        return Buffer.from((0, hkdf_1.hkdf)(sha256_1.sha256, master, undefined, undefined, 32));
    };
    PublicKey.prototype.equals = function (other) {
        return this.uncompressed.equals(other.uncompressed);
    };
    return PublicKey;
}());
exports.default = PublicKey;
