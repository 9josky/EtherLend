"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("@noble/curves/secp256k1");
var hkdf_1 = require("@noble/hashes/hkdf");
var sha256_1 = require("@noble/hashes/sha256");
var utils_1 = require("../utils");
var PublicKey_1 = __importDefault(require("./PublicKey"));
var PrivateKey = /** @class */ (function () {
    function PrivateKey(secret) {
        this.secret = secret || (0, utils_1.getValidSecret)();
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(this.secret)) {
            throw new Error("Invalid private key");
        }
        this.publicKey = new PublicKey_1.default(Buffer.from(secp256k1_1.secp256k1.getPublicKey(this.secret)));
    }
    PrivateKey.fromHex = function (hex) {
        return new PrivateKey((0, utils_1.decodeHex)(hex));
    };
    PrivateKey.prototype.toHex = function () {
        return this.secret.toString("hex");
    };
    PrivateKey.prototype.encapsulate = function (pub) {
        var master = Buffer.concat([this.publicKey.uncompressed, this.multiply(pub)]);
        return Buffer.from((0, hkdf_1.hkdf)(sha256_1.sha256, master, undefined, undefined, 32));
    };
    PrivateKey.prototype.multiply = function (pub) {
        return Buffer.from(secp256k1_1.secp256k1.getSharedSecret(this.secret, pub.compressed, false));
    };
    PrivateKey.prototype.equals = function (other) {
        return this.secret.equals(other.secret);
    };
    return PrivateKey;
}());
exports.default = PrivateKey;
