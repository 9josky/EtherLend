import type { GeneralJws } from '../types/jws-types.js';
import type { Signer } from '../types/signer.js';
import type { AuthorizationModel, Descriptor, GenericMessage, GenericSignaturePayload } from '../types/message-types.js';
export declare enum DwnInterfaceName {
    Events = "Events",
    Messages = "Messages",
    Permissions = "Permissions",
    Protocols = "Protocols",
    Records = "Records"
}
export declare enum DwnMethodName {
    Configure = "Configure",
    Create = "Create",
    Get = "Get",
    Grant = "Grant",
    Query = "Query",
    Read = "Read",
    Request = "Request",
    Revoke = "Revoke",
    Write = "Write",
    Delete = "Delete"
}
export declare abstract class Message<M extends GenericMessage> {
    readonly message: M;
    readonly authorSignaturePayload: GenericSignaturePayload | undefined;
    readonly author: string | undefined;
    constructor(message: M);
    /**
     * Called by `JSON.stringify(...)` automatically.
     */
    toJSON(): GenericMessage;
    /**
     * Validates the given message against the corresponding JSON schema.
     * @throws {Error} if fails validation.
     */
    static validateJsonSchema(rawMessage: any): void;
    /**
     * Gets the DID of the author of the given message, returned `undefined` if message is not signed.
     */
    static getAuthor(message: GenericMessage): string | undefined;
    /**
     * Gets the CID of the given message.
     */
    static getCid(message: GenericMessage): Promise<string>;
    /**
     * Compares message CID in lexicographical order according to the spec.
     * @returns 1 if `a` is larger than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same message)
     */
    static compareCid(a: GenericMessage, b: GenericMessage): Promise<number>;
    /**
     * Creates the `authorization` as the author to be used in a DWN message.
     * @param signer Signer as the author
     * @returns {AuthorizationModel} used as an `authorization` property.
     */
    static createAuthorizationAsAuthor(descriptor: Descriptor, signer: Signer, additionalPayloadProperties?: {
        permissionsGrantId?: string;
        protocolRole?: string;
    }): Promise<AuthorizationModel>;
    /**
     * Creates a generic signature from the given DWN message descriptor by including `descriptorCid` as the required property in the signature payload.
     * NOTE: there is an opportunity to consolidate RecordsWrite.createAuthorSignature() wth this method
     */
    static createSignature(descriptor: Descriptor, signer: Signer, additionalPayloadProperties?: {
        permissionsGrantId?: string;
        protocolRole?: string;
    }): Promise<GeneralJws>;
    /**
     * @returns newest message in the array. `undefined` if given array is empty.
     */
    static getNewestMessage(messages: GenericMessage[]): Promise<GenericMessage | undefined>;
    /**
     * @returns oldest message in the array. `undefined` if given array is empty.
     */
    static getOldestMessage(messages: GenericMessage[]): Promise<GenericMessage | undefined>;
    /**
     * Checks if first message is newer than second message.
     * @returns `true` if `a` is newer than `b`; `false` otherwise
     */
    static isNewer(a: GenericMessage, b: GenericMessage): Promise<boolean>;
    /**
     * Checks if first message is older than second message.
     * @returns `true` if `a` is older than `b`; `false` otherwise
     */
    static isOlder(a: GenericMessage, b: GenericMessage): Promise<boolean>;
    /**
     * Compares the `messageTimestamp` of the given messages with a fallback to message CID according to the spec.
     * @returns 1 if `a` is larger/newer than `b`; -1 if `a` is smaller/older than `b`; 0 otherwise (same age)
     */
    static compareMessageTimestamp(a: GenericMessage, b: GenericMessage): Promise<number>;
}
//# sourceMappingURL=message.d.ts.map