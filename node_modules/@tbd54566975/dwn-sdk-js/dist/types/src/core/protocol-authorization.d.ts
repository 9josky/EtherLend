import type { MessageStore } from '../types/message-store.js';
import type { RecordsRead } from '../interfaces/records-read.js';
import { RecordsWrite } from '../interfaces/records-write.js';
export declare class ProtocolAuthorization {
    /**
     * Performs protocol-based authorization against the given message.
     * @param recordsWrite Either the incomingMessage itself if the incoming is a RecordsWrite,
     *                     or the latest RecordsWrite associated with the recordId being read.
     * @throws {Error} if authorization fails.
     */
    static authorize(tenant: string, incomingMessage: RecordsRead | RecordsWrite, recordsWrite: RecordsWrite, messageStore: MessageStore): Promise<void>;
    /**
     * Fetches the protocol definition based on the protocol specified in the given message.
     */
    private static fetchProtocolDefinition;
    /**
     * Constructs a chain of ancestor messages
     * @returns the ancestor chain of messages where the first element is the root of the chain; returns empty array if no parent is specified.
     */
    private static constructAncestorMessageChain;
    /**
     * Gets the rule set corresponding to the given message chain.
     */
    private static getRuleSet;
    /**
     * Verifies the `protocolPath` declared in the given message (if it is a RecordsWrite) matches the path of actual ancestor chain.
     * @throws {DwnError} if fails verification.
     */
    private static verifyProtocolPath;
    /**
     * Verifies the `dataFormat` and `schema` declared in the given message (if it is a RecordsWrite) matches dataFormat
     * and schema of the type in the given protocol.
     * @throws {DwnError} if fails verification.
     */
    private static verifyType;
    /**
     * Check if the incoming message is invoking a role. If so, validate the invoked role.
     */
    private static verifyInvokedRole;
    /**
     * Verifies the action (e.g. read/write) specified in the given message matches the allowed actions in the rule set.
     * @throws {Error} if action not allowed.
     */
    private static verifyAllowedActions;
    /**
     * Verifies that writes to a $globalRole or $contextRole record do not have the same recipient as an existing RecordsWrite
     * to the same $globalRole or the same $contextRole in the same context.
     */
    private static verifyUniqueRoleRecipient;
    /**
     * Verifies if the desired action can be taken.
     * Currently the only check is: if the write is not the initial write, the author must be the same as the initial write
     * @throws {Error} if fails verification
     */
    private static verifyActionCondition;
    private static getRuleSetAtProtocolPath;
    /**
     * Checks if there is a RecordsWriteMessage in the ancestor chain that matches the protocolPath in given ProtocolActionRule.
     * Assumes that the actionRule authorizes either recipient or author, but not 'anyone'.
     * @returns true if there is an ancestorRecordsWrite that matches actionRule. false otherwise.
     */
    private static checkAncestorGroupActionRule;
    private static getTypeName;
}
//# sourceMappingURL=protocol-authorization.d.ts.map