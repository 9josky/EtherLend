import type { GeneralJws } from '../types/jws-types.js';
import type { MessageStore } from '../types/message-store.js';
import type { PublicJwk } from '../types/jose-types.js';
import type { Signer } from '../types/signer.js';
import type { EncryptionProperty, InternalRecordsWriteMessage, RecordsWriteDescriptor, RecordsWriteMessage, RecordsWriteSignaturePayload, UnsignedRecordsWriteMessage } from '../types/records-types.js';
import type { GenericMessage, GenericSignaturePayload } from '../types/message-types.js';
import { EncryptionAlgorithm } from '../utils/encryption.js';
import { KeyDerivationScheme } from '../utils/hd-key.js';
export type RecordsWriteOptions = {
    recipient?: string;
    protocol?: string;
    protocolPath?: string;
    protocolRole?: string;
    contextId?: string;
    schema?: string;
    recordId?: string;
    parentId?: string;
    data?: Uint8Array;
    dataCid?: string;
    dataSize?: number;
    dateCreated?: string;
    messageTimestamp?: string;
    published?: boolean;
    datePublished?: string;
    dataFormat: string;
    authorizationSigner?: Signer;
    attestationSigners?: Signer[];
    encryptionInput?: EncryptionInput;
    permissionsGrantId?: string;
};
/**
 * Input that describes how data is encrypted as spec-ed in TP18 (https://github.com/TBD54566975/technical-proposals/pull/6).
 */
export type EncryptionInput = {
    /**
     * Algorithm used for encrypting the Data. Uses {EncryptionAlgorithm.Aes256Ctr} if not given.
     */
    algorithm?: EncryptionAlgorithm;
    /**
     * Initialization vector used for encrypting the data.
     */
    initializationVector: Uint8Array;
    /**
     * Symmetric key used to encrypt the data.
     */
    key: Uint8Array;
    /**
     * Array of input that specifies how the symmetric key is encrypted.
     * Each entry in the array will result in a unique ciphertext of the symmetric key.
     */
    keyEncryptionInputs: KeyEncryptionInput[];
};
/**
 * Input that specifies how a symmetric key is encrypted.
 */
export type KeyEncryptionInput = {
    /**
     * Key derivation scheme used to derive the public key to encrypt the symmetric key.
     */
    derivationScheme: KeyDerivationScheme;
    /**
     * Fully qualified ID of root public key used derive the public key to be used to to encrypt the symmetric key.
     * (e.g. did:example:abc#encryption-key-id)
     */
    publicKeyId: string;
    /**
     * Public key to be used to encrypt the symmetric key.
     */
    publicKey: PublicJwk;
    /**
     * Algorithm used for encrypting the symmetric key. Uses {EncryptionAlgorithm.EciesSecp256k1} if not given.
     */
    algorithm?: EncryptionAlgorithm;
};
export type CreateFromOptions = {
    unsignedRecordsWriteMessage: UnsignedRecordsWriteMessage;
    data?: Uint8Array;
    published?: boolean;
    messageTimestamp?: string;
    datePublished?: string;
    authorizationSigner?: Signer;
    attestationSigners?: Signer[];
    encryptionInput?: EncryptionInput;
};
export declare class RecordsWrite {
    private _message;
    /**
     * Valid JSON message representing this RecordsWrite.
     * @throws `DwnErrorCode.RecordsWriteMissingAuthorizationSigner` if the message is not signed yet.
     */
    get message(): RecordsWriteMessage;
    private _author;
    /**
     * DID of author of this message.
     */
    get author(): string | undefined;
    private _authorSignaturePayload;
    /**
     * Decoded author signature payload.
     */
    get authorSignaturePayload(): RecordsWriteSignaturePayload | undefined;
    private _owner;
    /**
     * DID of owner of this message.
     */
    get owner(): string | undefined;
    private _ownerSignaturePayload;
    /**
     * Decoded owner signature payload.
     */
    get ownerSignaturePayload(): GenericSignaturePayload | undefined;
    readonly attesters: string[];
    private constructor();
    static parse(message: RecordsWriteMessage): Promise<RecordsWrite>;
    /**
     * Creates a RecordsWrite message.
     * @param options.recordId If `undefined`, will be auto-filled as a originating message as convenience for developer.
     * @param options.data Data used to compute the `dataCid`, must be the encrypted data bytes if `options.encryptionInput` is given.
     *                     Must specify `options.dataCid` if `undefined`.
     * @param options.dataCid CID of the data that is already stored in the DWN. Must specify `options.data` if `undefined`.
     * @param options.dataSize Size of data in number of bytes. Must be defined if `options.dataCid` is defined; must be `undefined` otherwise.
     * @param options.dateCreated If `undefined`, it will be auto-filled with current time.
     * @param options.messageTimestamp If `undefined`, it will be auto-filled with current time.
     */
    static create(options: RecordsWriteOptions): Promise<RecordsWrite>;
    /**
     * Convenience method that creates a message by:
     * 1. Copying over immutable properties from the given unsigned message
     * 2. Copying over mutable properties that are not overwritten from the given unsigned message
     * 3. Replace the mutable properties that are given new value
     * @param options.unsignedRecordsWriteMessage Unsigned message that the new RecordsWrite will be based from.
     * @param options.messageTimestamp The new date the record is modified. If not given, current time will be used .
     * @param options.data The new data or the record. If not given, data from given message will be used.
     * @param options.published The new published state. If not given, then will be set to `true` if {options.messageTimestamp} is given;
     * else the state from given message will be used.
     * @param options.publishedDate The new date the record is modified. If not given, then:
     * - will not be set if the record will be unpublished as the result of this RecordsWrite; else
     * - will be set to the same published date as the given message if it wss already published; else
     * - will be set to current time (because this is a toggle from unpublished to published)
     */
    static createFrom(options: CreateFromOptions): Promise<RecordsWrite>;
    /**
     * Called by `JSON.stringify(...)` automatically.
     */
    toJSON(): RecordsWriteMessage;
    /**
     * Encrypts the symmetric encryption key using the public keys given and attach the resulting `encryption` property to the RecordsWrite.
     */
    encryptSymmetricEncryptionKey(encryptionInput: EncryptionInput): Promise<void>;
    /**
     * Signs the RecordsWrite as the author.
     */
    sign(signer: Signer, options?: {
        permissionsGrantId?: string;
        protocolRole?: string;
    }): Promise<void>;
    /**
     * Signs the `RecordsWrite` as the DWN owner.
     * This is used when the DWN owner wants to retain a copy of a message that the owner did not author.
     * NOTE: requires the `RecordsWrite` to already have the author's signature already.
     */
    signAsOwner(signer: Signer, permissionsGrantId?: string): Promise<void>;
    authorize(tenant: string, messageStore: MessageStore): Promise<void>;
    /**
     * Validates the integrity of the RecordsWrite message assuming the message passed basic schema validation.
     * There is opportunity to integrate better with `validateSchema(...)`
     */
    private validateIntegrity;
    /**
     * Validates the structural integrity of the `attestation` property.
     * NOTE: signature is not verified.
     */
    private static validateAttestationIntegrity;
    /**
     * Computes the deterministic Entry ID of this message.
     */
    getEntryId(): Promise<string>;
    /**
     * Computes the deterministic Entry ID of this message.
     */
    static getEntryId(author: string | undefined, descriptor: RecordsWriteDescriptor): Promise<string>;
    /**
     * Checks if the given message is the initial entry of a record.
     */
    isInitialWrite(): Promise<boolean>;
    /**
     * Checks if the given message is the initial entry of a record.
     */
    static isInitialWrite(message: GenericMessage): Promise<boolean>;
    /**
     * Creates the `encryption` property if encryption input is given. Else `undefined` is returned.
     */
    private static createEncryptionProperty;
    /**
     * Creates the `attestation` property of a RecordsWrite message if given signature inputs; returns `undefined` otherwise.
     */
    static createAttestation(descriptorCid: string, signers?: Signer[]): Promise<GeneralJws | undefined>;
    /**
     * Creates the `authorization` property of a RecordsWrite message.
     */
    static createAuthorSignature(recordId: string, contextId: string | undefined, descriptorCid: string, attestation: GeneralJws | undefined, encryption: EncryptionProperty | undefined, signer: Signer, additionalProperties?: {
        permissionsGrantId?: string;
        protocolRole?: string;
    }): Promise<GeneralJws>;
    /**
     * Gets the initial write from the given list or record write.
     */
    static getInitialWrite(messages: GenericMessage[]): Promise<RecordsWriteMessage>;
    /**
     * Verifies that immutable properties of the two given messages are identical.
     * @throws {Error} if immutable properties between two RecordsWrite message
     */
    static verifyEqualityOfImmutableProperties(existingWriteMessage: RecordsWriteMessage, newMessage: RecordsWriteMessage): boolean;
    /**
     * Gets the DID of the author of the given message.
     */
    static getAttesters(message: InternalRecordsWriteMessage): string[];
}
//# sourceMappingURL=records-write.d.ts.map