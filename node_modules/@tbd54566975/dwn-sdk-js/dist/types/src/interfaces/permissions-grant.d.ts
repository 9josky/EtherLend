import type { PermissionsRequest } from './permissions-request.js';
import type { Signer } from '../types/signer.js';
import type { PermissionConditions, PermissionScope } from '../types/permissions-types.js';
import type { PermissionsGrantMessage } from '../types/permissions-types.js';
import { Message } from '../core/message.js';
export type PermissionsGrantOptions = {
    messageTimestamp?: string;
    dateExpires: string;
    description?: string;
    grantedTo: string;
    grantedBy: string;
    grantedFor: string;
    permissionsRequestId?: string;
    scope: PermissionScope;
    conditions?: PermissionConditions;
    authorizationSigner: Signer;
};
export type CreateFromPermissionsRequestOverrides = {
    dateExpires: string;
    description?: string;
    grantedTo?: string;
    grantedBy?: string;
    grantedFor?: string;
    scope?: PermissionScope;
    conditions?: PermissionConditions;
};
export declare class PermissionsGrant extends Message<PermissionsGrantMessage> {
    static parse(message: PermissionsGrantMessage): Promise<PermissionsGrant>;
    static create(options: PermissionsGrantOptions): Promise<PermissionsGrant>;
    /**
     * generates a PermissionsGrant using the provided PermissionsRequest
     * @param permissionsRequest
     * @param authorizationSigner - the private key and additional signature material of the grantor
     * @param overrides - overrides that will be used instead of the properties in `permissionsRequest`
     */
    static createFromPermissionsRequest(permissionsRequest: PermissionsRequest, authorizationSigner: Signer, overrides: CreateFromPermissionsRequestOverrides): Promise<PermissionsGrant>;
    authorize(): void;
    /**
     * Validates scope structure for properties beyond `interface` and `method`.
     * Currently only grants for RecordsRead and RecordsWrite have such properties and need validation beyond JSON Schema.
     */
    static validateScope(permissionsGrantMessage: PermissionsGrantMessage): void;
}
//# sourceMappingURL=permissions-grant.d.ts.map