/// <reference types="readable-stream" />
import type { EventLog } from '../types/event-log.js';
import type { GenericMessageReply } from '../core/message-reply.js';
import type { MethodHandler } from '../types/method-handler.js';
import type { RecordsWriteMessageWithOptionalEncodedData } from '../store/storage-controller.js';
import type { DataStore, DidResolver, MessageStore } from '../index.js';
import type { RecordsDeleteMessage, RecordsWriteMessage } from '../types/records-types.js';
import { RecordsWrite } from '../interfaces/records-write.js';
export type RecordsWriteHandlerOptions = {
    skipDataStorage?: boolean;
};
type HandlerArgs = {
    tenant: string;
    message: RecordsWriteMessage;
    options?: RecordsWriteHandlerOptions;
    dataStream?: _Readable.Readable;
};
export declare class RecordsWriteHandler implements MethodHandler {
    private didResolver;
    private messageStore;
    private dataStore;
    private eventLog;
    constructor(didResolver: DidResolver, messageStore: MessageStore, dataStore: DataStore, eventLog: EventLog);
    handle({ tenant, message, options, dataStream }: HandlerArgs): Promise<GenericMessageReply>;
    /**
     * Embeds the record's data into the `encodedData` property.
     * If dataStream is present, it uses the dataStream. Otherwise, uses the `encodedData` from the most recent RecordsWrite.
     *
     * @returns {RecordsWriteMessageWithOptionalEncodedData} `encodedData` embedded.
     *
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteMissingDataInPrevious`
     *                    if `dataStream` is absent AND `encodedData` of previous message is missing
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataCidMismatch`
     *                    if the data stream resulted in a data CID that mismatches with `dataCid` in the given message
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataSizeMismatch`
     *                    if `dataSize` in `descriptor` given mismatches the actual data size
     */
    processEncodedData(message: RecordsWriteMessage, dataStream?: _Readable.Readable, newestExistingMessage?: RecordsWriteMessage | RecordsDeleteMessage): Promise<RecordsWriteMessageWithOptionalEncodedData>;
    /**
     * Puts the given data in storage unless tenant already has that data for the given recordId
     *
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteMissingDataAssociation`
     *                    if `dataStream` is absent AND unable to associate data given `dataCid`
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataCidMismatch`
     *                    if the data stream resulted in a data CID that mismatches with `dataCid` in the given message
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataSizeMismatch`
     *                    if `dataSize` in `descriptor` given mismatches the actual data size
     */
    putData(tenant: string, message: RecordsWriteMessage, dataStream?: _Readable.Readable): Promise<void>;
    /**
     * Validates the expected `dataCid` and `dataSize` in the descriptor vs the received data.
     *
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataCidMismatch`
     *                    if the data stream resulted in a data CID that mismatches with `dataCid` in the given message
     * @throws {DwnError} with `DwnErrorCode.RecordsWriteDataSizeMismatch`
     *                    if `dataSize` in `descriptor` given mismatches the actual data size
     */
    static validateDataIntegrity(expectedDataCid: string, expectedDataSize: number, actualDataCid: string, actualDataSize: number): void;
}
export declare function constructRecordsWriteIndexes(recordsWrite: RecordsWrite, isLatestBaseState: boolean): Promise<Record<string, string>>;
export {};
//# sourceMappingURL=records-write.d.ts.map