import type { DerivedPrivateJwk } from './hd-key.js';
import type { Readable } from 'readable-stream';
import type { Filter, GenericSignaturePayload } from '../types/message-types.js';
import type { RecordsDeleteMessage, RecordsFilter, RecordsQueryMessage, RecordsReadMessage, RecordsWriteDescriptor, RecordsWriteMessage } from '../types/records-types.js';
import { KeyDerivationScheme } from './hd-key.js';
/**
 * Class containing useful utilities related to the Records interface.
 */
export declare class Records {
    /**
     * Decrypts the encrypted data in a message reply using the given ancestor private key.
     * @param ancestorPrivateKey Any ancestor private key in the key derivation path.
     */
    static decrypt(recordsWrite: RecordsWriteMessage, ancestorPrivateKey: DerivedPrivateJwk, cipherStream: Readable): Promise<Readable>;
    /**
     * Constructs full key derivation path using the specified scheme.
     */
    static constructKeyDerivationPath(keyDerivationScheme: KeyDerivationScheme, recordsWriteMessage: RecordsWriteMessage): string[];
    /**
     * Constructs the full key derivation path using `dataFormats` scheme.
     */
    static constructKeyDerivationPathUsingDataFormatsScheme(schema: string | undefined, dataFormat: string): string[];
    /**
     * Constructs the full key derivation path using `protocolPath` scheme.
     */
    static constructKeyDerivationPathUsingProtocolPathScheme(descriptor: RecordsWriteDescriptor): string[];
    /**
     * Constructs the full key derivation path using `protocolContext` scheme.
     */
    static constructKeyDerivationPathUsingProtocolContextScheme(contextId: string | undefined): string[];
    /**
     * Constructs the full key derivation path using `schemas` scheme.
     */
    static constructKeyDerivationPathUsingSchemasScheme(schema: string | undefined): string[];
    /**
     * Derives a descendant private key given an ancestor private key and the full absolute derivation path.
     * NOTE: right now only `ECIES-ES256K` algorithm is supported for asymmetric encryption,
     *       so we will only derive SECP256K1 key without additional conditional checks
     */
    static derivePrivateKey(ancestorPrivateKey: DerivedPrivateJwk, fullDescendantDerivationPath: string[]): Promise<Uint8Array>;
    /**
     * Validates that ancestor derivation path matches the descendant derivation path completely.
     * @throws {DwnError} with `DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment` if fails validation.
     */
    static validateAncestorKeyAndDescentKeyDerivationPathsMatch(ancestorKeyDerivationPath: string[], descendantKeyDerivationPath: string[]): void;
    /**
     * Normalizes the protocol and schema URLs within a provided RecordsFilter and returns a copy of RecordsFilter with the modified values.
     *
     * @param filter incoming RecordsFilter to normalize.
     * @returns {RecordsFilter} a copy of the incoming RecordsFilter with the normalized properties.
     */
    static normalizeFilter(filter: RecordsFilter): RecordsFilter;
    /**
     *  Converts an incoming RecordsFilter into a Filter usable by MessageStore.
     *
     * @param filter A RecordsFilter
     * @returns {Filter} a generic Filter able to be used with MessageStore.
     */
    static convertFilter(filter: RecordsFilter): Filter;
    private static convertRangeCriterion;
    /**
     * Validates the referential integrity regarding delegated grant.
     * @param signaturePayload Decoded payload of the signature of the message. `undefined` if message is not signed.
     *                         Usage of this property is purely for performance optimization so we don't have to decode the signature payload again.
     */
    static validateDelegatedGrantReferentialIntegrity(message: RecordsReadMessage | RecordsQueryMessage | RecordsWriteMessage | RecordsDeleteMessage, signaturePayload: GenericSignaturePayload | undefined): void;
}
//# sourceMappingURL=records.d.ts.map