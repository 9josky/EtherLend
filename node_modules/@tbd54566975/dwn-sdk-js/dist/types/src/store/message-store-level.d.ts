import type { Filter, GenericMessage, MessageSort, Pagination } from '../types/message-types.js';
import type { MessageStore, MessageStoreOptions } from '../types/message-store.js';
import { BlockstoreLevel } from './blockstore-level.js';
import { createLevelDatabase } from './level-wrapper.js';
import { IndexLevel } from './index-level.js';
import { SortOrder } from '../types/message-types.js';
/**
 * A simple implementation of {@link MessageStore} that works in both the browser and server-side.
 * Leverages LevelDB under the hood.
 */
export declare class MessageStoreLevel implements MessageStore {
    config: MessageStoreLevelConfig;
    blockstore: BlockstoreLevel;
    index: IndexLevel;
    /**
     * @param {MessageStoreLevelConfig} config
     * @param {string} config.blockstoreLocation - must be a directory path (relative or absolute) where
     *  LevelDB will store its files, or in browsers, the name of the
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase IDBDatabase} to be opened.
     * @param {string} config.indexLocation - same as config.blockstoreLocation
     */
    constructor(config?: MessageStoreLevelConfig);
    open(): Promise<void>;
    close(): Promise<void>;
    get(tenant: string, cidString: string, options?: MessageStoreOptions): Promise<GenericMessage | undefined>;
    query(tenant: string, filters: Filter[], messageSort?: MessageSort, pagination?: Pagination, options?: MessageStoreOptions): Promise<{
        messages: GenericMessage[];
        paginationMessageCid?: string;
    }>;
    private paginateMessages;
    /**
     * Compares the chosen property of two messages in lexicographical order.
     * When the value is the same between the two objects, `messageCid` comparison is used to tiebreak.
     * tiebreaker always compares messageA to messageB
     *
     * @returns if SortOrder is Ascending:
     *            1 if the chosen property of `messageA` is larger than of `messageB`;
     *           -1 if the chosen property `messageA` is smaller/older than of `messageB`;
     *            0 otherwise
     *          if SortOrder is Descending:
     *            1 if the chosen property of `messageB` is larger than of `messageA`;
     *           -1 if the chosen property `messageB` is smaller/older than of `messageA`;
     *            0 otherwise
     */
    static lexicographicalCompare(messageA: GenericMessage, messageB: GenericMessage, comparedPropertyName: string, sortOrder: SortOrder): Promise<number>;
    /**
     * This is a temporary naive sort, it will eventually be done within the underlying data store.
     *
     * If sorting is based on date published, records that are not published are filtered out.
     * @param messages - Messages to be sorted if dateSort is present
     * @param sort - Sorting scheme
     * @returns Sorted Messages
     */
    static sortMessages(messages: GenericMessage[], messageSort?: MessageSort): Promise<GenericMessage[]>;
    delete(tenant: string, cidString: string, options?: MessageStoreOptions): Promise<void>;
    put(tenant: string, message: GenericMessage, indexes: {
        [key: string]: string | boolean;
    }, options?: MessageStoreOptions): Promise<void>;
    /**
     * deletes everything in the underlying blockstore and indices.
     */
    clear(): Promise<void>;
    dump(): Promise<void>;
}
type MessageStoreLevelConfig = {
    blockstoreLocation?: string;
    indexLocation?: string;
    createLevelDatabase?: typeof createLevelDatabase;
};
export {};
//# sourceMappingURL=message-store-level.d.ts.map