import type { DidResolutionResult } from '../../src/types/did-types.js';
import type { GeneralJws } from '../../src/types/jws-types.js';
import type { Readable } from 'readable-stream';
import type { RecordsFilter } from '../../src/types/records-types.js';
import type { AuthorizationModel, Pagination } from '../../src/types/message-types.js';
import type { DateSort, EncryptionInput, EventsGetMessage, MessagesGetMessage, ProtocolDefinition, ProtocolsConfigureMessage, ProtocolsQueryMessage, RecordsDeleteMessage, RecordsQueryMessage, RecordsWriteMessage } from '../../src/index.js';
import type { PermissionConditions, PermissionScope } from '../../src/types/permissions-grant-descriptor.js';
import type { PermissionsGrantMessage, PermissionsRequestMessage, PermissionsRevokeMessage } from '../../src/types/permissions-types.js';
import type { PrivateJwk, PublicJwk } from '../../src/types/jose-types.js';
import { PermissionsGrant } from '../../src/interfaces/permissions-grant.js';
import { PermissionsRequest } from '../../src/interfaces/permissions-request.js';
import { PermissionsRevoke } from '../../src/interfaces/permissions-revoke.js';
import { EventsGet, MessagesGet, ProtocolsConfigure, ProtocolsQuery, RecordsDelete, RecordsWrite } from '../../src/index.js';
/**
 * A logical grouping of user data used to generate test messages.
 */
export type Persona = {
    did: string;
    keyId: string;
    keyPair: {
        publicJwk: PublicJwk;
        privateJwk: PrivateJwk;
    };
};
export type GenerateProtocolsConfigureInput = {
    /**
     * Denotes if the Protocol Definition can be returned by unauthenticated `ProtocolsQuery`.
     * Only takes effect if `protocolDefinition` is not explicitly set. Defaults to false if not specified.
     */
    published?: boolean;
    /**
     * Author who will be signing the protocol config created.
     */
    author?: Persona;
    messageTimestamp?: string;
    protocolDefinition?: ProtocolDefinition;
    permissionsGrantId?: string;
};
export type GenerateProtocolsConfigureOutput = {
    author: Persona;
    message: ProtocolsConfigureMessage;
    protocolsConfigure: ProtocolsConfigure;
};
export type GenerateProtocolsQueryInput = {
    author?: Persona;
    messageTimestamp?: string;
    permissionsGrantId?: string;
    filter?: {
        protocol: string;
    };
};
export type GenerateProtocolsQueryOutput = {
    author: Persona;
    message: ProtocolsQueryMessage;
    protocolsQuery: ProtocolsQuery;
};
export type GenerateRecordsWriteInput = {
    author?: Persona;
    attesters?: Persona[];
    recipient?: string;
    protocol?: string;
    protocolPath?: string;
    protocolRole?: string;
    contextId?: string;
    schema?: string;
    recordId?: string;
    parentId?: string;
    published?: boolean;
    data?: Uint8Array;
    dataCid?: string;
    dataSize?: number;
    dataFormat?: string;
    dateCreated?: string;
    messageTimestamp?: string;
    datePublished?: string;
    encryptionInput?: EncryptionInput;
    permissionsGrantId?: string;
};
export type GenerateFromRecordsWriteInput = {
    author: Persona;
    existingWrite: RecordsWrite;
    data?: Uint8Array;
    published?: boolean;
    messageTimestamp?: string;
    datePublished?: string;
    protocolRole?: string;
};
export type GenerateFromRecordsWriteOut = {
    message: RecordsWriteMessage;
    dataBytes: Uint8Array;
    dataStream: Readable;
    recordsWrite: RecordsWrite;
};
export type GenerateRecordsWriteOutput = {
    author: Persona;
    message: RecordsWriteMessage;
    dataCid?: string;
    dataSize?: number;
    dataBytes?: Uint8Array;
    dataStream?: Readable;
    recordsWrite: RecordsWrite;
};
export type GenerateRecordsQueryInput = {
    /**
     * Treated as `false` if not given.
     */
    anonymous?: boolean;
    author?: Persona;
    messageTimestamp?: string;
    filter?: RecordsFilter;
    dateSort?: DateSort;
    pagination?: Pagination;
    protocolRole?: string;
};
export type GenerateRecordsQueryOutput = {
    author: Persona | undefined;
    message: RecordsQueryMessage;
};
export type GenerateRecordsDeleteInput = {
    author?: Persona;
    recordId?: string;
    protocolRole?: string;
};
export type GenerateRecordsDeleteOutput = {
    author: Persona;
    recordsDelete: RecordsDelete;
    message: RecordsDeleteMessage;
};
export type GeneratePermissionsRequestInput = {
    author: Persona;
    messageTimestamp?: string;
    description?: string;
    grantedTo?: string;
    grantedBy?: string;
    grantedFor?: string;
    scope?: PermissionScope;
    conditions?: PermissionConditions;
};
export type GeneratePermissionsGrantInput = {
    author: Persona;
    messageTimestamp?: string;
    dateExpires?: string;
    description?: string;
    grantedTo?: string;
    grantedBy?: string;
    grantedFor?: string;
    permissionsRequestId?: string;
    scope?: PermissionScope;
    conditions?: PermissionConditions;
};
export type GeneratePermissionsRevokeInput = {
    author: Persona;
    dateCreated?: string;
    permissionsGrantId?: string;
};
export type GeneratePermissionsRequestOutput = {
    author: Persona;
    permissionsRequest: PermissionsRequest;
    message: PermissionsRequestMessage;
};
export type GeneratePermissionsGrantOutput = {
    author: Persona;
    permissionsGrant: PermissionsGrant;
    message: PermissionsGrantMessage;
};
export type GeneratePermissionsRevokeOutput = {
    author: Persona;
    permissionsRevoke: PermissionsRevoke;
    message: PermissionsRevokeMessage;
};
export type GenerateEventsGetInput = {
    author?: Persona;
    watermark?: string;
};
export type GenerateEventsGetOutput = {
    author: Persona;
    eventsGet: EventsGet;
    message: EventsGetMessage;
};
export type GenerateMessagesGetInput = {
    author?: Persona;
    messageCids: string[];
};
export type GenerateMessagesGetOutput = {
    author: Persona;
    message: MessagesGetMessage;
    messagesGet: MessagesGet;
};
/**
 * Utility class for generating data for testing.
 */
export declare class TestDataGenerator {
    /**
     * Generates a persona.
     */
    static generatePersona(input?: Partial<Persona>): Promise<Persona>;
    /**
     * Generates a ProtocolsConfigure message for testing.
     * Optional parameters are generated if not given.
     * Implementation currently uses `ProtocolsConfigure.create()`.
     */
    static generateProtocolsConfigure(input?: GenerateProtocolsConfigureInput): Promise<GenerateProtocolsConfigureOutput>;
    /**
     * Generates a ProtocolsQuery message for testing.
     */
    static generateProtocolsQuery(input?: GenerateProtocolsQueryInput): Promise<GenerateProtocolsQueryOutput>;
    /**
     * Generates a RecordsWrite message for testing.
     * Implementation currently uses `RecordsWrite.create()`.
     * @param input.attesters Attesters of the message. Will NOT be generated if not given.
     * @param input.data Data that belongs to the record. Generated when not given only if `dataCid` and `dataSize` are also not given.
     * @param input.dataFormat Format of the data. Defaults to 'application/json' if not given.
     * @param input.signer Signer of the message. Generated if not given.
     * @param input.schema Schema of the message. Randomly generated if not given.
     */
    static generateRecordsWrite(input?: GenerateRecordsWriteInput): Promise<GenerateRecordsWriteOutput>;
    /**
     * Generates a encrypted RecordsWrite message for testing.
     *
     * @param input.protocolDefinition Protocol definition used to generate the RecordsWrite.
     *        Must be the RECIPIENT's protocol definition if `encryptSymmetricKeyWithProtocolPathDerivedKey` is true,
     *        because the recipient's public keys will be needed to encrypt the symmetric key.
     *
     * @param input.encryptSymmetricKeyWithProtocolPathDerivedKey
     *        Set to `true` to attach the symmetric key encrypted by the protocol path derived public key
     *
     * @param input.encryptSymmetricKeyWithProtocolContextDerivedKey
     *        Set to `true` to attach the symmetric key encrypted by the protocol context derived public key
     */
    static generateProtocolEncryptedRecordsWrite(input: {
        plaintextBytes: Uint8Array;
        author: Persona;
        recipient?: string;
        protocolDefinition: ProtocolDefinition;
        protocolPath: string;
        protocolContextId?: string;
        protocolContextDerivingRootKeyId?: string;
        protocolContextDerivedPublicJwk?: PublicJwk;
        protocolParentId?: string;
        encryptSymmetricKeyWithProtocolPathDerivedKey: boolean;
        encryptSymmetricKeyWithProtocolContextDerivedKey: boolean;
    }): Promise<{
        message: RecordsWriteMessage;
        dataStream: Readable;
        recordsWrite: RecordsWrite;
        encryptionInput: EncryptionInput;
        encryptedDataBytes: Uint8Array;
    }>;
    /**
     * Generates a valid RecordsWrite that modifies the given an existing write.
     * Any mutable property is not specified will be automatically mutated.
     * e.g. if `published` is not specified, it will be toggled from the state of the given existing write.
     */
    static generateFromRecordsWrite(input: GenerateFromRecordsWriteInput): Promise<GenerateFromRecordsWriteOut>;
    /**
     * Generates a RecordsQuery message for testing.
     */
    static generateRecordsQuery(input?: GenerateRecordsQueryInput): Promise<GenerateRecordsQueryOutput>;
    /**
     * Generates a RecordsDelete for testing.
     */
    static generateRecordsDelete(input?: GenerateRecordsDeleteInput): Promise<GenerateRecordsDeleteOutput>;
    /**
     * Generates a PermissionsRequest message for testing.
     */
    static generatePermissionsRequest(input?: GeneratePermissionsRequestInput): Promise<GeneratePermissionsRequestOutput>;
    /**
     * Generates a PermissionsGrant message for testing.
     */
    static generatePermissionsGrant(input?: GeneratePermissionsGrantInput): Promise<GeneratePermissionsGrantOutput>;
    /**
     * Generates a PermissionsRevoke message for testing.
     */
    static generatePermissionsRevoke(input?: GeneratePermissionsRevokeInput): Promise<GeneratePermissionsRevokeOutput>;
    static generateEventsGet(input?: GenerateEventsGetInput): Promise<GenerateEventsGetOutput>;
    static generateMessagesGet(input: GenerateMessagesGetInput): Promise<GenerateMessagesGetOutput>;
    /**
     * Generates a dummy `authorization` property for a DWN message that only conforms to schema validation.
     */
    static generateAuthorization(): AuthorizationModel;
    /**
     * Generates a dummy `authorization` property for a DWN message that only conforms to schema validation.
     */
    static generateAuthorizationSignature(): GeneralJws;
    /**
     * Generates a random alpha-numeric string.
     */
    static randomString(length: number): string;
    /**
     * Generates a random byte array of given length.
     */
    static randomBytes(length: number): Uint8Array;
    /**
     * Generates a random CBOR SHA256 CID.
     */
    static randomCborSha256Cid(): Promise<string>;
    /**
     * Generates a random within a range (inclusive).
     * @param min lowest potential value.
     * @param max greatest potential value.
     */
    static randomInt(min: number, max: number): number;
    /**
     * Generates a random timestamp. Optionally allows you to set specific non-randomized values for the timestamp.
     *
     * @returns random UTC ISO-8601 timestamp
     */
    static randomTimestamp(options?: {
        year?: number;
        month?: number;
        day?: number;
        hour?: number;
        minute?: number;
        second?: number;
        millisecond?: number;
        microsecond?: number;
    }): string;
    /**
     * Creates a mock DID resolution result for testing purposes.
     */
    static createDidResolutionResult(persona: Persona): DidResolutionResult;
}
//# sourceMappingURL=test-data-generator.d.ts.map