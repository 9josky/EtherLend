var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Secp256k1 } from './secp256k1.js';
export var KeyDerivationScheme;
(function (KeyDerivationScheme) {
    /**
     * Key derivation using the `dataFormat` value for Flat-space records.
     */
    KeyDerivationScheme["DataFormats"] = "dataFormats";
    KeyDerivationScheme["ProtocolContext"] = "protocolContext";
    KeyDerivationScheme["ProtocolPath"] = "protocolPath";
    /**
     * Key derivation using the `schema` value for Flat-space records.
     */
    KeyDerivationScheme["Schemas"] = "schemas";
})(KeyDerivationScheme || (KeyDerivationScheme = {}));
/**
 * Class containing hierarchical deterministic key related utility methods used by the DWN.
 */
export class HdKey {
    /**
     * Derives a descendant private key.
     * NOTE: currently only supports SECP256K1 keys.
     */
    static derivePrivateKey(ancestorKey, subDerivationPath) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const ancestorPrivateKey = Secp256k1.privateJwkToBytes(ancestorKey.derivedPrivateKey);
            const ancestorPrivateKeyDerivationPath = (_a = ancestorKey.derivationPath) !== null && _a !== void 0 ? _a : [];
            const derivedPrivateKeyBytes = yield Secp256k1.derivePrivateKey(ancestorPrivateKey, subDerivationPath);
            const derivedPrivateJwk = yield Secp256k1.privateKeyToJwk(derivedPrivateKeyBytes);
            const derivedDescendantPrivateKey = {
                rootKeyId: ancestorKey.rootKeyId,
                derivationScheme: ancestorKey.derivationScheme,
                derivationPath: [...ancestorPrivateKeyDerivationPath, ...subDerivationPath],
                derivedPrivateKey: derivedPrivateJwk
            };
            return derivedDescendantPrivateKey;
        });
    }
    /**
     * Derives a descendant public key from an ancestor private key.
     * NOTE: currently only supports SECP256K1 keys.
     */
    static derivePublicKey(ancestorKey, subDerivationPath) {
        return __awaiter(this, void 0, void 0, function* () {
            const derivedDescendantPrivateKey = yield HdKey.derivePrivateKey(ancestorKey, subDerivationPath);
            const derivedDescendantPublicKey = yield Secp256k1.getPublicJwk(derivedDescendantPrivateKey.derivedPrivateKey);
            return derivedDescendantPublicKey;
        });
    }
}
//# sourceMappingURL=hd-key.js.map