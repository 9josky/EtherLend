var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import varint from 'varint';
import chai, { expect } from 'chai';
import { base58btc } from 'multiformats/bases/base58';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
// extends chai to test promises
chai.use(chaiAsPromised);
describe('DidKeyResolver', () => {
    it('should resolve a ed25519 `did:key` DID correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c;
        // test vector taken from https://w3c-ccg.github.io/did-method-key/#ed25519-x25519
        const did = 'did:key:z6MkiTBz1ymuepAQ4HEHYSF1H8quG5GLVVQR3djdX3mDooWp';
        const resolver = new DidKeyResolver();
        const resolutionDocument = yield resolver.resolve(did);
        const didDocument = resolutionDocument.didDocument;
        expect(didDocument.id).to.equal(did);
        expect((_a = didDocument['@context']) === null || _a === void 0 ? void 0 : _a.indexOf('https://w3id.org/security/suites/ed25519-2020/v1')).to.not.equal(-1);
        const verificationMethod = (_b = resolutionDocument.didDocument) === null || _b === void 0 ? void 0 : _b.verificationMethod[0];
        expect((_c = verificationMethod.publicKeyJwk) === null || _c === void 0 ? void 0 : _c.x).to.equal('O2onvM62pC1io6jQKm8Nc2UyFXcd4kOmOsBIoYtZ2ik');
    }));
    it('should resolve a secp256k1 `did:key` DID correctly', () => __awaiter(void 0, void 0, void 0, function* () {
        var _d, _e, _f, _g, _h;
        // test vector taken from:
        // https://github.com/transmute-industries/did-key.js/blob/main/packages/did-key-test-vectors/src/secp256k1/did-key-secp256k1-case-0.json
        const did = 'did:key:zQ3shjRPgHQQbTtXyofk1ygghRJ75RZpXmWBMY1BKnhyz7zKp';
        const resolver = new DidKeyResolver();
        const resolutionDocument = yield resolver.resolve(did);
        expect((_d = resolutionDocument.didDocument) === null || _d === void 0 ? void 0 : _d.id).to.equal(did);
        expect((_e = resolutionDocument['@context']) === null || _e === void 0 ? void 0 : _e.indexOf('https://w3id.org/security/suites/ed25519-2020/v1')).to.equal(-1);
        const verificationMethod = (_f = resolutionDocument.didDocument) === null || _f === void 0 ? void 0 : _f.verificationMethod[0];
        expect((_g = verificationMethod.publicKeyJwk) === null || _g === void 0 ? void 0 : _g.x).to.equal('RwiZITTa2Dcmq-V1j-5tgPUshOLO31FbsnhVS-7lskc');
        expect((_h = verificationMethod.publicKeyJwk) === null || _h === void 0 ? void 0 : _h.y).to.equal('3o1-UCc3ABh757P58gDISSc4hOj9qyfSGl3SGGA7xdc');
    }));
    it('should resolve a `did:key` DID that the library generates', () => __awaiter(void 0, void 0, void 0, function* () {
        var _j, _k, _l;
        const { did, keyPair } = yield DidKeyResolver.generate();
        const resolver = new DidKeyResolver();
        const resolutionDocument = yield resolver.resolve(did);
        expect((_j = resolutionDocument.didDocument) === null || _j === void 0 ? void 0 : _j.id).to.equal(did);
        const verificationMethod = (_k = resolutionDocument.didDocument) === null || _k === void 0 ? void 0 : _k.verificationMethod[0];
        expect((_l = verificationMethod.publicKeyJwk) === null || _l === void 0 ? void 0 : _l.x).to.equal(keyPair.publicJwk.x);
    }));
    it('should throw if DID is using unsupported multicodec', () => __awaiter(void 0, void 0, void 0, function* () {
        const unsupportedMulticodec = varint.encode(0x01); // any unsupported multicodec
        const idBytes = new Uint8Array(unsupportedMulticodec.length); // just allocate for the multicodec for testing
        idBytes.set(unsupportedMulticodec, 0);
        const id = base58btc.encode(idBytes);
        const did = `did:key:${id}`;
        const didKeyResolver = new DidKeyResolver();
        const resolutionDocument = yield didKeyResolver.resolve(did);
        expect(resolutionDocument.didDocument).to.equal(undefined);
        expect(resolutionDocument.didResolutionMetadata.error).to.equal('invalidDid');
    }));
    it('should throw if key is invalid', () => __awaiter(void 0, void 0, void 0, function* () {
        const did = 'did:ion:SomethingThatCannotBeResolved';
        const didIonResolver = new DidKeyResolver();
        const resolutionDocument = yield didIonResolver.resolve(did);
        expect(resolutionDocument.didDocument).to.equal(undefined);
        expect(resolutionDocument.didResolutionMetadata.error).to.equal('invalidDid');
    }));
});
//# sourceMappingURL=did-key-resolver.spec.js.map