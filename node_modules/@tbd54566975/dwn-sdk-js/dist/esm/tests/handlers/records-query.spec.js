var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import freeForAll from '../vectors/protocol-definitions/free-for-all.json' assert { type: 'json' };
import friendRoleProtocolDefinition from '../vectors/protocol-definitions/friend-role.json' assert { type: 'json' };
import threadRoleProtocolDefinition from '../vectors/protocol-definitions/thread-role.json' assert { type: 'json' };
import { ArrayUtility } from '../../src/utils/array.js';
import { DateSort } from '../../src/types/records-types.js';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DwnConstant } from '../../src/core/dwn-constant.js';
import { Encoder } from '../../src/utils/encoder.js';
import { Jws } from '../../src/utils/jws.js';
import { Message } from '../../src/core/message.js';
import { RecordsQuery } from '../../src/interfaces/records-query.js';
import { RecordsQueryHandler } from '../../src/handlers/records-query.js';
import { RecordsWriteHandler } from '../../src/handlers/records-write.js';
import { SortOrder } from '../../src/types/message-types.js';
import { stubInterface } from 'ts-sinon';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { TestStubGenerator } from '../utils/test-stub-generator.js';
import { DidResolver, Dwn, RecordsWrite, Time } from '../../src/index.js';
import { DwnErrorCode, MessageStoreLevel } from '../../src/index.js';
chai.use(chaiAsPromised);
export function testRecordsQueryHandler() {
    describe('RecordsQueryHandler.handle()', () => {
        describe('functional tests', () => {
            let didResolver;
            let messageStore;
            let dataStore;
            let eventLog;
            let dwn;
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new DidResolver([new DidKeyResolver()]);
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should return recordId, descriptor, authorization and attestation', () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const alice = yield TestDataGenerator.generatePersona();
                const bob = yield TestDataGenerator.generatePersona();
                TestStubGenerator.stubDidResolver(didResolver, [alice, bob]);
                const dataFormat = 'myAwesomeDataFormat';
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob], dataFormat });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const query = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, query.message);
                expect((_a = reply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
                const entry = reply.entries[0];
                expect(entry.authorization).to.deep.equal(write.message.authorization);
                expect(entry.attestation).to.deep.equal(write.message.attestation);
                expect(entry.descriptor).to.deep.equal(write.message.descriptor);
                expect(entry.recordId).to.equal(write.message.recordId);
            }));
            it('should return records matching the query', () => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                // insert three messages into DB, two with matching protocol
                const alice = yield TestDataGenerator.generatePersona();
                const dataFormat = 'myAwesomeDataFormat';
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema1' });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema2' });
                // setting up a stub resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing singular conditional query
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_b = reply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(2); // only 2 entries should match the query on protocol
                // testing multi-conditional query, reuse data generated above for bob
                const messageData2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        dataFormat,
                        schema: 'schema1'
                    }
                });
                const reply2 = yield dwn.processMessage(alice.did, messageData2.message);
                expect(reply2.status.code).to.equal(200);
                expect((_c = reply2.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1); // only 1 entry should match the query
            }));
            it('should return `encodedData` if data size is within the spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _d;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded); // within/on threshold
                const alice = yield DidKeyResolver.generate();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_d = reply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(data));
            }));
            it('should not return `encodedData` if data size is greater then spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _e;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1); // exceeding threshold
                const alice = yield DidKeyResolver.generate();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_e = reply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.be.undefined;
            }));
            it('should be able to query by attester', () => __awaiter(this, void 0, void 0, function* () {
                var _f, _g, _h;
                // scenario: 2 records authored by alice, 1st attested by alice, 2nd attested by bob
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const recordsWrite1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const recordsWrite2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob] });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, recordsWrite1.message, recordsWrite1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, recordsWrite2.message, recordsWrite2.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                // testing attester filter
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: alice.did } });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_f = reply1.entries) === null || _f === void 0 ? void 0 : _f.length).to.equal(1);
                const reply1Attester = Jws.getSignerDid(reply1.entries[0].attestation.signatures[0]);
                expect(reply1Attester).to.equal(alice.did);
                // testing attester + another filter
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { attester: bob.did, schema: recordsWrite2.message.descriptor.schema }
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_g = reply2.entries) === null || _g === void 0 ? void 0 : _g.length).to.equal(1);
                const reply2Attester = Jws.getSignerDid(reply2.entries[0].attestation.signatures[0]);
                expect(reply2Attester).to.equal(bob.did);
                // testing attester filter that yields no results
                const carol = yield DidKeyResolver.generate();
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: carol.did } });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_h = reply3.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(0);
            }));
            it('should be able to query by author', () => __awaiter(this, void 0, void 0, function* () {
                var _j, _k;
                // scenario alice and bob both author records into alice's DWN.
                // alice is able to filter for records authored by bob.
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const protocolDefinition = freeForAll;
                const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                    author: alice,
                    protocolDefinition
                });
                const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                expect(protocolsConfigureReply.status.code).to.equal(202);
                const aliceAuthorWrite = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const aliceAuthorReply = yield dwn.processMessage(alice.did, aliceAuthorWrite.message, aliceAuthorWrite.dataStream);
                expect(aliceAuthorReply.status.code).to.equal(202);
                const bobAuthorWrite = yield TestDataGenerator.generateRecordsWrite({
                    author: bob,
                    protocol: protocolDefinition.protocol,
                    schema: protocolDefinition.types.post.schema,
                    dataFormat: protocolDefinition.types.post.dataFormats[0],
                    protocolPath: 'post'
                });
                const bobAuthorReply = yield dwn.processMessage(alice.did, bobAuthorWrite.message, bobAuthorWrite.dataStream);
                expect(bobAuthorReply.status.code).to.equal(202);
                // alice queries with an empty filter, gets both
                let recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                let queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_j = queryReply.entries) === null || _j === void 0 ? void 0 : _j.length).to.equal(2);
                // filter for bob as author
                recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        author: bob.did,
                        protocol: protocolDefinition.protocol,
                        schema: protocolDefinition.types.post.schema,
                        dataFormat: protocolDefinition.types.post.dataFormats[0],
                        protocolPath: 'post'
                    }
                });
                queryReply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_k = queryReply.entries) === null || _k === void 0 ? void 0 : _k.length).to.equal(1);
                expect(queryReply.entries[0].recordId).to.equal(bobAuthorWrite.message.recordId);
            }));
            it('should be able to query for published records', () => __awaiter(this, void 0, void 0, function* () {
                var _l, _m, _o, _p, _q, _r, _s, _t, _u;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, publishedWrite.dataStream);
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, draftWrite.dataStream);
                expect(draftWriteReply.status.code).to.equal(202);
                // query for only published records
                const publishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: true } });
                let publishedPostReply = yield dwn.processMessage(alice.did, publishedPostQuery.message);
                expect(publishedPostReply.status.code).to.equal(200);
                expect((_l = publishedPostReply.entries) === null || _l === void 0 ? void 0 : _l.length).to.equal(1);
                expect(publishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // make an query for published records from non owner
                const notOwnerPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: true } });
                let notOwnerPublishedPostReply = yield dwn.processMessage(alice.did, notOwnerPostQuery.message);
                expect(notOwnerPublishedPostReply.status.code).to.equal(200);
                expect((_m = notOwnerPublishedPostReply.entries) === null || _m === void 0 ? void 0 : _m.length).to.equal(1);
                expect(notOwnerPublishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // anonymous query for published records
                const anonymousPostQuery = yield RecordsQuery.create({ filter: { schema: 'post', published: true } });
                let anonymousPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(anonymousPublishedPostReply.status.code).to.equal(200);
                expect((_o = anonymousPublishedPostReply.entries) === null || _o === void 0 ? void 0 : _o.length).to.equal(1);
                expect(anonymousPublishedPostReply.entries[0].recordId).to.equal(publishedWrite.message.recordId);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // issue the same query for published records
                publishedPostReply = yield dwn.processMessage(alice.did, publishedPostQuery.message);
                expect(publishedPostReply.status.code).to.equal(200);
                expect((_p = publishedPostReply.entries) === null || _p === void 0 ? void 0 : _p.length).to.equal(2);
                const returnedRecordIds = (_q = publishedPostReply.entries) === null || _q === void 0 ? void 0 : _q.map(e => e.recordId);
                // ensure that both records now exist in results
                expect(returnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
                // query after publishing from non owner
                notOwnerPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(notOwnerPublishedPostReply.status.code).to.equal(200);
                expect((_r = notOwnerPublishedPostReply.entries) === null || _r === void 0 ? void 0 : _r.length).to.equal(2);
                const nonOwnerReturnedRecordIds = (_s = notOwnerPublishedPostReply.entries) === null || _s === void 0 ? void 0 : _s.map(e => e.recordId);
                expect(nonOwnerReturnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
                // anonymous query after publishing
                anonymousPublishedPostReply = yield dwn.processMessage(alice.did, anonymousPostQuery.message);
                expect(anonymousPublishedPostReply.status.code).to.equal(200);
                expect((_t = anonymousPublishedPostReply.entries) === null || _t === void 0 ? void 0 : _t.length).to.equal(2);
                const anonymousReturnedRecordIds = (_u = anonymousPublishedPostReply.entries) === null || _u === void 0 ? void 0 : _u.map(e => e.recordId);
                expect(anonymousReturnedRecordIds).to.have.members([publishedWrite.message.recordId, draftWrite.message.recordId]);
            }));
            it('should be able to query for unpublished records', () => __awaiter(this, void 0, void 0, function* () {
                var _v, _w;
                const alice = yield DidKeyResolver.generate();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, publishedWrite.dataStream);
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, draftWrite.dataStream);
                expect(draftWriteReply.status.code).to.equal(202);
                // query for only unpublished records
                const unpublishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: false } });
                let unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_v = unpublishedPostReply.entries) === null || _v === void 0 ? void 0 : _v.length).to.equal(1);
                expect(unpublishedPostReply.entries[0].recordId).to.equal(draftWrite.message.recordId);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // issue the same query for unpublished records
                unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_w = unpublishedPostReply.entries) === null || _w === void 0 ? void 0 : _w.length).to.equal(0);
            }));
            it('should not be able to query for unpublished records if unauthorized', () => __awaiter(this, void 0, void 0, function* () {
                var _x, _y, _z, _0;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                // create a published record
                const publishedWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true, schema: 'post' });
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWrite.message, publishedWrite.dataStream);
                expect(publishedWriteReply.status.code).to.equal(202);
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, draftWrite.dataStream);
                expect(draftWriteReply.status.code).to.equal(202);
                // bob queries for unpublished records returns zero
                const unpublishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: false } });
                let notOwnerPostReply = yield dwn.processMessage(alice.did, unpublishedNotOwner.message);
                expect(notOwnerPostReply.status.code).to.equal(200);
                expect((_x = notOwnerPostReply.entries) === null || _x === void 0 ? void 0 : _x.length).to.equal(0);
                // publish the unpublished record
                const publishedDraftWrite = yield RecordsWrite.createFrom({
                    recordsWriteMessage: draftWrite.message,
                    published: true,
                    signer: Jws.createSigner(alice)
                });
                const publishedDraftReply = yield dwn.processMessage(alice.did, publishedDraftWrite.message);
                expect(publishedDraftReply.status.code).to.equal(202);
                // without published filter
                let publishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post' } });
                let publishedNotOwnerReply = yield dwn.processMessage(alice.did, publishedNotOwner.message);
                expect(publishedNotOwnerReply.status.code).to.equal(200);
                expect((_y = publishedNotOwnerReply.entries) === null || _y === void 0 ? void 0 : _y.length).to.equal(2);
                // with explicit published true
                publishedNotOwner = yield TestDataGenerator.generateRecordsQuery({ author: bob, filter: { schema: 'post', published: true } });
                publishedNotOwnerReply = yield dwn.processMessage(alice.did, publishedNotOwner.message);
                expect(publishedNotOwnerReply.status.code).to.equal(200);
                expect((_z = publishedNotOwnerReply.entries) === null || _z === void 0 ? void 0 : _z.length).to.equal(2);
                // with explicit published false after publishing should still return nothing
                notOwnerPostReply = yield dwn.processMessage(alice.did, unpublishedNotOwner.message);
                expect(notOwnerPostReply.status.code).to.equal(200);
                expect((_0 = notOwnerPostReply.entries) === null || _0 === void 0 ? void 0 : _0.length).to.equal(0);
            }));
            it('should be able to query for a record by a dataCid', () => __awaiter(this, void 0, void 0, function* () {
                var _1;
                const alice = yield DidKeyResolver.generate();
                // create a record
                const writeRecord = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeRecordReply = yield dwn.processMessage(alice.did, writeRecord.message, writeRecord.dataStream);
                expect(writeRecordReply.status.code).to.equal(202);
                const recordDataCid = writeRecord.message.descriptor.dataCid;
                // query for the record by it's dataCid
                const dataCidQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataCid: recordDataCid } });
                const dataCidQueryReply = yield dwn.processMessage(alice.did, dataCidQuery.message);
                expect(dataCidQueryReply.status.code).to.equal(200);
                expect((_1 = dataCidQueryReply.entries) === null || _1 === void 0 ? void 0 : _1.length).to.equal(1);
                expect(dataCidQueryReply.entries[0].recordId).to.equal(writeRecord.message.recordId);
            }));
            it('should be able to query with `dataSize` filter (half-open range)', () => __awaiter(this, void 0, void 0, function* () {
                var _2, _3, _4, _5, _6, _7, _8, _9;
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(10) });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(50) });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(100) });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing gt
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 10 } },
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_2 = reply1.entries) === null || _2 === void 0 ? void 0 : _2.length).to.equal(2);
                expect((_3 = reply1.entries) === null || _3 === void 0 ? void 0 : _3.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
                // testing lt
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { lt: 100 } },
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_4 = reply2.entries) === null || _4 === void 0 ? void 0 : _4.length).to.equal(2);
                expect((_5 = reply2.entries) === null || _5 === void 0 ? void 0 : _5.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes)
                ]);
                // testing gte
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10 } },
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_6 = reply3.entries) === null || _6 === void 0 ? void 0 : _6.length).to.equal(3);
                expect((_7 = reply3.entries) === null || _7 === void 0 ? void 0 : _7.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
                // testing lte
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { lte: 100 } },
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_8 = reply4.entries) === null || _8 === void 0 ? void 0 : _8.length).to.equal(3);
                expect((_9 = reply4.entries) === null || _9 === void 0 ? void 0 : _9.map((entry) => entry.encodedData)).to.have.members([
                    Encoder.bytesToBase64Url(write1.dataBytes),
                    Encoder.bytesToBase64Url(write2.dataBytes),
                    Encoder.bytesToBase64Url(write3.dataBytes)
                ]);
            }));
            it('should be able to range query with `dataSize` filter (open & closed range)', () => __awaiter(this, void 0, void 0, function* () {
                var _10, _11, _12, _13, _14, _15;
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(10) });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(50) });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, data: TestDataGenerator.randomBytes(100) });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing range using gt & lt
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 10, lt: 60 } },
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_10 = reply1.entries) === null || _10 === void 0 ? void 0 : _10.length).to.equal(1);
                expect(reply1.entries[0].recordId).to.equal(write2.message.recordId);
                // testing range using gte & lt
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10, lt: 60 } },
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_11 = reply2.entries) === null || _11 === void 0 ? void 0 : _11.length).to.equal(2);
                const reply2RecordIds = (_12 = reply2.entries) === null || _12 === void 0 ? void 0 : _12.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing range using gt & lte
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gt: 50, lte: 100 } },
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_13 = reply3.entries) === null || _13 === void 0 ? void 0 : _13.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing range using gte & lte
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dataSize: { gte: 10, lte: 100 } },
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_14 = reply4.entries) === null || _14 === void 0 ? void 0 : _14.length).to.equal(3);
                const reply4RecordIds = (_15 = reply4.entries) === null || _15 === void 0 ? void 0 : _15.map(e => e.recordId);
                expect(reply4RecordIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
            }));
            it('should be able to range query by `dateCreated`', () => __awaiter(this, void 0, void 0, function* () {
                var _16, _17, _18, _19;
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively,
                // only the first 2 records share the same schema
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022 });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023 });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_16 = reply1.entries) === null || _16 === void 0 ? void 0 : _16.length).to.equal(2);
                expect(reply1.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                expect(reply1.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_17 = reply2.entries) === null || _17 === void 0 ? void 0 : _17.length).to.equal(2);
                expect(reply2.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write1.dataBytes));
                expect(reply2.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_18 = reply3.entries) === null || _18 === void 0 ? void 0 : _18.length).to.equal(1);
                expect(reply3.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_19 = reply4.entries) === null || _19 === void 0 ? void 0 : _19.length).to.equal(1);
                expect(reply4.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should not return records that were published and then unpublished ', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: 3 records authored by alice, published on first of 2021, 2022, and 2023 respectively
                // then the records are unpublished and tested to not return when filtering for published records
                var _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2021, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2022, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2023, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // confirm range before un-publishing.
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const ownerRangeQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, ownerRangeQuery.message);
                expect((_20 = reply1.entries) === null || _20 === void 0 ? void 0 : _20.length).to.equal(2);
                const reply1RecordIds = (_21 = reply1.entries) === null || _21 === void 0 ? void 0 : _21.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // confirm published true filter before un-publishing
                const ownerPublishedQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { published: true },
                    dateSort: DateSort.CreatedAscending
                });
                let ownerPublishedReply = yield dwn.processMessage(alice.did, ownerPublishedQuery.message);
                expect(ownerPublishedReply.status.code).to.equal(200);
                expect((_22 = ownerPublishedReply.entries) === null || _22 === void 0 ? void 0 : _22.length).to.equal(3);
                const ownerPublishedIds = (_23 = ownerPublishedReply.entries) === null || _23 === void 0 ? void 0 : _23.map(e => e.recordId);
                expect(ownerPublishedIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
                // confirm for anonymous query before un-publishing
                const anonymousRangeQuery = yield RecordsQuery.create({
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                let anonymousRangeReply = yield dwn.processMessage(alice.did, anonymousRangeQuery.message);
                expect(anonymousRangeReply.status.code).to.equal(200);
                expect((_24 = anonymousRangeReply.entries) === null || _24 === void 0 ? void 0 : _24.length).to.equal(2);
                const anonymousReplyIds = (_25 = anonymousRangeReply.entries) === null || _25 === void 0 ? void 0 : _25.map(e => e.recordId);
                expect(anonymousReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // confirm anonymous published true filter before un-publishing
                const anonymousPublishedQuery = yield RecordsQuery.create({
                    filter: { published: true },
                    dateSort: DateSort.CreatedAscending
                });
                let anonymousPublishedReply = yield dwn.processMessage(alice.did, anonymousPublishedQuery.message);
                expect(anonymousPublishedReply.status.code).to.equal(200);
                expect((_26 = anonymousPublishedReply.entries) === null || _26 === void 0 ? void 0 : _26.length).to.equal(3);
                const anonymousPublishedIds = (_27 = anonymousPublishedReply.entries) === null || _27 === void 0 ? void 0 : _27.map(e => e.recordId);
                expect(anonymousPublishedIds).to.have.members([write1.message.recordId, write2.message.recordId, write3.message.recordId]);
                //unpublish records
                const write1Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write1.message,
                    published: false
                });
                const write2Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write2.message,
                    published: false
                });
                const write3Unpublish = yield RecordsWrite.createFrom({
                    signer: Jws.createSigner(alice),
                    recordsWriteMessage: write3.message,
                    published: false
                });
                const unpublished1Response = yield dwn.processMessage(alice.did, write1Unpublish.message);
                const unpublished2Response = yield dwn.processMessage(alice.did, write2Unpublish.message);
                const unpublished3Response = yield dwn.processMessage(alice.did, write3Unpublish.message);
                expect(unpublished1Response.status.code).to.equal(202);
                expect(unpublished2Response.status.code).to.equal(202);
                expect(unpublished3Response.status.code).to.equal(202);
                // try datePublished range query as an anonymous user after unpublish
                anonymousRangeReply = yield dwn.processMessage(alice.did, anonymousRangeQuery.message);
                expect(anonymousRangeReply.status.code).to.equal(200);
                expect((_28 = anonymousRangeReply.entries) === null || _28 === void 0 ? void 0 : _28.length).to.equal(0);
                // try published:true filter as an anonymous user after unpublish
                anonymousPublishedReply = yield dwn.processMessage(alice.did, anonymousPublishedQuery.message);
                expect(anonymousPublishedReply.status.code).to.equal(200);
                expect((_29 = anonymousPublishedReply.entries) === null || _29 === void 0 ? void 0 : _29.length).to.equal(0);
                // try datePublished range query as owner after unpublish
                const ownerRangeReply = yield dwn.processMessage(alice.did, ownerRangeQuery.message);
                expect(ownerRangeReply.status.code).to.equal(200);
                expect((_30 = ownerRangeReply.entries) === null || _30 === void 0 ? void 0 : _30.length).to.equal(0);
                // try published:true filter as owner after unpublish
                ownerPublishedReply = yield dwn.processMessage(alice.did, ownerPublishedQuery.message);
                expect(ownerPublishedReply.status.code).to.equal(200);
                expect((_31 = ownerPublishedReply.entries) === null || _31 === void 0 ? void 0 : _31.length).to.equal(0);
            }));
            it('should be able to range query by `datePublished`', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: 3 records authored by alice, published on first of 2021, 2022, and 2023 respectively
                // all 3 records are created on first of 2020
                var _32, _33, _34, _35, _36, _37, _38, _39, _40, _41;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2021, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2022, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, published: true, dateCreated: firstDayOf2020, datePublished: firstDayOf2023, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_32 = reply1.entries) === null || _32 === void 0 ? void 0 : _32.length).to.equal(2);
                const reply1RecordIds = (_33 = reply1.entries) === null || _33 === void 0 ? void 0 : _33.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_34 = reply2.entries) === null || _34 === void 0 ? void 0 : _34.length).to.equal(2);
                const reply2RecordIds = (_35 = reply2.entries) === null || _35 === void 0 ? void 0 : _35.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_36 = reply3.entries) === null || _36 === void 0 ? void 0 : _36.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_37 = reply4.entries) === null || _37 === void 0 ? void 0 : _37.length).to.equal(1);
                expect(reply4.entries[0].recordId).to.equal(write2.message.recordId);
                // check for anonymous range query
                const anonymousRecordQuery = yield RecordsQuery.create({
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const anonymousReply = yield dwn.processMessage(alice.did, anonymousRecordQuery.message);
                expect(anonymousReply.status.code).to.equal(200);
                expect((_38 = anonymousReply.entries) === null || _38 === void 0 ? void 0 : _38.length).to.equal(2);
                const anonymousReplyIds = (_39 = anonymousReply.entries) === null || _39 === void 0 ? void 0 : _39.map(e => e.recordId);
                expect(anonymousReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // check for non owner range query
                const bob = yield DidKeyResolver.generate();
                const nonOwnerRange = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { datePublished: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const nonOwnerReply = yield dwn.processMessage(alice.did, nonOwnerRange.message);
                expect(nonOwnerReply.status.code).to.equal(200);
                expect((_40 = nonOwnerReply.entries) === null || _40 === void 0 ? void 0 : _40.length).to.equal(2);
                const nonOwnerReplyIds = (_41 = nonOwnerReply.entries) === null || _41 === void 0 ? void 0 : _41.map(e => e.recordId);
                expect(nonOwnerReplyIds).to.have.members([write2.message.recordId, write3.message.recordId]);
            }));
            it('should be able to range query by `dateUpdated`', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: alice creates 3 records on the first day of 2020.
                // alice then updates these records to published on first of 2021, 2022, and 2023 respectively
                // this should update the messageTimestamp on the respective messages
                var _42, _43, _44, _45, _46, _47;
                const firstDayOf2020 = Time.createTimestamp({ year: 2020, month: 1, day: 1 });
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2020, messageTimestamp: firstDayOf2020
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // update to published
                const write1Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write1.message,
                    published: true,
                    messageTimestamp: firstDayOf2021,
                    datePublished: firstDayOf2021,
                    signer: Jws.createSigner(alice)
                });
                const write2Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write2.message,
                    published: true,
                    messageTimestamp: firstDayOf2022,
                    datePublished: firstDayOf2022,
                    signer: Jws.createSigner(alice)
                });
                const write3Update = yield RecordsWrite.createFrom({
                    recordsWriteMessage: write3.message,
                    published: true,
                    messageTimestamp: firstDayOf2023,
                    datePublished: firstDayOf2023,
                    signer: Jws.createSigner(alice)
                });
                const writeReplyUpdate1 = yield dwn.processMessage(alice.did, write1Update.message);
                const writeReplyUpdate2 = yield dwn.processMessage(alice.did, write2Update.message);
                const writeReplyUpdate3 = yield dwn.processMessage(alice.did, write3Update.message);
                expect(writeReplyUpdate1.status.code).to.equal(202);
                expect(writeReplyUpdate2.status.code).to.equal(202);
                expect(writeReplyUpdate3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_42 = reply1.entries) === null || _42 === void 0 ? void 0 : _42.length).to.equal(2);
                const reply1RecordIds = (_43 = reply1.entries) === null || _43 === void 0 ? void 0 : _43.map(e => e.recordId);
                expect(reply1RecordIds).to.have.members([write2.message.recordId, write3.message.recordId]);
                // testing `to` range
                const lastDayOf2022 = Time.createTimestamp({ year: 2022, month: 12, day: 31 });
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_44 = reply2.entries) === null || _44 === void 0 ? void 0 : _44.length).to.equal(2);
                const reply2RecordIds = (_45 = reply2.entries) === null || _45 === void 0 ? void 0 : _45.map(e => e.recordId);
                expect(reply2RecordIds).to.have.members([write1.message.recordId, write2.message.recordId]);
                // testing `from` and `to` range
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_46 = reply3.entries) === null || _46 === void 0 ? void 0 : _46.length).to.equal(1);
                expect(reply3.entries[0].recordId).to.equal(write3.message.recordId);
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateUpdated: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_47 = reply4.entries) === null || _47 === void 0 ? void 0 : _47.length).to.equal(1);
                expect(reply4.entries[0].recordId).to.equal(write2.message.recordId);
            }));
            it('should be able use range and exact match queries at the same time', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively,
                // only the first 2 records share the same schema
                var _48;
                const firstDayOf2021 = Time.createTimestamp({ year: 2021, month: 1, day: 1 });
                const firstDayOf2022 = Time.createTimestamp({ year: 2022, month: 1, day: 1 });
                const firstDayOf2023 = Time.createTimestamp({ year: 2023, month: 1, day: 1 });
                const alice = yield DidKeyResolver.generate();
                const schema = '2021And2022Schema';
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021, schema
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022, schema
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing range criterion with another exact match
                const lastDayOf2021 = Time.createTimestamp({ year: 2021, month: 12, day: 31 });
                const lastDayOf2023 = Time.createTimestamp({ year: 2023, month: 12, day: 31 });
                const recordsQuery5 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        schema,
                        dateCreated: { from: lastDayOf2021, to: lastDayOf2023 } // by itself selects the last 2 records
                    },
                    dateSort: DateSort.CreatedAscending
                });
                const reply = yield dwn.processMessage(alice.did, recordsQuery5.message);
                expect((_48 = reply.entries) === null || _48 === void 0 ? void 0 : _48.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should include `authorization` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                var _49;
                const alice = yield TestDataGenerator.generatePersona();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_49 = queryReply.entries) === null || _49 === void 0 ? void 0 : _49.length).to.equal(1);
                expect(queryReply.entries[0].authorization).to.deep.equal(message.authorization);
            }));
            it('should include `attestation` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: alice and bob attest to a message alice authored
                var _50, _51, _52;
                const alice = yield DidKeyResolver.generate();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_50 = queryReply.entries) === null || _50 === void 0 ? void 0 : _50.length).to.equal(1);
                const recordsWriteMessage = queryReply.entries[0];
                expect((_52 = (_51 = recordsWriteMessage.attestation) === null || _51 === void 0 ? void 0 : _51.signatures) === null || _52 === void 0 ? void 0 : _52.length).to.equal(1);
            }));
            it('should omit records that are not published if `dateSort` sorts on `datePublished`', () => __awaiter(this, void 0, void 0, function* () {
                var _53, _54;
                // setup: 2 records in DWN: 1 published and 1 unpublished
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const publishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, published: true
                });
                const unpublishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema
                });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWriteData.message, publishedWriteData.dataStream);
                const unpublishedWriteReply = yield dwn.processMessage(alice.did, unpublishedWriteData.message, unpublishedWriteData.dataStream);
                expect(publishedWriteReply.status.code).to.equal(202);
                expect(unpublishedWriteReply.status.code).to.equal(202);
                // test published date ascending sort does not include any records that is not published
                const publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                const publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect((_53 = publishedAscendingQueryReply.entries) === null || _53 === void 0 ? void 0 : _53.length).to.equal(1);
                expect(publishedAscendingQueryReply.entries[0].descriptor['datePublished']).to.equal(publishedWriteData.message.descriptor.datePublished);
                // test published date scending sort does not include any records that is not published
                const publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                const publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect((_54 = publishedDescendingQueryReply.entries) === null || _54 === void 0 ? void 0 : _54.length).to.equal(1);
                expect(publishedDescendingQueryReply.entries[0].descriptor['datePublished']).to.equal(publishedWriteData.message.descriptor.datePublished);
            }));
            it('should sort records if `dateSort` is specified', () => __awaiter(this, void 0, void 0, function* () {
                var _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66;
                // insert three messages into DB
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data, intentionally out of order
                const writeReply2 = yield dwn.processMessage(alice.did, write2Data.message, write2Data.dataStream);
                const writeReply1 = yield dwn.processMessage(alice.did, write1Data.message, write1Data.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3Data.message, write3Data.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // createdAscending test
                const createdAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedAscending,
                    filter: { schema }
                });
                const createdAscendingQueryReply = yield dwn.processMessage(alice.did, createdAscendingQueryData.message);
                expect((_55 = createdAscendingQueryReply.entries) === null || _55 === void 0 ? void 0 : _55[0].descriptor['dateCreated']).to.equal(write1Data.message.descriptor.dateCreated);
                expect((_56 = createdAscendingQueryReply.entries) === null || _56 === void 0 ? void 0 : _56[1].descriptor['dateCreated']).to.equal(write2Data.message.descriptor.dateCreated);
                expect((_57 = createdAscendingQueryReply.entries) === null || _57 === void 0 ? void 0 : _57[2].descriptor['dateCreated']).to.equal(write3Data.message.descriptor.dateCreated);
                // createdDescending test
                const createdDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedDescending,
                    filter: { schema }
                });
                const createdDescendingQueryReply = yield dwn.processMessage(alice.did, createdDescendingQueryData.message);
                expect((_58 = createdDescendingQueryReply.entries) === null || _58 === void 0 ? void 0 : _58[0].descriptor['dateCreated']).to.equal(write3Data.message.descriptor.dateCreated);
                expect((_59 = createdDescendingQueryReply.entries) === null || _59 === void 0 ? void 0 : _59[1].descriptor['dateCreated']).to.equal(write2Data.message.descriptor.dateCreated);
                expect((_60 = createdDescendingQueryReply.entries) === null || _60 === void 0 ? void 0 : _60[2].descriptor['dateCreated']).to.equal(write1Data.message.descriptor.dateCreated);
                // publishedAscending test
                const publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                const publishedAscendingQueryReply = yield dwn.processMessage(alice.did, publishedAscendingQueryData.message);
                expect((_61 = publishedAscendingQueryReply.entries) === null || _61 === void 0 ? void 0 : _61[0].descriptor['datePublished']).to.equal(write1Data.message.descriptor.datePublished);
                expect((_62 = publishedAscendingQueryReply.entries) === null || _62 === void 0 ? void 0 : _62[1].descriptor['datePublished']).to.equal(write2Data.message.descriptor.datePublished);
                expect((_63 = publishedAscendingQueryReply.entries) === null || _63 === void 0 ? void 0 : _63[2].descriptor['datePublished']).to.equal(write3Data.message.descriptor.datePublished);
                // publishedDescending test
                const publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                const publishedDescendingQueryReply = yield dwn.processMessage(alice.did, publishedDescendingQueryData.message);
                expect((_64 = publishedDescendingQueryReply.entries) === null || _64 === void 0 ? void 0 : _64[0].descriptor['datePublished']).to.equal(write3Data.message.descriptor.datePublished);
                expect((_65 = publishedDescendingQueryReply.entries) === null || _65 === void 0 ? void 0 : _65[1].descriptor['datePublished']).to.equal(write2Data.message.descriptor.datePublished);
                expect((_66 = publishedDescendingQueryReply.entries) === null || _66 === void 0 ? void 0 : _66[2].descriptor['datePublished']).to.equal(write1Data.message.descriptor.datePublished);
            }));
            it('should tiebreak using `messageCid` when sorting encounters identical values', () => __awaiter(this, void 0, void 0, function* () {
                var _67;
                // setup: 3 messages with the same `dateCreated` value
                const dateCreated = Time.getCurrentTimestamp();
                const messageTimestamp = dateCreated;
                const alice = yield DidKeyResolver.generate();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                // sort the messages in lexicographical order against `messageCid`
                const [oldestWrite, middleWrite, newestWrite] = yield ArrayUtility.asyncSort([write1Data, write2Data, write3Data], (messageDataA, messageDataB) => { return Message.compareCid(messageDataA.message, messageDataB.message); });
                // intentionally write the RecordsWrite of out lexicographical order to avoid the test query below accidentally having the correct order
                const reply2 = yield dwn.processMessage(alice.did, middleWrite.message, middleWrite.dataStream);
                expect(reply2.status.code).to.equal(202);
                const reply3 = yield dwn.processMessage(alice.did, newestWrite.message, newestWrite.dataStream);
                expect(reply3.status.code).to.equal(202);
                const reply1 = yield dwn.processMessage(alice.did, oldestWrite.message, oldestWrite.dataStream);
                expect(reply1.status.code).to.equal(202);
                const queryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending
                });
                const queryReply = yield dwn.processMessage(alice.did, queryMessageData.message);
                // verify that messages returned are sorted/tiebreak by `messageCid`
                expect(queryReply.status.code).to.equal(200);
                expect((_67 = queryReply.entries) === null || _67 === void 0 ? void 0 : _67.length).to.equal(3);
                expect(queryReply.entries[0].recordId).to.equal(oldestWrite.message.recordId);
                expect(queryReply.entries[1].recordId).to.equal(middleWrite.message.recordId);
                expect(queryReply.entries[2].recordId).to.equal(newestWrite.message.recordId);
            }));
            it('should paginate records if pagination is provided', () => __awaiter(this, void 0, void 0, function* () {
                var _68;
                const alice = yield DidKeyResolver.generate();
                const messages = yield Promise.all(Array(12).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, message.dataStream);
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const results = [];
                let cursor;
                while (true) {
                    const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: {
                            schema: 'https://schema'
                        },
                        pagination: {
                            limit: limit,
                            cursor,
                        },
                    });
                    const pageReply = yield dwn.processMessage(alice.did, pageQuery.message);
                    expect(pageReply.status.code).to.equal(200);
                    cursor = pageReply.cursor;
                    expect((_68 = pageReply.entries) === null || _68 === void 0 ? void 0 : _68.length).to.be.lte(limit);
                    results.push(...pageReply.entries);
                    if (cursor === undefined) {
                        break;
                    }
                }
                expect(results.length).to.equal(messages.length);
                expect(messages.every(({ message }) => results.map(e => e.recordId).includes(message.recordId)));
            }));
            it('cursor should match the messageCid of the last entry in the returned query', () => __awaiter(this, void 0, void 0, function* () {
                var _69;
                const alice = yield DidKeyResolver.generate();
                const messages = yield Promise.all(Array(6).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, message.dataStream);
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        schema: 'https://schema'
                    },
                    pagination: {
                        limit: limit,
                    },
                });
                const pageReply = yield dwn.processMessage(alice.did, pageQuery.message);
                expect(pageReply.status.code).to.equal(200);
                expect((_69 = pageReply.entries) === null || _69 === void 0 ? void 0 : _69.length).to.be.lte(limit);
                expect(pageReply.cursor).to.exist;
                const lastMessageWithAuthorization = messages.find(m => { var _a; return m.message.recordId === ((_a = pageReply.entries) === null || _a === void 0 ? void 0 : _a.at(-1).recordId); });
                const messageCid = yield Message.getCid(lastMessageWithAuthorization.message);
                expect(pageReply.cursor).to.equal(messageCid);
            }));
            it('should allow an anonymous unauthenticated query to return published records', () => __awaiter(this, void 0, void 0, function* () {
                var _70, _71;
                // write 2 records into Alice's DB:
                // 1st is unpublished
                // 2nd is published
                const alice = yield DidKeyResolver.generate();
                const record1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema1', published: false });
                const record2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema2', published: true });
                const recordsWrite1Reply = yield dwn.processMessage(alice.did, record1Data.message, record1Data.dataStream);
                expect(recordsWrite1Reply.status.code).to.equal(202);
                const recordsWrite2Reply = yield dwn.processMessage(alice.did, record2Data.message, record2Data.dataStream);
                expect(recordsWrite2Reply.status.code).to.equal(202);
                // test correctness for anonymous query
                const anonymousQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    anonymous: true,
                    filter: { dateCreated: { from: '2000-01-01T10:20:30.123456Z' } }
                });
                // sanity check
                expect(anonymousQueryMessageData.message.authorization).to.not.exist;
                const replyToQuery = yield dwn.processMessage(alice.did, anonymousQueryMessageData.message);
                expect(replyToQuery.status.code).to.equal(200);
                expect((_70 = replyToQuery.entries) === null || _70 === void 0 ? void 0 : _70.length).to.equal(1);
                expect(replyToQuery.entries[0].descriptor.schema).to.equal('https://schema2');
                // explicitly for published records
                const anonymousQueryPublished = yield TestDataGenerator.generateRecordsQuery({
                    anonymous: true,
                    filter: { dateCreated: { from: '2000-01-01T10:20:30.123456Z' }, published: true }
                });
                // sanity check
                expect(anonymousQueryPublished.message.authorization).to.not.exist;
                // should return the published records
                const publishedReply = yield dwn.processMessage(alice.did, anonymousQueryPublished.message);
                expect(publishedReply.status.code).to.equal(200);
                expect((_71 = publishedReply.entries) === null || _71 === void 0 ? void 0 : _71.length).to.equal(1);
                expect(publishedReply.entries[0].descriptor.schema).to.equal('https://schema2');
            }));
            it('should only return published records and unpublished records that is meant for author', () => __awaiter(this, void 0, void 0, function* () {
                // write 4 records into Alice's DB:
                // 1st is unpublished authored by Alice
                // 2nd is also unpublished authored by Alice, but is meant for (has recipient as) Bob
                // 3rd is also unpublished but is authored by Bob
                // 4th is published
                // 5th is published, authored by Alice and is meant for Carol as recipient;
                var _72, _73, _74, _75, _76, _77, _78, _79, _80;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const carol = yield DidKeyResolver.generate();
                const schema = 'schema1';
                const record1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('1') });
                const record2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, protocol: 'protocol', protocolPath: 'path', recipient: bob.did, data: Encoder.stringToBytes('2') });
                const record3Data = yield TestDataGenerator.generateRecordsWrite({ author: bob, schema, protocol: 'protocol', protocolPath: 'path', recipient: alice.did, data: Encoder.stringToBytes('3') });
                const record4Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('4'), published: true });
                const record5Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('5'), published: true, recipient: carol.did });
                // directly inserting data to datastore so that we don't have to setup to grant Bob permission to write to Alice's DWN
                const recordsWriteHandler = new RecordsWriteHandler(didResolver, messageStore, dataStore, eventLog);
                const additionalIndexes1 = yield record1Data.recordsWrite.constructRecordsWriteIndexes(true);
                record1Data.message = yield recordsWriteHandler.processEncodedData(record1Data.message, record1Data.dataStream);
                yield messageStore.put(alice.did, record1Data.message, additionalIndexes1);
                yield eventLog.append(alice.did, yield Message.getCid(record1Data.message));
                const additionalIndexes2 = yield record2Data.recordsWrite.constructRecordsWriteIndexes(true);
                record2Data.message = yield recordsWriteHandler.processEncodedData(record2Data.message, record2Data.dataStream);
                yield messageStore.put(alice.did, record2Data.message, additionalIndexes2);
                yield eventLog.append(alice.did, yield Message.getCid(record2Data.message));
                const additionalIndexes3 = yield record3Data.recordsWrite.constructRecordsWriteIndexes(true);
                record3Data.message = yield recordsWriteHandler.processEncodedData(record3Data.message, record3Data.dataStream);
                yield messageStore.put(alice.did, record3Data.message, additionalIndexes3);
                yield eventLog.append(alice.did, yield Message.getCid(record3Data.message));
                const additionalIndexes4 = yield record4Data.recordsWrite.constructRecordsWriteIndexes(true);
                record4Data.message = yield recordsWriteHandler.processEncodedData(record4Data.message, record4Data.dataStream);
                yield messageStore.put(alice.did, record4Data.message, additionalIndexes4);
                yield eventLog.append(alice.did, yield Message.getCid(record4Data.message));
                const additionalIndexes5 = yield record5Data.recordsWrite.constructRecordsWriteIndexes(true);
                record5Data.message = yield recordsWriteHandler.processEncodedData(record5Data.message, record5Data.dataStream);
                yield messageStore.put(alice.did, record5Data.message, additionalIndexes5);
                yield eventLog.append(alice.did, yield Message.getCid(record5Data.message));
                // test correctness for Bob's query
                const bobQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema }
                });
                const replyToBob = yield dwn.processMessage(alice.did, bobQueryMessageData.message);
                expect(replyToBob.status.code).to.equal(200);
                expect((_72 = replyToBob.entries) === null || _72 === void 0 ? void 0 : _72.length).to.equal(4); // expect 4 records
                const privateRecordsForBob = (_73 = replyToBob.entries) === null || _73 === void 0 ? void 0 : _73.filter(message => message.encodedData === Encoder.stringToBase64Url('2'));
                const privateRecordsFromBob = (_74 = replyToBob.entries) === null || _74 === void 0 ? void 0 : _74.filter(message => message.encodedData === Encoder.stringToBase64Url('3'));
                const publicRecords = (_75 = replyToBob.entries) === null || _75 === void 0 ? void 0 : _75.filter(message => message.encodedData === Encoder.stringToBase64Url('4') || message.encodedData === Encoder.stringToBase64Url('5'));
                expect(privateRecordsForBob.length).to.equal(1);
                expect(privateRecordsFromBob.length).to.equal(1);
                expect(publicRecords.length).to.equal(2);
                // check for explicitly published:false records for Bob
                const bobQueryPublishedFalse = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema, published: false }
                });
                const unpublishedBobReply = yield dwn.processMessage(alice.did, bobQueryPublishedFalse.message);
                expect(unpublishedBobReply.status.code).to.equal(200);
                expect((_76 = unpublishedBobReply.entries) === null || _76 === void 0 ? void 0 : _76.length).to.equal(2);
                const unpublishedBobRecordIds = (_77 = unpublishedBobReply.entries) === null || _77 === void 0 ? void 0 : _77.map(e => e.recordId);
                expect(unpublishedBobRecordIds).to.have.members([record2Data.message.recordId, record3Data.message.recordId]);
                // test correctness for Alice's query
                const aliceQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                const replyToAliceQuery = yield dwn.processMessage(alice.did, aliceQueryMessageData.message);
                expect(replyToAliceQuery.status.code).to.equal(200);
                expect((_78 = replyToAliceQuery.entries) === null || _78 === void 0 ? void 0 : _78.length).to.equal(5); // expect all 5 records
                // filter for public records with carol as recipient
                const bobQueryCarolMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema, recipient: carol.did }
                });
                const replyToBobCarolQuery = yield dwn.processMessage(alice.did, bobQueryCarolMessageData.message);
                expect(replyToBobCarolQuery.status.code).to.equal(200);
                expect((_79 = replyToBobCarolQuery.entries) === null || _79 === void 0 ? void 0 : _79.length).to.equal(1);
                expect(replyToBobCarolQuery.entries[0].encodedData).to.equal(Encoder.stringToBase64Url('5'));
                // filter for explicit unpublished public records with carol as recipient, should not return any.
                const bobQueryCarolMessageDataUnpublished = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema, recipient: carol.did, published: false }
                });
                const replyToBobCarolUnpublishedQuery = yield dwn.processMessage(alice.did, bobQueryCarolMessageDataUnpublished.message);
                expect(replyToBobCarolUnpublishedQuery.status.code).to.equal(200);
                expect((_80 = replyToBobCarolUnpublishedQuery.entries) === null || _80 === void 0 ? void 0 : _80.length).to.equal(0);
            }));
            it('should paginate correctly for fetchRecordsAsNonOwner()', () => __awaiter(this, void 0, void 0, function* () {
                var _81, e_1, _82, _83;
                var _84, _85, _86, _87, _88;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'schema1';
                // published messages bob
                const bobPublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // published messages alice
                const alicePublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // alice non public messages
                const aliceMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // bob non public messages
                const bobMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // non public messages intended for bob
                const aliceMessagesForBobPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), recipient: bob.did,
                }));
                const messagePromises = [
                    ...bobPublishedPromise,
                    ...aliceMessagesPromise,
                    ...bobMessagesPromise,
                    ...alicePublishedPromise,
                    ...aliceMessagesForBobPromise,
                ];
                const recordsWriteHandler = new RecordsWriteHandler(didResolver, messageStore, dataStore, eventLog);
                const messages = [];
                try {
                    for (var _89 = true, messagePromises_1 = __asyncValues(messagePromises), messagePromises_1_1; messagePromises_1_1 = yield messagePromises_1.next(), _81 = messagePromises_1_1.done, !_81; _89 = true) {
                        _83 = messagePromises_1_1.value;
                        _89 = false;
                        const { recordsWrite, message, dataStream } = _83;
                        const indexes = yield recordsWrite.constructRecordsWriteIndexes(true);
                        const processedMessage = yield recordsWriteHandler.processEncodedData(message, dataStream);
                        yield messageStore.put(alice.did, processedMessage, indexes);
                        yield eventLog.append(alice.did, yield Message.getCid(processedMessage));
                        messages.push(processedMessage);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_89 && !_81 && (_82 = messagePromises_1.return)) yield _82.call(messagePromises_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // fetch all from alice for sanity, alice should get all of the records
                // page1 alice
                const aliceQueryMessageDataPage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                const sortedMessages = yield MessageStoreLevel.sortMessages(messages, { dateCreated: SortOrder.Ascending });
                let results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage1.message);
                expect(results.status.code).to.equal(200);
                expect((_84 = results.entries) === null || _84 === void 0 ? void 0 : _84.length).to.equal(10, 'alice page 1');
                const page1PaginationLastMessage = yield Message.getCid(sortedMessages.at(9)); // get messageCid from message with authorization.
                expect(results.cursor).to.equal(page1PaginationLastMessage, 'alice page 1');
                // page2 alice
                const aliceQueryMessageDataPage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage2.message);
                expect(results.status.code).to.equal(200);
                expect((_85 = results.entries) === null || _85 === void 0 ? void 0 : _85.length).to.equal(10, 'alice page 2');
                const page2PaginationLastMessage = yield Message.getCid(sortedMessages.at(19)); // get messageCid from message with authorization.
                expect(results.cursor).to.equal(page2PaginationLastMessage, 'alice page 2');
                // page3 alice
                const aliceQueryMessageDataPage3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage3.message);
                expect(results.status.code).to.equal(200);
                expect((_86 = results.entries) === null || _86 === void 0 ? void 0 : _86.length).to.equal(5, 'alice page 3');
                expect(results.cursor).to.not.exist;
                const bobs = (m) => {
                    return m.descriptor.recipient === bob.did || m.descriptor.published === true || Message.getSigner(m) === bob.did;
                };
                // all records from alice have been validated
                // now we prepare to test records that only bob should get
                const bobSorted = sortedMessages.filter(m => bobs(m));
                const bobRetrieved = [];
                const bobQueryMessagePage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                results = yield dwn.processMessage(alice.did, bobQueryMessagePage1.message);
                expect(results.status.code).to.equal(200);
                expect((_87 = results.entries) === null || _87 === void 0 ? void 0 : _87.length).to.equal(10, 'bob page 1');
                const page1BobPaginationLastMessage = yield Message.getCid(bobSorted.at(9));
                expect(results.cursor).to.equal(page1BobPaginationLastMessage, 'bob page 1');
                bobRetrieved.push(...results.entries);
                const bobQueryMessagePage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, cursor: results.cursor },
                });
                results = yield dwn.processMessage(alice.did, bobQueryMessagePage2.message);
                expect(results.status.code).to.equal(200);
                expect((_88 = results.entries) === null || _88 === void 0 ? void 0 : _88.length).to.equal(10, 'bob page 2');
                expect(results.cursor).to.not.exist;
                bobRetrieved.push(...results.entries);
                const compareRecordId = (a, b) => {
                    return a.recordId === b.recordId;
                };
                expect(bobSorted.every((m, i) => compareRecordId(bobRetrieved.at(i), m)));
            }));
            // https://github.com/TBD54566975/dwn-sdk-js/issues/170
            it('#170 - should treat records with `published` explicitly set to `false` as unpublished', () => __awaiter(this, void 0, void 0, function* () {
                var _90, _91;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'schema1';
                const unpublishedRecordsWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('1'), published: false } // explicitly setting `published` to `false`
                );
                const result1 = yield dwn.processMessage(alice.did, unpublishedRecordsWrite.message, unpublishedRecordsWrite.dataStream);
                expect(result1.status.code).to.equal(202);
                // alice should be able to see the unpublished record
                const queryByAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                const replyToAliceQuery = yield dwn.processMessage(alice.did, queryByAlice.message);
                expect(replyToAliceQuery.status.code).to.equal(200);
                expect((_90 = replyToAliceQuery.entries) === null || _90 === void 0 ? void 0 : _90.length).to.equal(1);
                // actual test: bob should not be able to see unpublished record
                const queryByBob = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema }
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, queryByBob.message);
                expect(replyToBobQuery.status.code).to.equal(200);
                expect((_91 = replyToBobQuery.entries) === null || _91 === void 0 ? void 0 : _91.length).to.equal(0);
            }));
            it('should allow DWN owner to use `recipient` as a filter in queries', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const bobQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { recipient: bob.did } // alice as the DWN owner querying bob's records
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, bobQueryMessageData.message);
                expect(replyToBobQuery.status.code).to.equal(200);
            }));
            it('should not fetch entries across tenants', () => __awaiter(this, void 0, void 0, function* () {
                var _92;
                // insert three messages into DB, two with matching schema
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'myAwesomeSchema';
                const recordsWriteMessage1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema });
                const recordsWriteMessage2Data = yield TestDataGenerator.generateRecordsWrite({ author: bob, schema });
                const aliceQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                // insert data into 2 different tenants
                yield dwn.processMessage(alice.did, recordsWriteMessage1Data.message, recordsWriteMessage1Data.dataStream);
                yield dwn.processMessage(bob.did, recordsWriteMessage2Data.message, recordsWriteMessage2Data.dataStream);
                const reply = yield dwn.processMessage(alice.did, aliceQueryMessageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_92 = reply.entries) === null || _92 === void 0 ? void 0 : _92.length).to.equal(1);
            }));
            it('should return 400 if protocol is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // query for non-normalized protocol
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { protocol: 'example.com/' },
                });
                // overwrite protocol because #create auto-normalizes protocol
                recordsQuery.message.descriptor.filter.protocol = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorization({
                    descriptor: recordsQuery.message.descriptor,
                    signer: Jws.createSigner(alice)
                });
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlProtocolNotNormalized);
            }));
            it('should return 400 if schema is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // query for non-normalized schema
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: 'example.com/' },
                });
                // overwrite schema because #create auto-normalizes schema
                recordsQuery.message.descriptor.filter.schema = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorization({
                    descriptor: recordsQuery.message.descriptor,
                    signer: Jws.createSigner(alice)
                });
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlSchemaNotNormalized);
            }));
            it('should return 400 if published is set to false and a datePublished range is provided', () => __awaiter(this, void 0, void 0, function* () {
                const fromDatePublished = Time.getCurrentTimestamp();
                const alice = yield DidKeyResolver.generate();
                // set to true so create does not fail
                const recordQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { datePublished: { from: fromDatePublished }, published: true }
                });
                // set to false
                recordQuery.message.descriptor.filter.published = false;
                const queryResponse = yield dwn.processMessage(alice.did, recordQuery.message);
                expect(queryResponse.status.code).to.equal(400);
                expect(queryResponse.status.detail).to.contain('descriptor/filter/published: must be equal to one of the allowed values');
            }));
            it('should return 401 for anonymous queries that filter explicitly for unpublished records', () => __awaiter(this, void 0, void 0, function* () {
                var _93;
                const alice = yield DidKeyResolver.generate();
                // create an unpublished record
                const draftWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'post' });
                const draftWriteReply = yield dwn.processMessage(alice.did, draftWrite.message, draftWrite.dataStream);
                expect(draftWriteReply.status.code).to.equal(202);
                // validate that alice can query
                const unpublishedPostQuery = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { schema: 'post', published: false } });
                const unpublishedPostReply = yield dwn.processMessage(alice.did, unpublishedPostQuery.message);
                expect(unpublishedPostReply.status.code).to.equal(200);
                expect((_93 = unpublishedPostReply.entries) === null || _93 === void 0 ? void 0 : _93.length).to.equal(1);
                expect(unpublishedPostReply.entries[0].recordId).to.equal(draftWrite.message.recordId);
                // anonymous query for unpublished records
                const unpublishedAnonymous = yield RecordsQuery.create({ filter: { schema: 'post', published: false } });
                const anonymousPostReply = yield dwn.processMessage(alice.did, unpublishedAnonymous.message);
                expect(anonymousPostReply.status.code).to.equal(401);
                expect(anonymousPostReply.status.detail).contains('Missing JWS');
            }));
            describe('protocol based queries', () => {
                it('does not try protocol authorization if protocolRole is not invoked', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages. Alice addresses
                    //           only one chat message to Bob. Bob queries by protocol URI without invoking a protocolRole,
                    //           and he is able to receive the message addressed to him.
                    var _a, _b;
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, threadRecord.dataStream);
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes one 'chat' record addressed to Bob
                    const chatRecordForBob = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/chat',
                        published: false,
                        contextId: threadRecord.message.contextId,
                        parentId: threadRecord.message.recordId,
                        data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                    });
                    const chatRecordForBobReply = yield dwn.processMessage(alice.did, chatRecordForBob.message, chatRecordForBob.dataStream);
                    expect(chatRecordForBobReply.status.code).to.equal(202);
                    // Alice writes two 'chat' records NOT addressed to Bob
                    for (let i = 0; i < 2; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            contextId: threadRecord.message.contextId,
                            parentId: threadRecord.message.recordId,
                            data: new TextEncoder().encode('Bob cannot read this'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                    }
                    // Bob queries without invoking any protocolRole
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                        },
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_a = chatQueryReply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
                    expect(chatQueryReply.entries[0].recordId).to.eq(chatRecordForBob.message.recordId);
                    // bob queries without invoking any protocolRole and filters for unpublished records
                    const unpublishedChatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            published: false,
                            protocol: protocolDefinition.protocol,
                        },
                    });
                    const unpublishedChatReply = yield dwn.processMessage(alice.did, unpublishedChatQuery.message);
                    expect(unpublishedChatReply.status.code).to.equal(200);
                    expect((_b = unpublishedChatReply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(1);
                    expect(unpublishedChatReply.entries[0].recordId).to.equal(chatRecordForBob.message.recordId);
                }));
                it('allows $globalRole authorized queries', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages writes a chat message. Bob invokes his
                    //           thread member role in order to query the chat messages.
                    var _c, _d;
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'friend' $globalRole record with Bob as recipient
                    const friendRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'friend',
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const friendRoleReply = yield dwn.processMessage(alice.did, friendRoleRecord.message, friendRoleRecord.dataStream);
                    expect(friendRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_c = chatQueryReply.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(3);
                    expect(chatQueryReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                    // Bob invokes his friendRole along with an explicit filter for unpublished records
                    const unpublishedChatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            published: false,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const unpublishedChatReply = yield dwn.processMessage(alice.did, unpublishedChatQuery.message);
                    expect(unpublishedChatReply.status.code).to.equal(200);
                    expect((_d = unpublishedChatReply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(3);
                    expect(unpublishedChatReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                }));
                it('allows $contextRole authorized queries', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes some chat messages writes a chat message. Bob invokes his
                    //           friend role in order to query the chat message.
                    var _e;
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, threadRecord.dataStream);
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes a 'participant' $contextRole record with Bob as recipient
                    const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/participant',
                        contextId: threadRecord.message.contextId,
                        parentId: threadRecord.message.recordId,
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const participantRoleReply = yield dwn.processMessage(alice.did, participantRoleRecord.message, participantRoleRecord.dataStream);
                    expect(participantRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            contextId: threadRecord.message.contextId,
                            parentId: threadRecord.message.recordId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            contextId: threadRecord.message.contextId,
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(200);
                    expect((_e = chatQueryReply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(3);
                    expect(chatQueryReply.entries.map((record) => record.recordId)).to.have.all.members(chatRecordIds);
                }));
                it('does not execute protocol queries where protocolPath is missing from the filter', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes some chat messages. Bob invokes his $globalRole to query those messages,
                    //           but his query filter does not include protocolPath.
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'friend' $globalRole record with Bob as recipient
                    const friendRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'friend',
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const friendRoleReply = yield dwn.processMessage(alice.did, friendRoleRecord.message, friendRoleRecord.dataStream);
                    expect(friendRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query but does not have `protocolPath` in the filter
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            // protocolPath deliberately omitted
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.equal(400);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.RecordsQueryFilterMissingRequiredProperties);
                }));
                it('does not execute $contextRole authorized queries where contextId is missing from the filter', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes some chat messages and gives Bob a role allowing him to access them. But Bob's filter
                    //           does not contain a contextId so the query fails.
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, threadRecord.dataStream);
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes a 'friend' $globalRole record with Bob as recipient
                    const participantRoleRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        recipient: bob.did,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread/participant',
                        contextId: threadRecord.message.contextId,
                        parentId: threadRecord.message.recordId,
                        data: new TextEncoder().encode('Bob is my friend'),
                    });
                    const participantRoleReply = yield dwn.processMessage(alice.did, participantRoleRecord.message, participantRoleRecord.dataStream);
                    expect(participantRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            contextId: threadRecord.message.contextId,
                            parentId: threadRecord.message.recordId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his thread participant role to query
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            // contextId deliberately omitted
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMissingContextId);
                }));
                it('rejects $globalRole authorized queries if the query author does not have a matching $globalRole', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice creates a thread and writes some chat messages writes a chat message. Bob invokes a
                    //           $globalRole but fails because he does not actually have a role.
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = friendRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                            published: false,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'chat',
                        },
                        protocolRole: 'friend',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMissingRole);
                }));
                it('rejects $contextRole authorized queries where the query author does not have a matching $contextRole', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = threadRoleProtocolDefinition;
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfig.message);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Alice writes a 'thread' record
                    const threadRecord = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'thread',
                    });
                    const threadRoleReply = yield dwn.processMessage(alice.did, threadRecord.message, threadRecord.dataStream);
                    expect(threadRoleReply.status.code).to.equal(202);
                    // Alice writes three 'chat' records
                    const chatRecordIds = [];
                    for (let i = 0; i < 3; i++) {
                        const chatRecord = yield TestDataGenerator.generateRecordsWrite({
                            author: alice,
                            recipient: alice.did,
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            published: false,
                            contextId: threadRecord.message.contextId,
                            parentId: threadRecord.message.recordId,
                            data: new TextEncoder().encode('Bob can read this cuz he is my friend'),
                        });
                        const chatReply = yield dwn.processMessage(alice.did, chatRecord.message, chatRecord.dataStream);
                        expect(chatReply.status.code).to.equal(202);
                        chatRecordIds.push(chatRecord.message.recordId);
                    }
                    // Bob invokes his friendRole to query that records
                    const chatQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: bob,
                        filter: {
                            protocol: protocolDefinition.protocol,
                            protocolPath: 'thread/chat',
                            contextId: threadRecord.message.contextId,
                        },
                        protocolRole: 'thread/participant',
                    });
                    const chatQueryReply = yield dwn.processMessage(alice.did, chatQuery.message);
                    expect(chatQueryReply.status.code).to.eq(401);
                    expect(chatQueryReply.status.detail).to.contain(DwnErrorCode.ProtocolAuthorizationMissingRole);
                }));
            });
        });
        it('should return 401 if signature check fails', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub did resolver & message store
            // intentionally not supplying the public key so a different public key is generated to simulate invalid signature
            const mismatchingPersona = yield TestDataGenerator.generatePersona({ did: author.did, keyId: author.keyId });
            const didResolver = TestStubGenerator.createDidResolverStub(mismatchingPersona);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(401);
        }));
        it('should return 400 if fail parsing the message', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub method resolver & message store
            const didResolver = TestStubGenerator.createDidResolverStub(author);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            // stub the `parse()` function to throw an error
            sinon.stub(RecordsQuery, 'parse').throws('anyError');
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(400);
        }));
    });
}
//# sourceMappingURL=records-query.spec.js.map