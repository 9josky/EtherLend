var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import { ArrayUtility } from '../../src/utils/array.js';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DwnConstant } from '../../src/core/dwn-constant.js';
import { Encoder } from '../../src/utils/encoder.js';
import { Jws } from '../../src/utils/jws.js';
import { Message } from '../../src/core/message.js';
import { RecordsQueryHandler } from '../../src/handlers/records-query.js';
import { SortOrder } from '../../src/types/message-types.js';
import { stubInterface } from 'ts-sinon';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { TestStubGenerator } from '../utils/test-stub-generator.js';
import { toTemporalInstant } from '@js-temporal/polyfill';
import { constructRecordsWriteIndexes, RecordsWriteHandler } from '../../src/handlers/records-write.js';
import { DateSort, RecordsQuery } from '../../src/interfaces/records-query.js';
import { DidResolver, Dwn } from '../../src/index.js';
import { DwnErrorCode, MessageStoreLevel } from '../../src/index.js';
chai.use(chaiAsPromised);
function createDateString(d) {
    return toTemporalInstant.call(d).toString({ smallestUnit: 'microseconds' });
}
export function testRecordsQueryHandler() {
    describe('RecordsQueryHandler.handle()', () => {
        describe('functional tests', () => {
            let didResolver;
            let messageStore;
            let dataStore;
            let eventLog;
            let dwn;
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new DidResolver([new DidKeyResolver()]);
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should return recordId, descriptor, authorization and attestation', () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const alice = yield TestDataGenerator.generatePersona();
                const bob = yield TestDataGenerator.generatePersona();
                TestStubGenerator.stubDidResolver(didResolver, [alice, bob]);
                const dataFormat = 'myAwesomeDataFormat';
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob], dataFormat });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const query = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, query.message);
                expect((_a = reply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
                const entry = reply.entries[0];
                expect(entry.authorization).to.deep.equal(write.message.authorization);
                expect(entry.attestation).to.deep.equal(write.message.attestation);
                expect(entry.descriptor).to.deep.equal(write.message.descriptor);
                expect(entry.recordId).to.equal(write.message.recordId);
            }));
            it('should return records matching the query', () => __awaiter(this, void 0, void 0, function* () {
                var _b, _c;
                // insert three messages into DB, two with matching protocol
                const alice = yield TestDataGenerator.generatePersona();
                const dataFormat = 'myAwesomeDataFormat';
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema1' });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dataFormat, schema: 'schema2' });
                // setting up a stub resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing singular conditional query
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { dataFormat } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_b = reply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(2); // only 2 entries should match the query on protocol
                // testing multi-conditional query, reuse data generated above for bob
                const messageData2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        dataFormat,
                        schema: 'schema1'
                    }
                });
                const reply2 = yield dwn.processMessage(alice.did, messageData2.message);
                expect(reply2.status.code).to.equal(200);
                expect((_c = reply2.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1); // only 1 entry should match the query
            }));
            it('should return `encodedData` if data size is within the spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _d;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded); // within/on threshold
                const alice = yield DidKeyResolver.generate();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_d = reply.entries) === null || _d === void 0 ? void 0 : _d.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(data));
            }));
            it('should not return `encodedData` if data size is greater then spec threshold', () => __awaiter(this, void 0, void 0, function* () {
                var _e;
                const data = TestDataGenerator.randomBytes(DwnConstant.maxDataSizeAllowedToBeEncoded + 1); // exceeding threshold
                const alice = yield DidKeyResolver.generate();
                const write = yield TestDataGenerator.generateRecordsWrite({ author: alice, data });
                const writeReply = yield dwn.processMessage(alice.did, write.message, write.dataStream);
                expect(writeReply.status.code).to.equal(202);
                const messageData = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { recordId: write.message.recordId } });
                const reply = yield dwn.processMessage(alice.did, messageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_e = reply.entries) === null || _e === void 0 ? void 0 : _e.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.be.undefined;
            }));
            it('should be able to query by attester', () => __awaiter(this, void 0, void 0, function* () {
                var _f, _g, _h;
                // scenario: 2 records authored by alice, 1st attested by alice, 2nd attested by bob
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const recordsWrite1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const recordsWrite2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [bob] });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, recordsWrite1.message, recordsWrite1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, recordsWrite2.message, recordsWrite2.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                // testing attester filter
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: alice.did } });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_f = reply1.entries) === null || _f === void 0 ? void 0 : _f.length).to.equal(1);
                const reply1Attester = Jws.getSignerDid(reply1.entries[0].attestation.signatures[0]);
                expect(reply1Attester).to.equal(alice.did);
                // testing attester + another filter
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { attester: bob.did, schema: recordsWrite2.message.descriptor.schema }
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_g = reply2.entries) === null || _g === void 0 ? void 0 : _g.length).to.equal(1);
                const reply2Attester = Jws.getSignerDid(reply2.entries[0].attestation.signatures[0]);
                expect(reply2Attester).to.equal(bob.did);
                // testing attester filter that yields no results
                const carol = yield DidKeyResolver.generate();
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({ author: alice, filter: { attester: carol.did } });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_h = reply3.entries) === null || _h === void 0 ? void 0 : _h.length).to.equal(0);
            }));
            it('should be able to range query by `dateCreated`', () => __awaiter(this, void 0, void 0, function* () {
                var _j, _k, _l, _m;
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively, only the first 2 records share the same schema
                const firstDayOf2021 = createDateString(new Date(2021, 1, 1));
                const firstDayOf2022 = createDateString(new Date(2022, 1, 1));
                const firstDayOf2023 = createDateString(new Date(2023, 1, 1));
                const alice = yield DidKeyResolver.generate();
                const write1 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021 });
                const write2 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022 });
                const write3 = yield TestDataGenerator.generateRecordsWrite({ author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023 });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing `from` range
                const lastDayOf2021 = createDateString(new Date(2021, 12, 31));
                const recordsQuery1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2021 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply1 = yield dwn.processMessage(alice.did, recordsQuery1.message);
                expect((_j = reply1.entries) === null || _j === void 0 ? void 0 : _j.length).to.equal(2);
                expect(reply1.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                expect(reply1.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing `to` range
                const lastDayOf2022 = createDateString(new Date(2022, 12, 31));
                const recordsQuery2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { to: lastDayOf2022 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply2 = yield dwn.processMessage(alice.did, recordsQuery2.message);
                expect((_k = reply2.entries) === null || _k === void 0 ? void 0 : _k.length).to.equal(2);
                expect(reply2.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write1.dataBytes));
                expect(reply2.entries[1].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
                // testing `from` and `to` range
                const lastDayOf2023 = createDateString(new Date(2023, 12, 31));
                const recordsQuery3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: lastDayOf2022, to: lastDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply3 = yield dwn.processMessage(alice.did, recordsQuery3.message);
                expect((_l = reply3.entries) === null || _l === void 0 ? void 0 : _l.length).to.equal(1);
                expect(reply3.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write3.dataBytes));
                // testing edge case where value equals `from` and `to`
                const recordsQuery4 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { dateCreated: { from: firstDayOf2022, to: firstDayOf2023 } },
                    dateSort: DateSort.CreatedAscending
                });
                const reply4 = yield dwn.processMessage(alice.did, recordsQuery4.message);
                expect((_m = reply4.entries) === null || _m === void 0 ? void 0 : _m.length).to.equal(1);
                expect(reply4.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should be able use range and exact match queries at the same time', () => __awaiter(this, void 0, void 0, function* () {
                var _o;
                // scenario: 3 records authored by alice, created on first of 2021, 2022, and 2023 respectively, only the first 2 records share the same schema
                const firstDayOf2021 = createDateString(new Date(2021, 1, 1));
                const firstDayOf2022 = createDateString(new Date(2022, 1, 1));
                const firstDayOf2023 = createDateString(new Date(2023, 1, 1));
                const alice = yield DidKeyResolver.generate();
                const schema = '2021And2022Schema';
                const write1 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2021, messageTimestamp: firstDayOf2021, schema
                });
                const write2 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2022, messageTimestamp: firstDayOf2022, schema
                });
                const write3 = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, dateCreated: firstDayOf2023, messageTimestamp: firstDayOf2023
                });
                // insert data
                const writeReply1 = yield dwn.processMessage(alice.did, write1.message, write1.dataStream);
                const writeReply2 = yield dwn.processMessage(alice.did, write2.message, write2.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3.message, write3.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // testing range criterion with another exact match
                const lastDayOf2021 = createDateString(new Date(2021, 12, 31));
                const lastDayOf2023 = createDateString(new Date(2023, 12, 31));
                const recordsQuery5 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        schema,
                        dateCreated: { from: lastDayOf2021, to: lastDayOf2023 } // by itself selects the last 2 records
                    },
                    dateSort: DateSort.CreatedAscending
                });
                const reply = yield dwn.processMessage(alice.did, recordsQuery5.message);
                expect((_o = reply.entries) === null || _o === void 0 ? void 0 : _o.length).to.equal(1);
                expect(reply.entries[0].encodedData).to.equal(Encoder.bytesToBase64Url(write2.dataBytes));
            }));
            it('should include `authorization` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                var _p;
                const alice = yield TestDataGenerator.generatePersona();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_p = queryReply.entries) === null || _p === void 0 ? void 0 : _p.length).to.equal(1);
                expect(queryReply.entries[0].authorization).to.deep.equal(message.authorization);
            }));
            it('should include `attestation` in returned records', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: alice and bob attest to a message alice authored
                var _q, _r, _s;
                const alice = yield DidKeyResolver.generate();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice, attesters: [alice] });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: message.descriptor.schema }
                });
                const queryReply = yield dwn.processMessage(alice.did, queryData.message);
                expect(queryReply.status.code).to.equal(200);
                expect((_q = queryReply.entries) === null || _q === void 0 ? void 0 : _q.length).to.equal(1);
                const recordsWriteMessage = queryReply.entries[0];
                expect((_s = (_r = recordsWriteMessage.attestation) === null || _r === void 0 ? void 0 : _r.signatures) === null || _s === void 0 ? void 0 : _s.length).to.equal(1);
            }));
            it('should omit records that are not published if `dateSort` sorts on `datePublished`', () => __awaiter(this, void 0, void 0, function* () {
                var _t, _u;
                // setup: 2 records in DWN: 1 published and 1 unpublished
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const publishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, published: true
                });
                const unpublishedWriteData = yield TestDataGenerator.generateRecordsWrite({
                    author: alice, schema
                });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data
                const publishedWriteReply = yield dwn.processMessage(alice.did, publishedWriteData.message, publishedWriteData.dataStream);
                const unpublishedWriteReply = yield dwn.processMessage(alice.did, unpublishedWriteData.message, unpublishedWriteData.dataStream);
                expect(publishedWriteReply.status.code).to.equal(202);
                expect(unpublishedWriteReply.status.code).to.equal(202);
                // test published date ascending sort does not include any records that is not published
                const publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                const publishedAscendingQueryReply = yield dwn.handleRecordsQuery(alice.did, publishedAscendingQueryData.message);
                expect((_t = publishedAscendingQueryReply.entries) === null || _t === void 0 ? void 0 : _t.length).to.equal(1);
                expect(publishedAscendingQueryReply.entries[0].descriptor['datePublished']).to.equal(publishedWriteData.message.descriptor.datePublished);
                // test published date scending sort does not include any records that is not published
                const publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                const publishedDescendingQueryReply = yield dwn.handleRecordsQuery(alice.did, publishedDescendingQueryData.message);
                expect((_u = publishedDescendingQueryReply.entries) === null || _u === void 0 ? void 0 : _u.length).to.equal(1);
                expect(publishedDescendingQueryReply.entries[0].descriptor['datePublished']).to.equal(publishedWriteData.message.descriptor.datePublished);
            }));
            it('should sort records if `dateSort` is specified', () => __awaiter(this, void 0, void 0, function* () {
                var _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6;
                // insert three messages into DB
                const alice = yield TestDataGenerator.generatePersona();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, published });
                // setting up a stub method resolver
                const mockResolution = TestDataGenerator.createDidResolutionResult(alice);
                ;
                sinon.stub(didResolver, 'resolve').resolves(mockResolution);
                // insert data, intentionally out of order
                const writeReply2 = yield dwn.processMessage(alice.did, write2Data.message, write2Data.dataStream);
                const writeReply1 = yield dwn.processMessage(alice.did, write1Data.message, write1Data.dataStream);
                const writeReply3 = yield dwn.processMessage(alice.did, write3Data.message, write3Data.dataStream);
                expect(writeReply1.status.code).to.equal(202);
                expect(writeReply2.status.code).to.equal(202);
                expect(writeReply3.status.code).to.equal(202);
                // createdAscending test
                const createdAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedAscending,
                    filter: { schema }
                });
                const createdAscendingQueryReply = yield dwn.handleRecordsQuery(alice.did, createdAscendingQueryData.message);
                expect((_v = createdAscendingQueryReply.entries) === null || _v === void 0 ? void 0 : _v[0].descriptor['dateCreated']).to.equal(write1Data.message.descriptor.dateCreated);
                expect((_w = createdAscendingQueryReply.entries) === null || _w === void 0 ? void 0 : _w[1].descriptor['dateCreated']).to.equal(write2Data.message.descriptor.dateCreated);
                expect((_x = createdAscendingQueryReply.entries) === null || _x === void 0 ? void 0 : _x[2].descriptor['dateCreated']).to.equal(write3Data.message.descriptor.dateCreated);
                // createdDescending test
                const createdDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.CreatedDescending,
                    filter: { schema }
                });
                const createdDescendingQueryReply = yield dwn.handleRecordsQuery(alice.did, createdDescendingQueryData.message);
                expect((_y = createdDescendingQueryReply.entries) === null || _y === void 0 ? void 0 : _y[0].descriptor['dateCreated']).to.equal(write3Data.message.descriptor.dateCreated);
                expect((_z = createdDescendingQueryReply.entries) === null || _z === void 0 ? void 0 : _z[1].descriptor['dateCreated']).to.equal(write2Data.message.descriptor.dateCreated);
                expect((_0 = createdDescendingQueryReply.entries) === null || _0 === void 0 ? void 0 : _0[2].descriptor['dateCreated']).to.equal(write1Data.message.descriptor.dateCreated);
                // publishedAscending test
                const publishedAscendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedAscending,
                    filter: { schema }
                });
                const publishedAscendingQueryReply = yield dwn.handleRecordsQuery(alice.did, publishedAscendingQueryData.message);
                expect((_1 = publishedAscendingQueryReply.entries) === null || _1 === void 0 ? void 0 : _1[0].descriptor['datePublished']).to.equal(write1Data.message.descriptor.datePublished);
                expect((_2 = publishedAscendingQueryReply.entries) === null || _2 === void 0 ? void 0 : _2[1].descriptor['datePublished']).to.equal(write2Data.message.descriptor.datePublished);
                expect((_3 = publishedAscendingQueryReply.entries) === null || _3 === void 0 ? void 0 : _3[2].descriptor['datePublished']).to.equal(write3Data.message.descriptor.datePublished);
                // publishedDescending test
                const publishedDescendingQueryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    dateSort: DateSort.PublishedDescending,
                    filter: { schema }
                });
                const publishedDescendingQueryReply = yield dwn.handleRecordsQuery(alice.did, publishedDescendingQueryData.message);
                expect((_4 = publishedDescendingQueryReply.entries) === null || _4 === void 0 ? void 0 : _4[0].descriptor['datePublished']).to.equal(write3Data.message.descriptor.datePublished);
                expect((_5 = publishedDescendingQueryReply.entries) === null || _5 === void 0 ? void 0 : _5[1].descriptor['datePublished']).to.equal(write2Data.message.descriptor.datePublished);
                expect((_6 = publishedDescendingQueryReply.entries) === null || _6 === void 0 ? void 0 : _6[2].descriptor['datePublished']).to.equal(write1Data.message.descriptor.datePublished);
            }));
            it('should tiebreak using `messageCid` when sorting encounters identical values', () => __awaiter(this, void 0, void 0, function* () {
                var _7;
                // setup: 3 messages with the same `dateCreated` value
                const dateCreated = createDateString(new Date());
                const messageTimestamp = dateCreated;
                const alice = yield DidKeyResolver.generate();
                const schema = 'aSchema';
                const published = true;
                const write1Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write2Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                const write3Data = yield TestDataGenerator.generateRecordsWrite({ messageTimestamp, dateCreated, author: alice, schema, published });
                // sort the messages in lexicographical order against `messageCid`
                const [oldestWrite, middleWrite, newestWrite] = yield ArrayUtility.asyncSort([write1Data, write2Data, write3Data], (messageDataA, messageDataB) => { return Message.compareCid(messageDataA.message, messageDataB.message); });
                // intentionally write the RecordsWrite of out lexicographical order to avoid the test query below accidentally having the correct order
                const reply2 = yield dwn.processMessage(alice.did, middleWrite.message, middleWrite.dataStream);
                expect(reply2.status.code).to.equal(202);
                const reply3 = yield dwn.processMessage(alice.did, newestWrite.message, newestWrite.dataStream);
                expect(reply3.status.code).to.equal(202);
                const reply1 = yield dwn.processMessage(alice.did, oldestWrite.message, oldestWrite.dataStream);
                expect(reply1.status.code).to.equal(202);
                const queryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending
                });
                const queryReply = yield dwn.processMessage(alice.did, queryMessageData.message);
                // verify that messages returned are sorted/tiebreak by `messageCid`
                expect(queryReply.status.code).to.equal(200);
                expect((_7 = queryReply.entries) === null || _7 === void 0 ? void 0 : _7.length).to.equal(3);
                expect(queryReply.entries[0].recordId).to.equal(oldestWrite.message.recordId);
                expect(queryReply.entries[1].recordId).to.equal(middleWrite.message.recordId);
                expect(queryReply.entries[2].recordId).to.equal(newestWrite.message.recordId);
            }));
            it('should paginate records if pagination is provided', () => __awaiter(this, void 0, void 0, function* () {
                var _8;
                const alice = yield DidKeyResolver.generate();
                const messages = yield Promise.all(Array(12).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, message.dataStream);
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const results = [];
                let messageCid;
                while (true) {
                    const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                        author: alice,
                        filter: {
                            schema: 'https://schema'
                        },
                        pagination: {
                            limit: limit,
                            messageCid,
                        },
                    });
                    const pageReply = yield dwn.handleRecordsQuery(alice.did, pageQuery.message);
                    expect(pageReply.status.code).to.equal(200);
                    messageCid = pageReply.paginationMessageCid;
                    expect((_8 = pageReply.entries) === null || _8 === void 0 ? void 0 : _8.length).to.be.lte(limit);
                    results.push(...pageReply.entries);
                    if (messageCid === undefined) {
                        break;
                    }
                }
                expect(results.length).to.equal(messages.length);
                expect(messages.every(({ message }) => results.map(e => e.recordId).includes(message.recordId)));
            }));
            it('paginationMessageCid should match the messageCid of the last entry in the returned query', () => __awaiter(this, void 0, void 0, function* () {
                var _9;
                const alice = yield DidKeyResolver.generate();
                const messages = yield Promise.all(Array(6).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    schema: 'https://schema'
                })));
                for (const message of messages) {
                    const result = yield dwn.processMessage(alice.did, message.message, message.dataStream);
                    expect(result.status.code).to.equal(202);
                }
                const limit = 5;
                const pageQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: {
                        schema: 'https://schema'
                    },
                    pagination: {
                        limit: limit,
                    },
                });
                const pageReply = yield dwn.handleRecordsQuery(alice.did, pageQuery.message);
                expect(pageReply.status.code).to.equal(200);
                expect((_9 = pageReply.entries) === null || _9 === void 0 ? void 0 : _9.length).to.be.lte(limit);
                expect(pageReply.paginationMessageCid).to.exist;
                const lastMessageWithAuthorization = messages.find(m => { var _a; return m.message.recordId === ((_a = pageReply.entries) === null || _a === void 0 ? void 0 : _a.at(-1).recordId); });
                const messageCid = yield Message.getCid(lastMessageWithAuthorization.message);
                expect(pageReply.paginationMessageCid).to.equal(messageCid);
            }));
            it('should allow an anonymous unauthenticated query to return published records', () => __awaiter(this, void 0, void 0, function* () {
                var _10;
                // write 2 records into Alice's DB:
                // 1st is unpublished
                // 2nd is published
                const alice = yield DidKeyResolver.generate();
                const record1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema1', published: false });
                const record2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema: 'https://schema2', published: true });
                const recordsWrite1Reply = yield dwn.processMessage(alice.did, record1Data.message, record1Data.dataStream);
                expect(recordsWrite1Reply.status.code).to.equal(202);
                const recordsWrite2Reply = yield dwn.processMessage(alice.did, record2Data.message, record2Data.dataStream);
                expect(recordsWrite2Reply.status.code).to.equal(202);
                // test correctness for anonymous query
                const anonymousQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    anonymous: true,
                    filter: { dateCreated: { from: '2000-01-01T10:20:30.123456Z' } }
                });
                // sanity check
                expect(anonymousQueryMessageData.message.authorization).to.not.exist;
                const replyToQuery = yield dwn.processMessage(alice.did, anonymousQueryMessageData.message);
                expect(replyToQuery.status.code).to.equal(200);
                expect((_10 = replyToQuery.entries) === null || _10 === void 0 ? void 0 : _10.length).to.equal(1);
                expect(replyToQuery.entries[0].descriptor.schema).to.equal('https://schema2');
            }));
            it('should only return published records and unpublished records that is meant for author', () => __awaiter(this, void 0, void 0, function* () {
                // write 4 records into Alice's DB:
                // 1st is unpublished authored by Alice
                // 2nd is also unpublished authored by Alice, but is meant for (has recipient as) Bob
                // 3rd is also unpublished but is authored by Bob
                // 4th is published
                // 5th is published, authored by Alice and is meant for Carol as recipient;
                var _11, _12, _13, _14, _15, _16;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const carol = yield DidKeyResolver.generate();
                const schema = 'schema1';
                const record1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('1') });
                const record2Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, protocol: 'protocol', protocolPath: 'path', recipient: bob.did, data: Encoder.stringToBytes('2') });
                const record3Data = yield TestDataGenerator.generateRecordsWrite({ author: bob, schema, protocol: 'protocol', protocolPath: 'path', recipient: alice.did, data: Encoder.stringToBytes('3') });
                const record4Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('4'), published: true });
                const record5Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('5'), published: true, recipient: carol.did });
                // directly inserting data to datastore so that we don't have to setup to grant Bob permission to write to Alice's DWN
                const recordsWriteHandler = new RecordsWriteHandler(didResolver, messageStore, dataStore, eventLog);
                const additionalIndexes1 = yield constructRecordsWriteIndexes(record1Data.recordsWrite, true);
                record1Data.message = yield recordsWriteHandler.processEncodedData(record1Data.message, record1Data.dataStream);
                yield messageStore.put(alice.did, record1Data.message, additionalIndexes1);
                yield eventLog.append(alice.did, yield Message.getCid(record1Data.message));
                const additionalIndexes2 = yield constructRecordsWriteIndexes(record2Data.recordsWrite, true);
                record2Data.message = yield recordsWriteHandler.processEncodedData(record2Data.message, record2Data.dataStream);
                yield messageStore.put(alice.did, record2Data.message, additionalIndexes2);
                yield eventLog.append(alice.did, yield Message.getCid(record2Data.message));
                const additionalIndexes3 = yield constructRecordsWriteIndexes(record3Data.recordsWrite, true);
                record3Data.message = yield recordsWriteHandler.processEncodedData(record3Data.message, record3Data.dataStream);
                yield messageStore.put(alice.did, record3Data.message, additionalIndexes3);
                yield eventLog.append(alice.did, yield Message.getCid(record3Data.message));
                const additionalIndexes4 = yield constructRecordsWriteIndexes(record4Data.recordsWrite, true);
                record4Data.message = yield recordsWriteHandler.processEncodedData(record4Data.message, record4Data.dataStream);
                yield messageStore.put(alice.did, record4Data.message, additionalIndexes4);
                yield eventLog.append(alice.did, yield Message.getCid(record4Data.message));
                const additionalIndexes5 = yield constructRecordsWriteIndexes(record5Data.recordsWrite, true);
                record5Data.message = yield recordsWriteHandler.processEncodedData(record5Data.message, record5Data.dataStream);
                yield messageStore.put(alice.did, record5Data.message, additionalIndexes5);
                yield eventLog.append(alice.did, yield Message.getCid(record5Data.message));
                // test correctness for Bob's query
                const bobQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema }
                });
                const replyToBob = yield dwn.processMessage(alice.did, bobQueryMessageData.message);
                expect(replyToBob.status.code).to.equal(200);
                expect((_11 = replyToBob.entries) === null || _11 === void 0 ? void 0 : _11.length).to.equal(4); // expect 4 records
                const privateRecordsForBob = (_12 = replyToBob.entries) === null || _12 === void 0 ? void 0 : _12.filter(message => message.encodedData === Encoder.stringToBase64Url('2'));
                const privateRecordsFromBob = (_13 = replyToBob.entries) === null || _13 === void 0 ? void 0 : _13.filter(message => message.encodedData === Encoder.stringToBase64Url('3'));
                const publicRecords = (_14 = replyToBob.entries) === null || _14 === void 0 ? void 0 : _14.filter(message => message.encodedData === Encoder.stringToBase64Url('4') || message.encodedData === Encoder.stringToBase64Url('5'));
                expect(privateRecordsForBob.length).to.equal(1);
                expect(privateRecordsFromBob.length).to.equal(1);
                expect(publicRecords.length).to.equal(2);
                // test correctness for Alice's query
                const aliceQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                const replyToAliceQuery = yield dwn.processMessage(alice.did, aliceQueryMessageData.message);
                expect(replyToAliceQuery.status.code).to.equal(200);
                expect((_15 = replyToAliceQuery.entries) === null || _15 === void 0 ? void 0 : _15.length).to.equal(5); // expect all 5 records
                // filter for public records with carol as recipient
                const bobQueryCarolMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema, recipient: carol.did }
                });
                const replyToBobCarolQuery = yield dwn.processMessage(alice.did, bobQueryCarolMessageData.message);
                expect(replyToBobCarolQuery.status.code).to.equal(200);
                expect((_16 = replyToBobCarolQuery.entries) === null || _16 === void 0 ? void 0 : _16.length).to.equal(1);
                expect(replyToBobCarolQuery.entries[0].encodedData).to.equal(Encoder.stringToBase64Url('5'));
            }));
            it('should paginate correctly for fetchRecordsAsNonOwner()', () => __awaiter(this, void 0, void 0, function* () {
                var _17, e_1, _18, _19;
                var _20, _21, _22, _23, _24;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'schema1';
                // published messages bob
                const bobPublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // published messages alice
                const alicePublishedPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), published: true,
                }));
                // alice non public messages
                const aliceMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // bob non public messages
                const bobMessagesPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: bob, schema, data: TestDataGenerator.randomBytes(10)
                }));
                // non public messages intended for bob
                const aliceMessagesForBobPromise = Array(5).fill({}).map(_ => TestDataGenerator.generateRecordsWrite({
                    author: alice, schema, data: TestDataGenerator.randomBytes(10), recipient: bob.did,
                }));
                const messagePromises = [
                    ...bobPublishedPromise,
                    ...aliceMessagesPromise,
                    ...bobMessagesPromise,
                    ...alicePublishedPromise,
                    ...aliceMessagesForBobPromise,
                ];
                const recordsWriteHandler = new RecordsWriteHandler(didResolver, messageStore, dataStore, eventLog);
                const messages = [];
                try {
                    for (var _25 = true, messagePromises_1 = __asyncValues(messagePromises), messagePromises_1_1; messagePromises_1_1 = yield messagePromises_1.next(), _17 = messagePromises_1_1.done, !_17; _25 = true) {
                        _19 = messagePromises_1_1.value;
                        _25 = false;
                        const { recordsWrite, message, dataStream } = _19;
                        const indexes = yield constructRecordsWriteIndexes(recordsWrite, true);
                        const processedMessage = yield recordsWriteHandler.processEncodedData(message, dataStream);
                        yield messageStore.put(alice.did, processedMessage, indexes);
                        yield eventLog.append(alice.did, yield Message.getCid(processedMessage));
                        messages.push(processedMessage);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_25 && !_17 && (_18 = messagePromises_1.return)) yield _18.call(messagePromises_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                // fetch all from alice for sanity, alice should get all of the records
                // page1 alice
                const aliceQueryMessageDataPage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                const sortedMessages = yield MessageStoreLevel.sortMessages(messages, { dateCreated: SortOrder.Ascending });
                let results = yield dwn.processMessage(alice.did, aliceQueryMessageDataPage1.message);
                expect(results.status.code).to.equal(200);
                expect((_20 = results.entries) === null || _20 === void 0 ? void 0 : _20.length).to.equal(10, 'alice page 1');
                const page1PaginationLastMessage = yield Message.getCid(sortedMessages.at(9)); // get messageCid from message with authorization.
                expect(results.paginationMessageCid).to.equal(page1PaginationLastMessage, 'alice page 1');
                // page2 alice
                const aliceQueryMessageDataPage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, messageCid: results.paginationMessageCid },
                });
                results = (yield dwn.processMessage(alice.did, aliceQueryMessageDataPage2.message));
                expect(results.status.code).to.equal(200);
                expect((_21 = results.entries) === null || _21 === void 0 ? void 0 : _21.length).to.equal(10, 'alice page 2');
                const page2PaginationLastMessage = yield Message.getCid(sortedMessages.at(19)); // get messageCid from message with authorization.
                expect(results.paginationMessageCid).to.equal(page2PaginationLastMessage, 'alice page 2');
                // page3 alice
                const aliceQueryMessageDataPage3 = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, messageCid: results.paginationMessageCid },
                });
                results = (yield dwn.processMessage(alice.did, aliceQueryMessageDataPage3.message));
                expect(results.status.code).to.equal(200);
                expect((_22 = results.entries) === null || _22 === void 0 ? void 0 : _22.length).to.equal(5, 'alice page 3');
                expect(results.paginationMessageCid).to.not.exist;
                const bobs = (m) => {
                    return m.descriptor.recipient === bob.did || m.descriptor.published === true || Message.getAuthor(m) === bob.did;
                };
                // all records from alice have been validated
                // now we prepare to test records that only bob should get
                const bobSorted = sortedMessages.filter(m => bobs(m));
                const bobRetrieved = [];
                const bobQueryMessagePage1 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10 },
                });
                results = (yield dwn.processMessage(alice.did, bobQueryMessagePage1.message));
                expect(results.status.code).to.equal(200);
                expect((_23 = results.entries) === null || _23 === void 0 ? void 0 : _23.length).to.equal(10, 'bob page 1');
                const page1BobPaginationLastMessage = yield Message.getCid(bobSorted.at(9));
                expect(results.paginationMessageCid).to.equal(page1BobPaginationLastMessage, 'bob page 1');
                bobRetrieved.push(...results.entries);
                const bobQueryMessagePage2 = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema },
                    dateSort: DateSort.CreatedAscending,
                    pagination: { limit: 10, messageCid: results.paginationMessageCid },
                });
                results = (yield dwn.processMessage(alice.did, bobQueryMessagePage2.message));
                expect(results.status.code).to.equal(200);
                expect((_24 = results.entries) === null || _24 === void 0 ? void 0 : _24.length).to.equal(10, 'bob page 2');
                expect(results.paginationMessageCid).to.not.exist;
                bobRetrieved.push(...results.entries);
                const compareRecordId = (a, b) => {
                    return a.recordId === b.recordId;
                };
                expect(bobSorted.every((m, i) => compareRecordId(bobRetrieved.at(i), m)));
            }));
            // https://github.com/TBD54566975/dwn-sdk-js/issues/170
            it('#170 - should treat records with `published` explicitly set to `false` as unpublished', () => __awaiter(this, void 0, void 0, function* () {
                var _26, _27;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'schema1';
                const unpublishedRecordsWrite = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema, data: Encoder.stringToBytes('1'), published: false } // explicitly setting `published` to `false`
                );
                const result1 = yield dwn.processMessage(alice.did, unpublishedRecordsWrite.message, unpublishedRecordsWrite.dataStream);
                expect(result1.status.code).to.equal(202);
                // alice should be able to see the unpublished record
                const queryByAlice = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                const replyToAliceQuery = yield dwn.processMessage(alice.did, queryByAlice.message);
                expect(replyToAliceQuery.status.code).to.equal(200);
                expect((_26 = replyToAliceQuery.entries) === null || _26 === void 0 ? void 0 : _26.length).to.equal(1);
                // actual test: bob should not be able to see unpublished record
                const queryByBob = yield TestDataGenerator.generateRecordsQuery({
                    author: bob,
                    filter: { schema }
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, queryByBob.message);
                expect(replyToBobQuery.status.code).to.equal(200);
                expect((_27 = replyToBobQuery.entries) === null || _27 === void 0 ? void 0 : _27.length).to.equal(0);
            }));
            it('should allow DWN owner to use `recipient` as a filter in queries', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const bobQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { recipient: bob.did } // alice as the DWN owner querying bob's records
                });
                const replyToBobQuery = yield dwn.processMessage(alice.did, bobQueryMessageData.message);
                expect(replyToBobQuery.status.code).to.equal(200);
            }));
            it('should not fetch entries across tenants', () => __awaiter(this, void 0, void 0, function* () {
                var _28;
                // insert three messages into DB, two with matching schema
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const schema = 'myAwesomeSchema';
                const recordsWriteMessage1Data = yield TestDataGenerator.generateRecordsWrite({ author: alice, schema });
                const recordsWriteMessage2Data = yield TestDataGenerator.generateRecordsWrite({ author: bob, schema });
                const aliceQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema }
                });
                // insert data into 2 different tenants
                yield dwn.processMessage(alice.did, recordsWriteMessage1Data.message, recordsWriteMessage1Data.dataStream);
                yield dwn.processMessage(bob.did, recordsWriteMessage2Data.message, recordsWriteMessage2Data.dataStream);
                const reply = yield dwn.processMessage(alice.did, aliceQueryMessageData.message);
                expect(reply.status.code).to.equal(200);
                expect((_28 = reply.entries) === null || _28 === void 0 ? void 0 : _28.length).to.equal(1);
            }));
            it('should return 400 if protocol is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // query for non-normalized protocol
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { protocol: 'example.com/' },
                });
                // overwrite protocol because #create auto-normalizes protocol
                recordsQuery.message.descriptor.filter.protocol = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorizationAsAuthor(recordsQuery.message.descriptor, Jws.createSigner(alice));
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlProtocolNotNormalized);
            }));
            it('should return 400 if schema is not normalized', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // query for non-normalized schema
                const recordsQuery = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { schema: 'example.com/' },
                });
                // overwrite schema because #create auto-normalizes schema
                recordsQuery.message.descriptor.filter.schema = 'example.com/';
                // Re-create auth because we altered the descriptor after signing
                recordsQuery.message.authorization = yield Message.createAuthorizationAsAuthor(recordsQuery.message.descriptor, Jws.createSigner(alice));
                // Send records write message
                const reply = yield dwn.processMessage(alice.did, recordsQuery.message);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(DwnErrorCode.UrlSchemaNotNormalized);
            }));
        });
        it('should return 401 if signature check fails', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub did resolver & message store
            // intentionally not supplying the public key so a different public key is generated to simulate invalid signature
            const mismatchingPersona = yield TestDataGenerator.generatePersona({ did: author.did, keyId: author.keyId });
            const didResolver = TestStubGenerator.createDidResolverStub(mismatchingPersona);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(401);
        }));
        it('should return 400 if fail parsing the message', () => __awaiter(this, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsQuery();
            const tenant = author.did;
            // setting up a stub method resolver & message store
            const didResolver = TestStubGenerator.createDidResolverStub(author);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsQueryHandler = new RecordsQueryHandler(didResolver, messageStore, dataStore);
            // stub the `parse()` function to throw an error
            sinon.stub(RecordsQuery, 'parse').throws('anyError');
            const reply = yield recordsQueryHandler.handle({ tenant, message });
            expect(reply.status.code).to.equal(400);
        }));
    });
}
//# sourceMappingURL=records-query.spec.js.map