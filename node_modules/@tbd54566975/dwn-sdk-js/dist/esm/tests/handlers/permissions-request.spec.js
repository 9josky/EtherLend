var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { expect } from 'chai';
import sinon from 'sinon';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DidResolver } from '../../src/did/did-resolver.js';
import { Dwn } from '../../src/dwn.js';
import { Message } from '../../src/core/message.js';
import { PermissionsRequest } from '../../src/interfaces/permissions-request.js';
import { PermissionsRequestHandler } from '../../src/handlers/permissions-request.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { DwnInterfaceName, DwnMethodName } from '../../src/index.js';
export function testPermissionsRequestHandler() {
    describe('PermissionsRequestHandler.handle()', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let dwn;
        describe('functional tests', () => {
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new DidResolver([new DidKeyResolver()]);
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should accept a PermissionsRequest with conditions omitted', () => __awaiter(this, void 0, void 0, function* () {
                // scenario: Bob sends a PermissionsRequest to Alice's DWN
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsRequest({
                    author: bob,
                    description: 'Please allow me to RecordsWrite',
                    grantedBy: alice.did,
                    grantedTo: bob.did,
                    grantedFor: alice.did,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                    },
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(202);
            }));
            it('should return 401 if auth fails', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                alice.keyId = 'wrongValue'; // to fail authentication
                const { message } = yield TestDataGenerator.generatePermissionsRequest({
                    author: alice,
                    scope: {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                    }
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain('not a valid DID');
            }));
            it('should return 400 if failure parsing the message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsRequest();
                const permissionsRequestHandler = new PermissionsRequestHandler(didResolver, messageStore, eventLog);
                // stub the `parse()` function to throw an error
                sinon.stub(PermissionsRequest, 'parse').throws('anyError');
                const reply = yield permissionsRequestHandler.handle({ tenant: alice.did, message });
                expect(reply.status.code).to.equal(400);
            }));
            describe('event log', () => {
                it('should add event for PermissionsRequest', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const { message } = yield TestDataGenerator.generatePermissionsRequest({
                        author: alice,
                        scope: {
                            interface: DwnInterfaceName.Records,
                            method: DwnMethodName.Write,
                        },
                    });
                    const reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    const events = yield eventLog.getEvents(alice.did);
                    expect(events.length).to.equal(1);
                    const messageCid = yield Message.getCid(message);
                    expect(events[0].messageCid).to.equal(messageCid);
                }));
                it('should not add a new event if we have already stored this PermissionsRequest', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const { message } = yield TestDataGenerator.generatePermissionsRequest({
                        author: alice,
                        scope: {
                            interface: DwnInterfaceName.Records,
                            method: DwnMethodName.Write,
                        },
                    });
                    let reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    const events = yield eventLog.getEvents(alice.did);
                    expect(events.length).to.equal(1);
                    const messageCid = yield Message.getCid(message);
                    expect(events[0].messageCid).to.equal(messageCid);
                }));
            });
        });
    });
}
//# sourceMappingURL=permissions-request.spec.js.map