var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import chatProtocolDefinition from '../vectors/protocol-definitions/chat.json' assert { type: 'json' };
import emailProtocolDefinition from '../vectors/protocol-definitions/email.json' assert { type: 'json' };
import sinon from 'sinon';
import socialMediaProtocolDefinition from '../vectors/protocol-definitions/social-media.json' assert { type: 'json' };
import chai, { expect } from 'chai';
import { ArrayUtility } from '../../src/utils/array.js';
import { authenticate } from '../../src/core/auth.js';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DwnErrorCode } from '../../src/core/dwn-error.js';
import { Encryption } from '../../src/utils/encryption.js';
import { HdKey } from '../../src/utils/hd-key.js';
import { KeyDerivationScheme } from '../../src/utils/hd-key.js';
import { RecordsReadHandler } from '../../src/handlers/records-read.js';
import { stubInterface } from 'ts-sinon';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { TestStubGenerator } from '../utils/test-stub-generator.js';
import { DataStream, DidResolver, Dwn, Jws, Protocols, ProtocolsConfigure, ProtocolsQuery, Records, RecordsDelete, RecordsRead, RecordsWrite, Secp256k1 } from '../../src/index.js';
chai.use(chaiAsPromised);
export function testRecordsReadHandler() {
    describe('RecordsReadHandler.handle()', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let dwn;
        describe('functional tests', () => {
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new DidResolver([new DidKeyResolver()]);
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should allow tenant to RecordsRead their own record', () => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const alice = yield DidKeyResolver.generate();
                // insert data
                const { message, dataStream, dataBytes } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // testing RecordsRead
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(alice)
                });
                const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(200);
                expect(readReply.record).to.exist;
                expect((_a = readReply.record) === null || _a === void 0 ? void 0 : _a.descriptor).to.exist;
                const dataFetched = yield DataStream.toBytes(readReply.record.data);
                expect(ArrayUtility.byteArraysEqual(dataFetched, dataBytes)).to.be.true;
            }));
            it('should not allow non-tenant to RecordsRead their a record data', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // insert data
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // testing RecordsRead
                const bob = yield DidKeyResolver.generate();
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(bob)
                });
                const readReply = yield dwn.processMessage(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(401);
            }));
            it('should allow reading of data that is published without `authorization`', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // insert public data
                const { message, dataStream, dataBytes } = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // testing public RecordsRead
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId
                });
                expect(recordsRead.author).to.be.undefined; // making sure no author/authorization is created
                const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(200);
                const dataFetched = yield DataStream.toBytes(readReply.record.data);
                expect(ArrayUtility.byteArraysEqual(dataFetched, dataBytes)).to.be.true;
            }));
            it('should allow an authenticated user to RecordRead data that is published', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                // insert public data
                const { message, dataStream, dataBytes } = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // testing public RecordsRead
                const bob = yield DidKeyResolver.generate();
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(bob)
                });
                const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(200);
                const dataFetched = yield DataStream.toBytes(readReply.record.data);
                expect(ArrayUtility.byteArraysEqual(dataFetched, dataBytes)).to.be.true;
            }));
            it('should allow a non-tenant to read RecordsRead data they have received', () => __awaiter(this, void 0, void 0, function* () {
                var _b;
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                // Alice inserts data with Bob as recipient
                const { message, dataStream, dataBytes } = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                    recipient: bob.did,
                });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // Bob reads the data that Alice sent him
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(bob)
                });
                const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(200);
                expect(readReply.record).to.exist;
                expect((_b = readReply.record) === null || _b === void 0 ? void 0 : _b.descriptor).to.exist;
                const dataFetched = yield DataStream.toBytes(readReply.record.data);
                expect(ArrayUtility.byteArraysEqual(dataFetched, dataBytes)).to.be.true;
            }));
            describe('protocol based reads', () => {
                it('should allow read with allow-anyone rule', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes an image to her DWN, then Bob reads the image because he is "anyone".
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const protocolDefinition = socialMediaProtocolDefinition;
                    // Install social-media protocol on Alice's DWN
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolWriteReply = yield dwn.processMessage(alice.did, protocolsConfig.message, protocolsConfig.dataStream);
                    expect(protocolWriteReply.status.code).to.equal(202);
                    // Alice writes image to her DWN
                    const encodedImage = new TextEncoder().encode('cafe-aesthetic.jpg');
                    const imageRecordsWrite = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'image',
                        schema: protocolDefinition.types.image.schema,
                        dataFormat: 'image/jpeg',
                        data: encodedImage,
                        recipient: alice.did
                    });
                    const imageReply = yield dwn.processMessage(alice.did, imageRecordsWrite.message, imageRecordsWrite.dataStream);
                    expect(imageReply.status.code).to.equal(202);
                    // Bob (anyone) reads the image that Alice wrote
                    const imageRecordsRead = yield RecordsRead.create({
                        recordId: imageRecordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(bob)
                    });
                    const imageReadReply = yield dwn.processMessage(alice.did, imageRecordsRead.message);
                    expect(imageReadReply.status.code).to.equal(200);
                }));
                it('should allow read with recipient rule', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice sends an email to Bob, then Bob reads the email.
                    //           ImposterBob tries and fails to read the email.
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const imposterBob = yield DidKeyResolver.generate();
                    const protocolDefinition = emailProtocolDefinition;
                    // Install email protocol on Alice's DWN
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolWriteReply = yield dwn.processMessage(alice.did, protocolsConfig.message, protocolsConfig.dataStream);
                    expect(protocolWriteReply.status.code).to.equal(202);
                    // Alice writes an email with Bob as recipient
                    const encodedEmail = new TextEncoder().encode('Dear Bob, hello!');
                    const emailRecordsWrite = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'email',
                        schema: protocolDefinition.types.email.schema,
                        dataFormat: protocolDefinition.types.email.dataFormats[0],
                        data: encodedEmail,
                        recipient: bob.did
                    });
                    const imageReply = yield dwn.processMessage(alice.did, emailRecordsWrite.message, emailRecordsWrite.dataStream);
                    expect(imageReply.status.code).to.equal(202);
                    // Bob reads Alice's email
                    const bobRecordsRead = yield RecordsRead.create({
                        recordId: emailRecordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(bob)
                    });
                    const bobReadReply = yield dwn.processMessage(alice.did, bobRecordsRead.message);
                    expect(bobReadReply.status.code).to.equal(200);
                    // ImposterBob is not able to read Alice's email
                    const imposterRecordsRead = yield RecordsRead.create({
                        recordId: emailRecordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(imposterBob)
                    });
                    const imposterReadReply = yield dwn.processMessage(alice.did, imposterRecordsRead.message);
                    expect(imposterReadReply.status.code).to.equal(401);
                    expect(imposterReadReply.status.detail).to.include(DwnErrorCode.ProtocolAuthorizationActionNotAllowed);
                }));
                it('should allow read with author rule', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Bob sends an email to Alice, then Bob reads the email.
                    //           ImposterBob tries and fails to read the email.
                    const alice = yield DidKeyResolver.generate();
                    const bob = yield DidKeyResolver.generate();
                    const imposterBob = yield DidKeyResolver.generate();
                    const protocolDefinition = emailProtocolDefinition;
                    // Install email protocol on Alice's DWN
                    const protocolsConfig = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition
                    });
                    const protocolWriteReply = yield dwn.processMessage(alice.did, protocolsConfig.message, protocolsConfig.dataStream);
                    expect(protocolWriteReply.status.code).to.equal(202);
                    // Alice writes an email with Bob as recipient
                    const encodedEmail = new TextEncoder().encode('Dear Alice, hello!');
                    const emailRecordsWrite = yield TestDataGenerator.generateRecordsWrite({
                        author: bob,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'email',
                        schema: protocolDefinition.types.email.schema,
                        dataFormat: protocolDefinition.types.email.dataFormats[0],
                        data: encodedEmail,
                        recipient: alice.did
                    });
                    const imageReply = yield dwn.processMessage(alice.did, emailRecordsWrite.message, emailRecordsWrite.dataStream);
                    expect(imageReply.status.code).to.equal(202);
                    // Bob reads the email he just sent
                    const bobRecordsRead = yield RecordsRead.create({
                        recordId: emailRecordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(bob)
                    });
                    const bobReadReply = yield dwn.processMessage(alice.did, bobRecordsRead.message);
                    expect(bobReadReply.status.code).to.equal(200);
                    // ImposterBob is not able to read the email
                    const imposterRecordsRead = yield RecordsRead.create({
                        recordId: emailRecordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(imposterBob)
                    });
                    const imposterReadReply = yield dwn.processMessage(alice.did, imposterRecordsRead.message);
                    expect(imposterReadReply.status.code).to.equal(401);
                    expect(imposterReadReply.status.detail).to.include(DwnErrorCode.ProtocolAuthorizationActionNotAllowed);
                }));
            });
            it('should return 404 RecordRead if data does not exist', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const recordsRead = yield RecordsRead.create({
                    recordId: `non-existent-record-id`,
                    authorizationSignatureInput: Jws.createSignatureInput(alice)
                });
                const readReply = yield dwn.processMessage(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(404);
            }));
            it('should return 404 RecordRead if data has been deleted', () => __awaiter(this, void 0, void 0, function* () {
                var _c;
                const alice = yield DidKeyResolver.generate();
                // insert public data
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice, published: true });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // ensure data is inserted
                const queryData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { recordId: message.recordId }
                });
                const reply = yield dwn.processMessage(alice.did, queryData.message);
                expect(reply.status.code).to.equal(200);
                expect((_c = reply.entries) === null || _c === void 0 ? void 0 : _c.length).to.equal(1);
                // RecordsDelete
                const recordsDelete = yield RecordsDelete.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(alice)
                });
                const deleteReply = yield dwn.processMessage(alice.did, recordsDelete.message);
                expect(deleteReply.status.code).to.equal(202);
                // RecordsRead
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(alice)
                });
                const readReply = yield dwn.processMessage(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(404);
            }));
            it('should return 404 underlying data store cannot locate the data', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                sinon.stub(dataStore, 'get').resolves(undefined);
                // insert data
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(writeReply.status.code).to.equal(202);
                // testing RecordsRead
                const recordsRead = yield RecordsRead.create({
                    recordId: message.recordId,
                    authorizationSignatureInput: Jws.createSignatureInput(alice)
                });
                const readReply = yield dwn.processMessage(alice.did, recordsRead.message);
                expect(readReply.status.code).to.equal(404);
            }));
            describe('encryption scenarios', () => {
                it('should be able to decrypt flat-space schema-contained record with a correct derived key', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes into her own DWN an encrypted record and she is able to decrypt it
                    const alice = yield TestDataGenerator.generatePersona();
                    TestStubGenerator.stubDidResolver(didResolver, [alice]);
                    // encrypt Alice's record
                    const originalData = TestDataGenerator.randomBytes(1000);
                    const originalDataStream = DataStream.fromBytes(originalData);
                    const dataEncryptionInitializationVector = TestDataGenerator.randomBytes(16);
                    const dataEncryptionKey = TestDataGenerator.randomBytes(32);
                    const encryptedDataStream = yield Encryption.aes256CtrEncrypt(dataEncryptionKey, dataEncryptionInitializationVector, originalDataStream);
                    const encryptedDataBytes = yield DataStream.toBytes(encryptedDataStream);
                    // TODO: #450 - Should not require a root key to specify the derivation scheme (https://github.com/TBD54566975/dwn-sdk-js/issues/450)
                    const rootPrivateKeyWithSchemasScheme = {
                        rootKeyId: alice.keyId,
                        derivationScheme: KeyDerivationScheme.Schemas,
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    const schema = 'https://some-schema.com';
                    const schemaDerivationPath = Records.constructKeyDerivationPathUsingSchemasScheme(schema);
                    const schemaDerivedPrivateKey = yield HdKey.derivePrivateKey(rootPrivateKeyWithSchemasScheme, schemaDerivationPath);
                    const schemaDerivedPublicKey = yield Secp256k1.getPublicJwk(schemaDerivedPrivateKey.derivedPrivateKey);
                    const rootPrivateKeyWithDataFormatsScheme = {
                        rootKeyId: alice.keyId,
                        derivationScheme: KeyDerivationScheme.DataFormats,
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    const dataFormat = 'some/format';
                    const dataFormatDerivationPath = Records.constructKeyDerivationPathUsingDataFormatsScheme(schema, dataFormat);
                    const dataFormatDerivedPublicKey = yield HdKey.derivePublicKey(rootPrivateKeyWithDataFormatsScheme, dataFormatDerivationPath);
                    const encryptionInput = {
                        initializationVector: dataEncryptionInitializationVector,
                        key: dataEncryptionKey,
                        keyEncryptionInputs: [{
                                publicKeyId: alice.keyId,
                                publicKey: schemaDerivedPublicKey,
                                derivationScheme: KeyDerivationScheme.Schemas
                            },
                            {
                                publicKeyId: alice.keyId,
                                publicKey: dataFormatDerivedPublicKey,
                                derivationScheme: KeyDerivationScheme.DataFormats
                            }]
                    };
                    const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({
                        author: alice,
                        schema,
                        dataFormat,
                        data: encryptedDataBytes,
                        encryptionInput
                    });
                    const writeReply = yield dwn.processMessage(alice.did, message, dataStream);
                    expect(writeReply.status.code).to.equal(202);
                    const recordsRead = yield RecordsRead.create({
                        recordId: message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(alice)
                    });
                    // test able to derive correct key using `schemas` scheme from root key to decrypt the message
                    const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                    expect(readReply.status.code).to.equal(200);
                    const unsignedRecordsWrite = readReply.record;
                    const cipherStream = readReply.record.data;
                    const plaintextDataStream = yield Records.decrypt(unsignedRecordsWrite, schemaDerivedPrivateKey, cipherStream);
                    const plaintextBytes = yield DataStream.toBytes(plaintextDataStream);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes, originalData)).to.be.true;
                    // test able to derive correct key using `dataFormat` scheme from root key to decrypt the message
                    const readReply2 = yield dwn.handleRecordsRead(alice.did, recordsRead.message); // send the same read message to get a new cipher stream
                    expect(readReply2.status.code).to.equal(200);
                    const cipherStream2 = readReply2.record.data;
                    const plaintextDataStream2 = yield Records.decrypt(unsignedRecordsWrite, rootPrivateKeyWithDataFormatsScheme, cipherStream2);
                    const plaintextBytes2 = yield DataStream.toBytes(plaintextDataStream2);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes2, originalData)).to.be.true;
                    // test unable to decrypt the message if dataFormat-derived key is derived without taking `schema` as input to derivation path
                    const readReply3 = yield dwn.handleRecordsRead(alice.did, recordsRead.message); // process the same read message to get a new cipher stream
                    expect(readReply3.status.code).to.equal(200);
                    const cipherStream3 = readReply3.record.data;
                    const invalidDerivationPath = [KeyDerivationScheme.DataFormats, message.descriptor.dataFormat];
                    const inValidDescendantPrivateKey = yield HdKey.derivePrivateKey(rootPrivateKeyWithDataFormatsScheme, invalidDerivationPath);
                    yield expect(Records.decrypt(unsignedRecordsWrite, inValidDescendantPrivateKey, cipherStream3)).to.be.rejectedWith(DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment);
                }));
                it('should be able to decrypt flat-space schema-less record with the correct derived key', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Alice writes into her own DWN an encrypted record and she is able to decrypt it
                    const alice = yield TestDataGenerator.generatePersona();
                    TestStubGenerator.stubDidResolver(didResolver, [alice]);
                    // encrypt Alice's record
                    const originalData = TestDataGenerator.randomBytes(1000);
                    const originalDataStream = DataStream.fromBytes(originalData);
                    const dataEncryptionInitializationVector = TestDataGenerator.randomBytes(16);
                    const dataEncryptionKey = TestDataGenerator.randomBytes(32);
                    const encryptedDataStream = yield Encryption.aes256CtrEncrypt(dataEncryptionKey, dataEncryptionInitializationVector, originalDataStream);
                    const encryptedDataBytes = yield DataStream.toBytes(encryptedDataStream);
                    // TODO: #450 - Should not require a root key to specify the derivation scheme (https://github.com/TBD54566975/dwn-sdk-js/issues/450)
                    const rootPrivateKeyWithDataFormatsScheme = {
                        rootKeyId: alice.keyId,
                        derivationScheme: KeyDerivationScheme.DataFormats,
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    const dataFormat = `image/jpg`;
                    const dataFormatDerivationPath = Records.constructKeyDerivationPathUsingDataFormatsScheme(undefined, dataFormat);
                    const dataFormatDerivedPublicKey = yield HdKey.derivePublicKey(rootPrivateKeyWithDataFormatsScheme, dataFormatDerivationPath);
                    const encryptionInput = {
                        initializationVector: dataEncryptionInitializationVector,
                        key: dataEncryptionKey,
                        keyEncryptionInputs: [{
                                publicKeyId: alice.keyId,
                                publicKey: dataFormatDerivedPublicKey,
                                derivationScheme: KeyDerivationScheme.DataFormats
                            }]
                    };
                    const recordsWrite = yield RecordsWrite.create({
                        authorizationSignatureInput: Jws.createSignatureInput(alice),
                        dataFormat,
                        data: encryptedDataBytes,
                        encryptionInput
                    });
                    const dataStream = DataStream.fromBytes(encryptedDataBytes);
                    const writeReply = yield dwn.processMessage(alice.did, recordsWrite.message, dataStream);
                    expect(writeReply.status.code).to.equal(202);
                    const recordsRead = yield RecordsRead.create({
                        recordId: recordsWrite.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(alice)
                    });
                    // test able to derive correct key using `dataFormat` scheme from root key to decrypt the message
                    const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message); // send the same read message to get a new cipher stream
                    expect(readReply.status.code).to.equal(200);
                    const cipherStream = readReply.record.data;
                    const unsignedRecordsWrite = readReply.record;
                    const plaintextDataStream = yield Records.decrypt(unsignedRecordsWrite, rootPrivateKeyWithDataFormatsScheme, cipherStream);
                    const plaintextBytes = yield DataStream.toBytes(plaintextDataStream);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes, originalData)).to.be.true;
                }));
                it('should only be able to decrypt record with a correct derived private key  - `protocol-context` derivation scheme', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Bob initiated an encrypted chat thread with Alice,
                    // bob is able to decrypt subsequent messages from Alice using the `protocol-context` derived private key
                    // creating Alice and Bob persona and setting up a stub DID resolver
                    const alice = yield TestDataGenerator.generatePersona();
                    const bob = yield TestDataGenerator.generatePersona();
                    TestStubGenerator.stubDidResolver(didResolver, [alice, bob]);
                    // Alice configures chat protocol with encryption
                    const protocolDefinition = chatProtocolDefinition;
                    const encryptedProtocolDefinitionForAlice = yield Protocols.deriveAndInjectPublicEncryptionKeys(protocolDefinition, alice.keyId, alice.keyPair.privateJwk);
                    const protocolsConfigureForAlice = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition: encryptedProtocolDefinitionForAlice
                    });
                    const protocolsConfigureForAliceReply = yield dwn.processMessage(alice.did, protocolsConfigureForAlice.message, protocolsConfigureForAlice.dataStream);
                    expect(protocolsConfigureForAliceReply.status.code).to.equal(202);
                    // Bob configures chat protocol with encryption
                    const encryptedProtocolDefinitionForBob = yield Protocols.deriveAndInjectPublicEncryptionKeys(protocolDefinition, bob.keyId, bob.keyPair.privateJwk);
                    const protocolsConfigureForBob = yield TestDataGenerator.generateProtocolsConfigure({
                        author: bob,
                        protocolDefinition: encryptedProtocolDefinitionForBob
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(bob.did, protocolsConfigureForBob.message, protocolsConfigureForBob.dataStream);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Bob queries for Alice's chat protocol definition
                    const protocolsQuery = yield ProtocolsQuery.create({
                        filter: { protocol: chatProtocolDefinition.protocol }
                    });
                    const protocolsQueryReply = yield dwn.processMessage(alice.did, protocolsQuery.message);
                    const protocolsConfigureMessageReceived = protocolsQueryReply.entries[0];
                    // Bob verifies that the chat protocol definition is authored by Alice
                    yield authenticate(protocolsConfigureMessageReceived.authorization, didResolver);
                    const protocolsConfigureFetched = yield ProtocolsConfigure.parse(protocolsConfigureMessageReceived);
                    expect(protocolsConfigureFetched.author).to.equal(alice.did);
                    // Bob creates an initiating a chat thread RecordsWrite
                    const plaintextMessageToAlice = TestDataGenerator.randomBytes(100);
                    const { message, dataStream, recordsWrite, encryptedDataBytes, encryptionInput } = yield TestDataGenerator.generateProtocolEncryptedRecordsWrite({
                        plaintextBytes: plaintextMessageToAlice,
                        author: bob,
                        targetProtocolDefinition: protocolsConfigureForAlice.message.descriptor.definition,
                        protocolPath: 'thread'
                    });
                    // Bob writes the encrypted chat thread to Alice's DWN
                    const bobToAliceWriteReply = yield dwn.processMessage(alice.did, message, dataStream);
                    expect(bobToAliceWriteReply.status.code).to.equal(202);
                    // Bob also needs to write the same encrypted chat thread to his own DWN
                    // Opportunity here to create a much nicer utility method for this entire block
                    const bobToBobRecordsWrite = yield RecordsWrite.createFrom({
                        unsignedRecordsWriteMessage: recordsWrite.message,
                        messageTimestamp: recordsWrite.message.descriptor.messageTimestamp
                    });
                    const bobRootPrivateKey = {
                        rootKeyId: bob.keyId,
                        derivationScheme: KeyDerivationScheme.ProtocolContext,
                        derivedPrivateKey: bob.keyPair.privateJwk
                    };
                    const protocolPathDerivationPath = Records.constructKeyDerivationPathUsingProtocolPathScheme(recordsWrite.message.descriptor);
                    const protocolPathDerivedPublicJwkForBobsDwn = yield HdKey.derivePublicKey(bobRootPrivateKey, protocolPathDerivationPath);
                    const protocolPathDerivedKeyEncryptionInputForBobsDwn = {
                        publicKeyId: bob.keyId,
                        publicKey: protocolPathDerivedPublicJwkForBobsDwn,
                        derivationScheme: KeyDerivationScheme.ProtocolPath
                    };
                    const encryptionInputForBobsDwn = encryptionInput;
                    const indexOfKeyEncryptionInputToReplace = encryptionInputForBobsDwn.keyEncryptionInputs.findIndex(input => input.derivationScheme === KeyDerivationScheme.ProtocolPath);
                    encryptionInputForBobsDwn.keyEncryptionInputs[indexOfKeyEncryptionInputToReplace] = protocolPathDerivedKeyEncryptionInputForBobsDwn;
                    yield bobToBobRecordsWrite.encryptSymmetricEncryptionKey(encryptionInputForBobsDwn);
                    yield bobToBobRecordsWrite.sign(Jws.createSignatureInput(bob));
                    const dataStreamForBobsDwn = DataStream.fromBytes(encryptedDataBytes);
                    const bobToBobWriteReply = yield dwn.processMessage(bob.did, bobToBobRecordsWrite.message, dataStreamForBobsDwn);
                    expect(bobToBobWriteReply.status.code).to.equal(202);
                    // NOTE: we know Alice is able to decrypt the message using protocol-path derived key through other tests, so we won't verify it again
                    // test that anyone with the protocol-context derived private key is able to decrypt the message
                    const recordsRead = yield RecordsRead.create({
                        recordId: message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(alice)
                    });
                    const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                    expect(readReply.status.code).to.equal(200);
                    const unsignedRecordsWrite = readReply.record;
                    const cipherStream = readReply.record.data;
                    const derivationPathFromReadContext = Records.constructKeyDerivationPathUsingProtocolContextScheme(unsignedRecordsWrite.contextId);
                    const protocolContextDerivedPrivateJwk = yield HdKey.derivePrivateKey(bobRootPrivateKey, derivationPathFromReadContext);
                    const plaintextDataStream = yield Records.decrypt(unsignedRecordsWrite, protocolContextDerivedPrivateJwk, cipherStream);
                    const plaintextBytes = yield DataStream.toBytes(plaintextDataStream);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes, plaintextMessageToAlice)).to.be.true;
                    // verify that Alice is able to send an encrypted message using the protocol-context derived public key and Bob is able to decrypt it
                    // NOTE: we will skip verification of Bob's protocol configuration because we have test the such scenario above as well as in other tests
                    const { derivedPublicKey: protocolContextDerivedPublicJwkReturned, rootKeyId: protocolContextDerivingRootKeyIdReturned } = unsignedRecordsWrite.encryption.keyEncryption.find(encryptedKey => encryptedKey.derivationScheme === KeyDerivationScheme.ProtocolContext);
                    const plaintextMessageToBob = TestDataGenerator.randomBytes(100);
                    const recordsWriteToBob = yield TestDataGenerator.generateProtocolEncryptedRecordsWrite({
                        plaintextBytes: plaintextMessageToBob,
                        author: alice,
                        targetProtocolDefinition: protocolsConfigureForBob.message.descriptor.definition,
                        protocolPath: 'thread/message',
                        protocolContextId: unsignedRecordsWrite.contextId,
                        protocolContextDerivingRootKeyId: protocolContextDerivingRootKeyIdReturned,
                        protocolContextDerivedPublicJwk: protocolContextDerivedPublicJwkReturned,
                        protocolParentId: unsignedRecordsWrite.recordId
                    });
                    // Alice sends the message to Bob
                    const aliceWriteReply = yield dwn.processMessage(bob.did, recordsWriteToBob.message, recordsWriteToBob.dataStream);
                    expect(aliceWriteReply.status.code).to.equal(202);
                    // test that Bob is able to read and decrypt Alice's message
                    const recordsReadByBob = yield RecordsRead.create({
                        recordId: recordsWriteToBob.message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(bob)
                    });
                    const readByBobReply = yield dwn.handleRecordsRead(bob.did, recordsReadByBob.message);
                    expect(readByBobReply.status.code).to.equal(200);
                    const unsignedRecordsWrite2 = readByBobReply.record;
                    const cipherStream2 = readByBobReply.record.data;
                    const plaintextDataStream2 = yield Records.decrypt(unsignedRecordsWrite2, protocolContextDerivedPrivateJwk, cipherStream2);
                    const plaintextBytes2 = yield DataStream.toBytes(plaintextDataStream2);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes2, plaintextMessageToBob)).to.be.true;
                }));
                it('should only be able to decrypt record with a correct derived private key  - `protocols` derivation scheme', () => __awaiter(this, void 0, void 0, function* () {
                    // scenario: Bob writes into Alice's DWN an encrypted "email", alice is able to decrypt it
                    var _a;
                    // creating Alice and Bob persona and setting up a stub DID resolver
                    const alice = yield TestDataGenerator.generatePersona();
                    const bob = yield TestDataGenerator.generatePersona();
                    TestStubGenerator.stubDidResolver(didResolver, [alice, bob]);
                    // Alice configures email protocol with encryption
                    const protocolDefinition = emailProtocolDefinition;
                    const encryptedProtocolDefinition = yield Protocols.deriveAndInjectPublicEncryptionKeys(protocolDefinition, alice.keyId, alice.keyPair.privateJwk);
                    const protocolsConfigure = yield TestDataGenerator.generateProtocolsConfigure({
                        author: alice,
                        protocolDefinition: encryptedProtocolDefinition
                    });
                    const protocolsConfigureReply = yield dwn.processMessage(alice.did, protocolsConfigure.message, protocolsConfigure.dataStream);
                    expect(protocolsConfigureReply.status.code).to.equal(202);
                    // Bob queries for Alice's email protocol definition
                    const protocolsQuery = yield ProtocolsQuery.create({
                        filter: { protocol: emailProtocolDefinition.protocol }
                    });
                    const protocolsQueryReply = yield dwn.processMessage(alice.did, protocolsQuery.message);
                    const protocolsConfigureMessageReceived = protocolsQueryReply.entries[0];
                    // Bob verifies that the email protocol definition is authored by Alice
                    yield authenticate(protocolsConfigureMessageReceived.authorization, didResolver);
                    const protocolsConfigureFetched = yield ProtocolsConfigure.parse(protocolsConfigureMessageReceived);
                    expect(protocolsConfigureFetched.author).to.equal(alice.did);
                    // Bob encrypts his email to Alice with a randomly generated symmetric key
                    const bobMessageBytes = TestDataGenerator.randomBytes(100);
                    const bobMessageStream = DataStream.fromBytes(bobMessageBytes);
                    const dataEncryptionInitializationVector = TestDataGenerator.randomBytes(16);
                    const dataEncryptionKey = TestDataGenerator.randomBytes(32);
                    const bobMessageEncryptedStream = yield Encryption.aes256CtrEncrypt(dataEncryptionKey, dataEncryptionInitializationVector, bobMessageStream);
                    const bobMessageEncryptedBytes = yield DataStream.toBytes(bobMessageEncryptedStream);
                    // Bob generates an encrypted RecordsWrite,
                    // the public encryption key designated by Alice is used to encrypt the symmetric key Bob generated above
                    const publicJwk = (_a = protocolsConfigureFetched.message.descriptor.definition.structure.email.$encryption) === null || _a === void 0 ? void 0 : _a.publicKeyJwk;
                    expect(publicJwk).to.not.be.undefined;
                    const encryptionInput = {
                        initializationVector: dataEncryptionInitializationVector,
                        key: dataEncryptionKey,
                        keyEncryptionInputs: [{
                                publicKeyId: alice.keyId,
                                publicKey: publicJwk,
                                derivationScheme: KeyDerivationScheme.ProtocolPath
                            }]
                    };
                    const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({
                        author: bob,
                        protocol: protocolDefinition.protocol,
                        protocolPath: 'email',
                        schema: protocolDefinition.types.email.schema,
                        dataFormat: protocolDefinition.types.email.dataFormats[0],
                        data: bobMessageEncryptedBytes,
                        encryptionInput
                    });
                    // Bob writes the encrypted email to Alice's DWN
                    const bobWriteReply = yield dwn.processMessage(alice.did, message, dataStream);
                    expect(bobWriteReply.status.code).to.equal(202);
                    // Alice reads the encrypted email
                    // assume Alice already made query to get the `recordId` of the email
                    const recordsRead = yield RecordsRead.create({
                        recordId: message.recordId,
                        authorizationSignatureInput: Jws.createSignatureInput(alice)
                    });
                    const readReply = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                    expect(readReply.status.code).to.equal(200);
                    // test that Alice is able decrypt the encrypted email from Bob using the root key
                    const rootPrivateKey = {
                        rootKeyId: alice.keyId,
                        derivationScheme: KeyDerivationScheme.ProtocolPath,
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    const unsignedRecordsWrite = readReply.record;
                    const cipherStream = readReply.record.data;
                    const plaintextDataStream = yield Records.decrypt(unsignedRecordsWrite, rootPrivateKey, cipherStream);
                    const plaintextBytes = yield DataStream.toBytes(plaintextDataStream);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes, bobMessageBytes)).to.be.true;
                    // test that a correct derived key is able decrypt the encrypted email from Bob
                    const readReply2 = yield dwn.handleRecordsRead(alice.did, recordsRead.message);
                    expect(readReply2.status.code).to.equal(200);
                    const relativeDescendantDerivationPath = Records.constructKeyDerivationPath(KeyDerivationScheme.ProtocolPath, unsignedRecordsWrite);
                    const derivedPrivateKey = yield HdKey.derivePrivateKey(rootPrivateKey, relativeDescendantDerivationPath);
                    const unsignedRecordsWrite2 = readReply2.record;
                    const cipherStream2 = readReply2.record.data;
                    const plaintextDataStream2 = yield Records.decrypt(unsignedRecordsWrite2, derivedPrivateKey, cipherStream2);
                    const plaintextBytes2 = yield DataStream.toBytes(plaintextDataStream2);
                    expect(ArrayUtility.byteArraysEqual(plaintextBytes2, bobMessageBytes)).to.be.true;
                    // test unable to decrypt the message if derived key has an unexpected path
                    const invalidDerivationPath = [KeyDerivationScheme.ProtocolPath, protocolDefinition.protocol, 'invalidContextId'];
                    const inValidDescendantPrivateKey = yield HdKey.derivePrivateKey(rootPrivateKey, invalidDerivationPath);
                    yield expect(Records.decrypt(unsignedRecordsWrite, inValidDescendantPrivateKey, cipherStream)).to.be.rejectedWith(DwnErrorCode.RecordsInvalidAncestorKeyDerivationSegment);
                    // test unable to decrypt the message if no derivation scheme used by the message matches the scheme used by the given private key
                    const privateKeyWithMismatchingDerivationScheme = {
                        rootKeyId: alice.keyId,
                        derivationScheme: 'scheme-that-is-not-protocol-context',
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    yield expect(Records.decrypt(unsignedRecordsWrite, privateKeyWithMismatchingDerivationScheme, cipherStream)).to.be.rejectedWith(DwnErrorCode.RecordsDecryptNoMatchingKeyEncryptedFound);
                    // test unable to decrypt the message if public key ID does not match the derived private key
                    const privateKeyWithMismatchingKeyId = {
                        rootKeyId: 'mismatchingKeyId',
                        derivationScheme: KeyDerivationScheme.ProtocolPath,
                        derivedPrivateKey: alice.keyPair.privateJwk
                    };
                    yield expect(Records.decrypt(unsignedRecordsWrite, privateKeyWithMismatchingKeyId, cipherStream)).to.be.rejectedWith(DwnErrorCode.RecordsDecryptNoMatchingKeyEncryptedFound);
                }));
            });
        });
        it('should return 401 if signature check fails', () => __awaiter(this, void 0, void 0, function* () {
            const alice = yield DidKeyResolver.generate();
            const recordsRead = yield RecordsRead.create({
                recordId: 'any-id',
                authorizationSignatureInput: Jws.createSignatureInput(alice)
            });
            // setting up a stub did resolver & message store
            // intentionally not supplying the public key so a different public key is generated to simulate invalid signature
            const mismatchingPersona = yield TestDataGenerator.generatePersona({ did: alice.did, keyId: alice.keyId });
            const didResolver = TestStubGenerator.createDidResolverStub(mismatchingPersona);
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsReadHandler = new RecordsReadHandler(didResolver, messageStore, dataStore);
            const reply = yield recordsReadHandler.handle({ tenant: alice.did, message: recordsRead.message });
            expect(reply.status.code).to.equal(401);
        }));
        it('should return 400 if fail parsing the message', () => __awaiter(this, void 0, void 0, function* () {
            const alice = yield DidKeyResolver.generate();
            const recordsRead = yield RecordsRead.create({
                recordId: 'any-id',
                authorizationSignatureInput: Jws.createSignatureInput(alice)
            });
            // setting up a stub method resolver & message store
            const messageStore = stubInterface();
            const dataStore = stubInterface();
            const recordsReadHandler = new RecordsReadHandler(didResolver, messageStore, dataStore);
            // stub the `parse()` function to throw an error
            sinon.stub(RecordsRead, 'parse').throws('anyError');
            const reply = yield recordsReadHandler.handle({ tenant: alice.did, message: recordsRead.message });
            expect(reply.status.code).to.equal(400);
        }));
    });
}
//# sourceMappingURL=records-read.spec.js.map