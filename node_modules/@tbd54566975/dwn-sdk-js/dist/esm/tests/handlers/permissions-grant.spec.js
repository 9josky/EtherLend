var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import sinon from 'sinon';
import { DidKeyResolver } from '../../src/did/did-key-resolver.js';
import { DidResolver } from '../../src/did/did-resolver.js';
import { Dwn } from '../../src/dwn.js';
import { DwnErrorCode } from '../../src/core/dwn-error.js';
import { expect } from 'chai';
import { Message } from '../../src/core/message.js';
import { PermissionsGrant } from '../../src/interfaces/permissions-grant.js';
import { PermissionsGrantHandler } from '../../src/handlers/permissions-grant.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
import { Time } from '../../src/utils/time.js';
import { DwnInterfaceName, DwnMethodName, Jws } from '../../src/index.js';
export function testPermissionsGrantHandler() {
    describe('PermissionsGrantHandler.handle()', () => {
        let didResolver;
        let messageStore;
        let dataStore;
        let eventLog;
        let dwn;
        describe('functional tests', () => {
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                didResolver = new DidResolver([new DidKeyResolver()]);
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                dataStore = stores.dataStore;
                eventLog = stores.eventLog;
                dwn = yield Dwn.create({ didResolver, messageStore, dataStore, eventLog });
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                sinon.restore(); // wipe all previous stubs/spies/mocks/fakes
                // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
                yield messageStore.clear();
                yield dataStore.clear();
                yield eventLog.clear();
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield dwn.close();
            }));
            it('should accept a PermissionsGrant with permissionsRequestId omitted', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsGrant({
                    author: alice,
                    grantedBy: alice.did,
                    grantedFor: alice.did,
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(202);
            }));
            it('should accept a PermissionsGrant with associated PermissionsRequest', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { permissionsRequest } = yield TestDataGenerator.generatePermissionsRequest({
                    author: alice,
                });
                const permissionsRequestReply = yield dwn.processMessage(alice.did, permissionsRequest.message);
                expect(permissionsRequestReply.status.code).to.equal(202);
                const { permissionsGrant } = yield TestDataGenerator.generatePermissionsGrant({
                    author: alice,
                    grantedBy: alice.did,
                    grantedFor: alice.did,
                    permissionsRequestId: yield Message.getCid(permissionsRequest.message),
                });
                const permissionsGrantReply = yield dwn.processMessage(alice.did, permissionsGrant.message);
                expect(permissionsGrantReply.status.code).to.equal(202);
            }));
            it('should return 401 if authentication fails', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                alice.keyId = 'wrongValue'; // to fail authentication
                const { message } = yield TestDataGenerator.generatePermissionsGrant({
                    author: alice,
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain('not a valid DID');
            }));
            it('should reject if author does not match grantedBy', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsGrant({
                    author: alice,
                    grantedBy: bob.did,
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain(DwnErrorCode.PermissionsGrantGrantedByMismatch);
            }));
            it('should reject if grantedBy is not a delegate and does not match grantedFor', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const bob = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsGrant({
                    author: alice,
                    grantedBy: alice.did,
                    grantedFor: bob.did,
                });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain(DwnErrorCode.PermissionsGrantUnauthorizedGrant);
            }));
            it('should return 400 if failure parsing the message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsGrant();
                const permissionsRequestHandler = new PermissionsGrantHandler(didResolver, messageStore, eventLog);
                // stub the `parse()` function to throw an error
                sinon.stub(PermissionsGrant, 'parse').throws('anyError');
                const reply = yield permissionsRequestHandler.handle({ tenant: alice.did, message });
                expect(reply.status.code).to.equal(400);
            }));
            describe('scope validation', () => {
                it('ensures that `schema` and protocol related fields `protocol`, `contextId` or `protocolPath` are not both present', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    // Options to create a grant with `schema` in its `scope`
                    const permissionsGrantBaseOptions = {
                        author: alice,
                        dateExpires: Time.getCurrentTimestamp(),
                        grantedBy: 'did:jank:bob',
                        grantedTo: 'did:jank:alice',
                        grantedFor: 'did:jank:bob',
                        scope: {
                            interface: DwnInterfaceName.Records,
                            method: DwnMethodName.Write,
                        }
                    };
                    // `schema` and `protocol` may not both be present in grant `scope`
                    const schemaAndProtocolGrant = yield TestDataGenerator.generatePermissionsGrant(permissionsGrantBaseOptions);
                    // Add `protocol` to `scope` and re-sign because validations upon message creation will reject it.
                    schemaAndProtocolGrant.message.descriptor.scope = {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        protocol: 'some-protocol'
                    };
                    schemaAndProtocolGrant.message.authorization = yield Message.createAuthorization({
                        descriptor: schemaAndProtocolGrant.message.descriptor,
                        signer: Jws.createSigner(alice)
                    });
                    const schemaAndProtocolGrantReply = yield dwn.processMessage(alice.did, schemaAndProtocolGrant.message);
                    expect(schemaAndProtocolGrantReply.status.code).to.eq(400);
                    expect(schemaAndProtocolGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsGrantScopeSchemaProhibitedFields);
                    // `schema` and `contextId` may not both be present in grant `scope`
                    const schemaAndContextIdGrant = yield TestDataGenerator.generatePermissionsGrant(permissionsGrantBaseOptions);
                    // Add `contextId` to `scope` and re-sign because validations upon message creation will reject it.
                    schemaAndContextIdGrant.message.descriptor.scope = {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        contextId: 'some-context-id'
                    };
                    schemaAndContextIdGrant.message.authorization = yield Message.createAuthorization({
                        descriptor: schemaAndContextIdGrant.message.descriptor,
                        signer: Jws.createSigner(alice)
                    });
                    const schemaAndContextIdGrantReply = yield dwn.processMessage(alice.did, schemaAndProtocolGrant.message);
                    expect(schemaAndContextIdGrantReply.status.code).to.eq(400);
                    expect(schemaAndContextIdGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsGrantScopeSchemaProhibitedFields);
                    // `schema` and `protocolPath` may not both be present in grant `scope`
                    const schemaAndProtocolPathGrant = yield TestDataGenerator.generatePermissionsGrant(permissionsGrantBaseOptions);
                    // Add `protocolPath` to `scope` and re-sign because validations upon message creation will reject it.
                    schemaAndProtocolPathGrant.message.descriptor.scope = {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        schema: 'some-schema',
                        protocolPath: 'some-protocol-path'
                    };
                    schemaAndProtocolPathGrant.message.authorization = yield Message.createAuthorization({
                        descriptor: schemaAndProtocolPathGrant.message.descriptor,
                        signer: Jws.createSigner(alice)
                    });
                    const schemaAndProtocolPathGrantReply = yield dwn.processMessage(alice.did, schemaAndProtocolGrant.message);
                    expect(schemaAndProtocolPathGrantReply.status.code).to.eq(400);
                    expect(schemaAndProtocolPathGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsGrantScopeSchemaProhibitedFields);
                }));
                it('ensures that `contextId` and `protocolPath` are not both present in grant scope', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const contextIdAndProtocolPathGrant = yield TestDataGenerator.generatePermissionsGrant({
                        author: alice,
                        dateExpires: Time.getCurrentTimestamp(),
                        grantedBy: 'did:jank:bob',
                        grantedTo: 'did:jank:alice',
                        grantedFor: 'did:jank:bob',
                        scope: {
                            interface: DwnInterfaceName.Records,
                            method: DwnMethodName.Write,
                        }
                    });
                    // Add `protocolPath` and `contextId` to `scope` and re-sign because validations upon message creation will reject it.
                    contextIdAndProtocolPathGrant.message.descriptor.scope = {
                        interface: DwnInterfaceName.Records,
                        method: DwnMethodName.Write,
                        protocol: 'some-protocol',
                        contextId: 'some-context-id',
                        protocolPath: 'some-protocol-path',
                    };
                    contextIdAndProtocolPathGrant.message.authorization = yield Message.createAuthorization({
                        descriptor: contextIdAndProtocolPathGrant.message.descriptor,
                        signer: Jws.createSigner(alice)
                    });
                    const contextIdAndProtocolPathGrantReply = yield dwn.processMessage(alice.did, contextIdAndProtocolPathGrant.message);
                    expect(contextIdAndProtocolPathGrantReply.status.code).to.eq(400);
                    expect(contextIdAndProtocolPathGrantReply.status.detail).to.contain(DwnErrorCode.PermissionsGrantScopeContextIdAndProtocolPath);
                }));
            });
            describe('event log', () => {
                it('should add event for PermissionsGrant', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const { message } = yield TestDataGenerator.generatePermissionsGrant({
                        author: alice,
                        grantedBy: alice.did,
                    });
                    const reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    const events = yield eventLog.getEvents(alice.did);
                    expect(events.length).to.equal(1);
                    const messageCid = yield Message.getCid(message);
                    expect(events[0].messageCid).to.equal(messageCid);
                }));
                it('should not add a new event if we have already stored this PermissionsRequest', () => __awaiter(this, void 0, void 0, function* () {
                    const alice = yield DidKeyResolver.generate();
                    const { message } = yield TestDataGenerator.generatePermissionsGrant({
                        author: alice,
                        grantedBy: alice.did,
                    });
                    let reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    reply = yield dwn.processMessage(alice.did, message);
                    expect(reply.status.code).to.equal(202);
                    const events = yield eventLog.getEvents(alice.did);
                    expect(events.length).to.equal(1);
                    const messageCid = yield Message.getCid(message);
                    expect(events[0].messageCid).to.equal(messageCid);
                }));
            });
        });
    });
}
//# sourceMappingURL=permissions-grant.spec.js.map