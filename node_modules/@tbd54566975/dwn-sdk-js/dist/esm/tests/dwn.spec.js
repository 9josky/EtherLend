var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import chai, { expect } from 'chai';
import { DidKeyResolver } from '../src/did/did-key-resolver.js';
import { Dwn } from '../src/dwn.js';
import { Message } from '../src/core/message.js';
import { stubInterface } from 'ts-sinon';
import { TestDataGenerator } from './utils/test-data-generator.js';
import { TestStores } from './test-stores.js';
import { DwnInterfaceName, DwnMethodName, Encoder } from '../src/index.js';
chai.use(chaiAsPromised);
export function testDwnClass() {
    describe('DWN', () => {
        let messageStore;
        let dataStore;
        let eventLog;
        let dwn;
        // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
        // so that different test suites can reuse the same backend store for testing
        before(() => __awaiter(this, void 0, void 0, function* () {
            const stores = TestStores.get();
            messageStore = stores.messageStore;
            dataStore = stores.dataStore;
            eventLog = stores.eventLog;
            dwn = yield Dwn.create({ messageStore, dataStore, eventLog });
        }));
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            sinon.restore(); // wipe all stubs/spies/mocks/fakes from previous test
            yield messageStore.clear(); // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield dwn.close();
        }));
        describe('processMessage()', () => {
            it('should process RecordsWrite message signed by a `did:key` DID', () => __awaiter(this, void 0, void 0, function* () {
                // generate a `did:key` DID
                const alice = yield DidKeyResolver.generate();
                const { message, dataStream } = yield TestDataGenerator.generateRecordsWrite({
                    author: alice,
                });
                const reply = yield dwn.processMessage(alice.did, message, dataStream);
                expect(reply.status.code).to.equal(202);
            }));
            it('should process RecordsQuery message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { author, message } = yield TestDataGenerator.generateRecordsQuery({ author: alice });
                const tenant = author.did;
                const reply = yield dwn.processMessage(tenant, message);
                expect(reply.status.code).to.equal(200);
                expect(reply.entries).to.be.empty;
            }));
            it('should process an EventsGet message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generateEventsGet({ author: alice });
                const reply = yield dwn.processMessage(alice.did, message);
                expect(reply.status.code).to.equal(200);
                expect(reply.events).to.be.empty;
                expect(reply.data).to.not.exist;
            }));
            it('#191 - regression - should run JSON schema validation', () => __awaiter(this, void 0, void 0, function* () {
                const invalidMessage = {
                    descriptor: {
                        interface: 'Records',
                        method: 'Read',
                        messageTimestamp: '2023-07-25T10:20:30.123456Z'
                    },
                    authorization: {}
                };
                const validateJsonSchemaSpy = sinon.spy(Message, 'validateJsonSchema');
                const alice = yield DidKeyResolver.generate();
                const reply = yield dwn.processMessage(alice.did, invalidMessage);
                sinon.assert.calledOnce(validateJsonSchemaSpy);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(`must have required property 'filter'`);
            }));
            it('should throw 400 if given no interface or method found in message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const reply1 = yield dwn.processMessage(alice.did, undefined); // missing message entirely, thus missing both `interface` and `method`
                expect(reply1.status.code).to.equal(400);
                expect(reply1.status.detail).to.contain('Both interface and method must be present');
                const reply2 = yield dwn.processMessage(alice.did, { descriptor: { method: 'anyValue' } }); // missing `interface`
                expect(reply2.status.code).to.equal(400);
                expect(reply2.status.detail).to.contain('Both interface and method must be present');
                const reply3 = yield dwn.processMessage(alice.did, { descriptor: { interface: 'anyValue' } }); // missing `method`
                expect(reply3.status.code).to.equal(400);
                expect(reply3.status.detail).to.contain('Both interface and method must be present');
            }));
            it('should throw 401 if message is targeted at a non-tenant', () => __awaiter(this, void 0, void 0, function* () {
                // tenant gate that blocks everyone
                const blockAllTenantGate = {
                    isTenant() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return false;
                        });
                    }
                };
                const messageStoreStub = stubInterface();
                const dataStoreStub = stubInterface();
                const eventLogStub = stubInterface();
                const dwnWithConfig = yield Dwn.create({
                    tenantGate: blockAllTenantGate,
                    messageStore: messageStoreStub,
                    dataStore: dataStoreStub,
                    eventLog: eventLogStub
                });
                const alice = yield DidKeyResolver.generate();
                const { author, message } = yield TestDataGenerator.generateRecordsQuery({ author: alice });
                const tenant = author.did;
                const reply = yield dwnWithConfig.processMessage(tenant, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain('not a tenant');
            }));
        });
        describe('synchronizePrunedInitialRecordsWrite()', () => {
            it('should allow an initial `RecordsWrite` to be written without supplying data', () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                const alice = yield DidKeyResolver.generate();
                const { recordsWrite } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                // simulate synchronize of pruned initial `RecordsWrite`
                const reply = yield dwn.synchronizePrunedInitialRecordsWrite(alice.did, recordsWrite.message);
                expect(reply.status.code).to.equal(202);
                // verify `RecordsWrite` inserted can be queried but without the data returned
                const recordsQueryMessageData = yield TestDataGenerator.generateRecordsQuery({
                    author: alice,
                    filter: { recordId: recordsWrite.message.recordId }
                });
                const recordsQueryReply = yield dwn.processMessage(alice.did, recordsQueryMessageData.message);
                expect(recordsQueryReply.status.code).to.equal(200);
                expect((_a = recordsQueryReply.entries) === null || _a === void 0 ? void 0 : _a.length).to.equal(1);
                expect(recordsQueryReply.entries[0].encodedData).to.not.exist;
                // generate and write a new `RecordsWrite` to overwrite the existing record
                const newDataBytes = Encoder.stringToBytes('new data');
                const newDataEncoded = Encoder.bytesToBase64Url(newDataBytes);
                const newRecordsWrite = yield TestDataGenerator.generateFromRecordsWrite({
                    author: alice,
                    existingWrite: recordsWrite,
                    data: newDataBytes
                });
                const newRecordsWriteReply = yield dwn.processMessage(alice.did, newRecordsWrite.message, newRecordsWrite.dataStream);
                expect(newRecordsWriteReply.status.code).to.equal(202);
                // verify new `RecordsWrite` has overwritten the existing record with new data
                const newRecordsQueryReply = yield dwn.processMessage(alice.did, recordsQueryMessageData.message);
                expect(newRecordsQueryReply.status.code).to.equal(200);
                expect((_b = newRecordsQueryReply.entries) === null || _b === void 0 ? void 0 : _b.length).to.equal(1);
                expect(newRecordsQueryReply.entries[0].encodedData).to.equal(newDataEncoded);
            }));
            it('should throw 401 if message is targeted at a non-tenant', () => __awaiter(this, void 0, void 0, function* () {
                // tenant gate that blocks everyone
                const blockAllTenantGate = {
                    isTenant() {
                        return __awaiter(this, void 0, void 0, function* () {
                            return false;
                        });
                    }
                };
                const messageStoreStub = stubInterface();
                const dataStoreStub = stubInterface();
                const eventLogStub = stubInterface();
                const dwnWithConfig = yield Dwn.create({
                    tenantGate: blockAllTenantGate,
                    messageStore: messageStoreStub,
                    dataStore: dataStoreStub,
                    eventLog: eventLogStub
                });
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generateRecordsWrite({ author: alice });
                const reply = yield dwnWithConfig.synchronizePrunedInitialRecordsWrite(alice.did, message);
                expect(reply.status.code).to.equal(401);
                expect(reply.status.detail).to.contain('not a tenant');
            }));
            it('should run JSON schema validation', () => __awaiter(this, void 0, void 0, function* () {
                const invalidMessage = {
                    descriptor: {
                        interface: 'Records',
                        method: 'Write'
                    },
                    authorization: {}
                };
                const validateJsonSchemaSpy = sinon.spy(Message, 'validateJsonSchema');
                const alice = yield DidKeyResolver.generate();
                const reply = yield dwn.synchronizePrunedInitialRecordsWrite(alice.did, invalidMessage);
                sinon.assert.calledOnce(validateJsonSchemaSpy);
                expect(reply.status.code).to.equal(400);
                expect(reply.status.detail).to.contain(`must have required property`);
            }));
            it('should throw 400 if given incorrect DWN interface or method', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const reply1 = yield dwn.synchronizePrunedInitialRecordsWrite(alice.did, undefined); // missing message
                expect(reply1.status.code).to.equal(400);
                expect(reply1.status.detail).to.contain('Both interface and method must be present');
                const reply2 = yield dwn.synchronizePrunedInitialRecordsWrite(alice.did, { descriptor: { interface: 'IncorrectInterface', method: DwnMethodName.Write } });
                expect(reply2.status.code).to.equal(400);
                expect(reply2.status.detail).to.contain(`Expected interface ${DwnInterfaceName.Records}`);
                const reply3 = yield dwn.synchronizePrunedInitialRecordsWrite(alice.did, { descriptor: { interface: DwnInterfaceName.Records, method: 'IncorrectMethod' } });
                expect(reply3.status.code).to.equal(400);
                expect(reply3.status.detail).to.contain(`Expected method ${DwnInterfaceName.Records}${DwnMethodName.Write}`);
            }));
        });
    });
}
//# sourceMappingURL=dwn.spec.js.map