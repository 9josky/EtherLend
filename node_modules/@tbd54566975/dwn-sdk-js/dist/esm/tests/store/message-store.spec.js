var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { DidKeyResolver } from '../../src/index.js';
import { expect } from 'chai';
import { Message } from '../../src/core/message.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import { TestStores } from '../test-stores.js';
let messageStore;
export function testMessageStore() {
    describe('Generic MessageStore Test Suite', () => {
        describe('put', function () {
            // important to follow the `before` and `after` pattern to initialize and clean the stores in tests
            // so that different test suites can reuse the same backend store for testing
            before(() => __awaiter(this, void 0, void 0, function* () {
                const stores = TestStores.get();
                messageStore = stores.messageStore;
                yield messageStore.open();
            }));
            beforeEach(() => __awaiter(this, void 0, void 0, function* () {
                yield messageStore.clear(); // clean up before each test rather than after so that a test does not depend on other tests to do the clean up
            }));
            after(() => __awaiter(this, void 0, void 0, function* () {
                yield messageStore.close();
            }));
            it('stores messages as cbor/sha256 encoded blocks with CID as key', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generatePermissionsRequest();
                yield messageStore.put(alice.did, message, {});
                const expectedCid = yield Message.getCid(message);
                const jsonMessage = (yield messageStore.get(alice.did, expectedCid));
                const resultCid = yield Message.getCid(jsonMessage);
                expect(resultCid).to.equal(expectedCid);
            }));
            // https://github.com/TBD54566975/dwn-sdk-js/issues/170
            it('#170 - should be able to update (delete and insert new) indexes to an existing message', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generateRecordsWrite();
                // inserting the message indicating it is the 'latest' in the index
                yield messageStore.put(alice.did, message, { latest: 'true' });
                const results1 = yield messageStore.query(alice.did, { latest: 'true' });
                expect(results1.length).to.equal(1);
                const results2 = yield messageStore.query(alice.did, { latest: 'false' });
                expect(results2.length).to.equal(0);
                // deleting the existing indexes and replacing it indicating it is no longer the 'latest'
                const cid = yield Message.getCid(message);
                yield messageStore.delete(alice.did, cid);
                yield messageStore.put(alice.did, message, { latest: 'false' });
                const results3 = yield messageStore.query(alice.did, { latest: 'true' });
                expect(results3.length).to.equal(0);
                const results4 = yield messageStore.query(alice.did, { latest: 'false' });
                expect(results4.length).to.equal(1);
            }));
            it('should index properties with characters beyond just letters and digits', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const schema = 'http://my-awesome-schema/awesomeness_schema';
                const { message } = yield TestDataGenerator.generateRecordsWrite({ schema });
                yield messageStore.put(alice.did, message, { schema });
                const results = yield messageStore.query(alice.did, { schema });
                expect(results[0].descriptor.schema).to.equal(schema);
            }));
            it('should not store anything if aborted beforehand', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const { message } = yield TestDataGenerator.generateRecordsWrite();
                const controller = new AbortController();
                controller.signal.throwIfAborted = () => { }; // simulate aborting happening async
                controller.abort('reason');
                try {
                    yield messageStore.put(alice.did, message, {}, { signal: controller.signal });
                }
                catch (e) {
                    expect(e).to.equal('reason');
                }
                const expectedCid = yield Message.getCid(message);
                const jsonMessage = yield messageStore.get(alice.did, expectedCid);
                expect(jsonMessage).to.equal(undefined);
            }));
            it('should not index anything if aborted during', () => __awaiter(this, void 0, void 0, function* () {
                const alice = yield DidKeyResolver.generate();
                const schema = 'http://my-awesome-schema/awesomeness_schema#awesome-1?id=awesome_1';
                const { message } = yield TestDataGenerator.generateRecordsWrite({ schema });
                const controller = new AbortController();
                queueMicrotask(() => {
                    controller.abort('reason');
                });
                try {
                    yield messageStore.put(alice.did, message, { schema }, { signal: controller.signal });
                }
                catch (e) {
                    expect(e).to.equal('reason');
                }
                const results = yield messageStore.query(alice.did, { schema });
                expect(results.length).to.equal(0);
            }));
        });
    });
}
//# sourceMappingURL=message-store.spec.js.map