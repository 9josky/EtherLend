var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import chaiAsPromised from 'chai-as-promised';
import { EventLogLevel } from '../../src/event-log/event-log-level.js';
import { Message } from '../../src/core/message.js';
import { TestDataGenerator } from '../utils/test-data-generator.js';
import chai, { expect } from 'chai';
chai.use(chaiAsPromised);
let eventLog;
describe('EventLogLevel Tests', () => {
    before(() => __awaiter(void 0, void 0, void 0, function* () {
        eventLog = new EventLogLevel({ location: 'TEST-EVENTLOG' });
        yield eventLog.open();
    }));
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield eventLog.clear();
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
        yield eventLog.close();
    }));
    it('separates events by tenant', () => __awaiter(void 0, void 0, void 0, function* () {
        const { author, message } = yield TestDataGenerator.generateRecordsWrite();
        const messageCid = yield Message.getCid(message);
        const watermark = yield eventLog.append(author.did, messageCid);
        const { author: author2, message: message2 } = yield TestDataGenerator.generateRecordsWrite();
        const messageCid2 = yield Message.getCid(message2);
        const watermark2 = yield eventLog.append(author2.did, messageCid2);
        let events = yield eventLog.getEvents(author.did);
        expect(events.length).to.equal(1);
        expect(events[0].watermark).to.equal(watermark);
        expect(events[0].messageCid).to.equal(messageCid);
        events = yield eventLog.getEvents(author2.did);
        expect(events.length).to.equal(1);
        expect(events[0].watermark).to.equal(watermark2);
        expect(events[0].messageCid).to.equal(messageCid2);
    }));
    it('returns events in the order that they were appended', () => __awaiter(void 0, void 0, void 0, function* () {
        const expectedEvents = [];
        const { author, message } = yield TestDataGenerator.generateRecordsWrite();
        const messageCid = yield Message.getCid(message);
        const watermark = yield eventLog.append(author.did, messageCid);
        expectedEvents.push({ watermark, messageCid });
        for (let i = 0; i < 9; i += 1) {
            const { message } = yield TestDataGenerator.generateRecordsWrite({ author });
            const messageCid = yield Message.getCid(message);
            const watermark = yield eventLog.append(author.did, messageCid);
            expectedEvents.push({ watermark, messageCid });
        }
        const events = yield eventLog.getEvents(author.did);
        expect(events.length).to.equal(expectedEvents.length);
        for (let i = 0; i < 10; i += 1) {
            expect(events[i].watermark).to.equal(expectedEvents[i].watermark);
            expect(events[i].messageCid).to.equal(expectedEvents[i].messageCid);
        }
    }));
    describe('getEventsAfter', () => {
        it('gets all events for a tenant if watermark is not provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const expectedEvents = [];
            const { author, message } = yield TestDataGenerator.generateRecordsWrite();
            const messageCid = yield Message.getCid(message);
            const watermark = yield eventLog.append(author.did, messageCid);
            expectedEvents.push({ messageCid, watermark });
            for (let i = 0; i < 9; i += 1) {
                const { message } = yield TestDataGenerator.generateRecordsWrite({ author });
                const messageCid = yield Message.getCid(message);
                const watermark = yield eventLog.append(author.did, messageCid);
                expectedEvents.push({ messageCid, watermark });
            }
            const events = yield eventLog.getEvents(author.did);
            expect(events.length).to.equal(10);
            for (let i = 0; i < events.length; i += 1) {
                expect(events[i].messageCid).to.equal(expectedEvents[i].messageCid);
                expect(events[i].watermark).to.equal(expectedEvents[i].watermark);
            }
        }));
        it('gets all events that occured after the watermark provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const { author, message } = yield TestDataGenerator.generateRecordsWrite();
            const messageCid = yield Message.getCid(message);
            yield eventLog.append(author.did, messageCid);
            const messageCids = [];
            let testWatermark = '';
            for (let i = 0; i < 9; i += 1) {
                const { message } = yield TestDataGenerator.generateRecordsWrite({ author });
                const messageCid = yield Message.getCid(message);
                const watermark = yield eventLog.append(author.did, messageCid);
                if (i === 4) {
                    testWatermark = watermark;
                }
                if (i > 4) {
                    messageCids.push(messageCid);
                }
            }
            const events = yield eventLog.getEvents(author.did, { gt: testWatermark });
            expect(events.length).to.equal(4);
            for (let i = 0; i < events.length; i += 1) {
                expect(events[i].messageCid).to.equal(messageCids[i], `${i}`);
            }
        }));
    });
    describe('deleteEventsByCid', () => {
        it('finds and deletes events that whose values match the cids provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const cids = [];
            const { author, message } = yield TestDataGenerator.generateRecordsWrite();
            const messageCid = yield Message.getCid(message);
            yield eventLog.append(author.did, messageCid);
            for (let i = 0; i < 9; i += 1) {
                const { message } = yield TestDataGenerator.generateRecordsWrite({ author });
                const messageCid = yield Message.getCid(message);
                yield eventLog.append(author.did, messageCid);
                if (i % 2 === 0) {
                    cids.push(messageCid);
                }
            }
            const numEventsDeleted = yield eventLog.deleteEventsByCid(author.did, cids);
            expect(numEventsDeleted).to.equal(cids.length);
            const remainingEvents = yield eventLog.getEvents(author.did);
            expect(remainingEvents.length).to.equal(10 - cids.length);
            const cidSet = new Set(cids);
            for (const event of remainingEvents) {
                if (cidSet.has(event.messageCid)) {
                    expect.fail(`${event.messageCid} should not exist`);
                }
            }
        }));
    });
});
//# sourceMappingURL=event-log-level.spec.js.map